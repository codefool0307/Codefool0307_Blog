<!--
 * @Author: 孙浩然
 * @Date: 2020-05-25 06:42:24
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-05-25 07:52:13
 * @FilePath: \docs\9.interview\6-框架面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
# 1.框架-spring-spring基础
## 问题1：什么是spring？


# 2.框架-spring-spring bean
## 问题1：spring bean原理

bean就是由IOC容器初始化、装配及管理的Java对象

## 问题2：spring bean的作用域：

springbean的作用域一共分为了五种：

1. singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
2. prototype : 每次请求都会创建一个新的 bean 实例。
3. request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
4. session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
5. global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话


## 问题3：spring bean的生命周期：

1. 首先容器启动后，会对scope为sigleton且非懒加载的bean进行实例化
2. 按照bean定义的信心配置信息，注入所有的属性
3. 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。
4. 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。
5. 类似的，如果实现了其他 *.Aware接口，就调用相应的方法。
6. 如果有bean实现了BeanPostProcessor对象，执行postProcessBeforeInitialization() 方法
7. 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。
8. 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
9. 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法
10. 此时前期工作完成就可以正式使用bean了。如果scope是singleton，spring的ioc会缓存一份bean的实例，如果scope是prototye，会创建一个新的对象
11. 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
12. 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

## 问题4：spring IOC原理

1. IoC是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。

2. 我认为 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 

3. 比如说某个类，我还不太了解他的底层，但是任务比较着急，没办法太自信看，使用IOC的hauler，只要配置好，在该引用的地方引用就好了

## 问题5；BeanFactory和ApplicationContext区别

1. bean的实例化上
  * BeanFactory在启动的时候不会去实例化Bean，只有从容器中拿Bean的时候才会去实例化；
  * ApplicationContext在启动的时候就把所有的Bean全部实例化了。
2. ApplicationContext是对BeanFactory的扩展，提供了更多的功能，如：自动注册，声明方式创建，国际化处理等等

## 问题6：简述AOP原理

AOP就是基于动态代理的，AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

## 问题7：深入说一下AOP

AOP代理主要分为了静态代理和动态代理。静态代理代表为AspectJ，动态代理则以Spring AOP为代表

未完

# 4.框架-spring-springmvc流程
## 问题2：spring事务管理



# x.框架-springmvc-springmvc流程

## 问题1：springmvc的流程