
<!-- TOC -->autoauto- [--------------JVM--------------------------------------------------------------------------------------](#--------------jvm--------------------------------------------------------------------------------------)auto- [1. JVM](#1-jvm)auto    - [1-1：JVM1.8新特性](#1-1jvm18新特性)auto    - [1-2：JDK1.8默认垃圾回收器](#1-2jdk18默认垃圾回收器)auto- [2.类加载](#2类加载)auto    - [1-1：类的生命周期](#1-1类的生命周期)auto    - [1-2：类的加载过程（37期）](#1-2类的加载过程37期)auto        - [1-2-1：符号引用于直接饮用](#1-2-1符号引用于直接饮用)auto    - [1-3：类加载机制](#1-3类加载机制)auto    - [1-4：知道哪些类加载器?](#1-4知道哪些类加载器)auto        - [1-4-1：类加载器之间的关系](#1-4-1类加载器之间的关系)auto    - [1-5：创建并使用自定义类加载器](#1-5创建并使用自定义类加载器)auto    - [1-5：双亲委派模型流程](#1-5双亲委派模型流程)auto        - [1-5-1：双亲委派模型带来了什么好处呢？](#1-5-1双亲委派模型带来了什么好处呢)auto        - [1-5-2：如果我们不想⽤双亲委派模型怎么办？](#1-5-2如果我们不想⽤双亲委派模型怎么办)auto        - [1-5-3：自己写一个类能不能被加载？](#1-5-3自己写一个类能不能被加载)auto        - [1-5-4：如何破坏双亲委派机制](#1-5-4如何破坏双亲委派机制)auto- [3.垃圾回收](#3垃圾回收)auto    - [3-1：什么是GC](#3-1什么是gc)auto        - [3-1-1：垃圾回收的优点](#3-1-1垃圾回收的优点)auto        - [3-1-2：什么样的对象需要回收](#3-1-2什么样的对象需要回收)auto        - [3-1-3：垃圾回收器可以马上回收内存吗？](#3-1-3垃圾回收器可以马上回收内存吗)auto        - [3-1-4：有什么办法主动通知虚拟机进行垃圾回收？](#3-1-4有什么办法主动通知虚拟机进行垃圾回收)auto    - [3-2：垃圾回收器的基本原理是什么？](#3-2垃圾回收器的基本原理是什么)auto    - [3-3：如何判断对象已经死亡？](#3-3如何判断对象已经死亡)auto        - [3-3-1：可作为GC Roots的对象？](#3-3-1可作为gc-roots的对象)auto        - [3-3-2：不可达的对象是否非死不可](#3-3-2不可达的对象是否非死不可)auto    - [3-4：如何判断一个类是无用的类](#3-4如何判断一个类是无用的类)auto    - [3-5：如何判断一个常量是废弃常量？](#3-5如何判断一个常量是废弃常量)auto    - [3-6：如何减少 GC 的次数](#3-6如何减少-gc-的次数)auto    - [3-7：垃圾回收算法](#3-7垃圾回收算法)auto    - [3-8：垃圾回收器](#3-8垃圾回收器)auto        - [3-8-1：Serial收集器](#3-8-1serial收集器)auto        - [3-8-2：ParNew收集器](#3-8-2parnew收集器)auto        - [3-8-3：Parallel Scavenge收集器](#3-8-3parallel-scavenge收集器)auto        - [3-8-4：Serial Old收集器](#3-8-4serial-old收集器)auto        - [3-8-5：Parallel Old收集器](#3-8-5parallel-old收集器)auto        - [3-8-6：CMS收集器](#3-8-6cms收集器)auto            - [3-8-6-1：产生 concurrent mode failure 真正的原因](#3-8-6-1产生-concurrent-mode-failure-真正的原因)auto            - [3-8-6-2：CMS 出现FullGC的原因](#3-8-6-2cms-出现fullgc的原因)auto            - [3-8-6-3：cms怎么解决内存碎片的问题](#3-8-6-3cms怎么解决内存碎片的问题)auto            - [3-8-6-4：CMS GC发生concurrent mode failure时的full GC为什么是单线程的?](#3-8-6-4cms-gc发生concurrent-mode-failure时的full-gc为什么是单线程的)auto        - [3-8-7：G1收集器](#3-8-7g1收集器)auto        - [3-8-8：CMS与G1区别](#3-8-8cms与g1区别)auto        - [3-8-9：吞吐有限和响应有限的垃圾收集器如何选择](#3-8-9吞吐有限和响应有限的垃圾收集器如何选择)auto    - [3-9：为什么要分代回收？分代回收背后的思想？](#3-9为什么要分代回收分代回收背后的思想)auto        - [3-9-1：young gc、old gc、full gc、mixed gc区别](#3-9-1young-gcold-gcfull-gcmixed-gc区别)auto            - [3-9-1-1：新生代的 GC 如何避免全堆扫描？](#3-9-1-1新生代的-gc-如何避免全堆扫描)auto            - [3-9-1-1：young gc 触发条件是什么？](#3-9-1-1young-gc-触发条件是什么)auto                - [3-9-1-1-1：TLAB你了解多少？](#3-9-1-1-1tlab你了解多少)auto                - [3-9-1-1-2：PLAB你了解多少？](#3-9-1-1-2plab你了解多少)auto            - [3-9-1-2：full gc 触发条件有哪些？](#3-9-1-2full-gc-触发条件有哪些)auto    - [3-10：为什么有些新老年代的收集器不能组合使用比如 ParNew 和 Parallel Old？](#3-10为什么有些新老年代的收集器不能组合使用比如-parnew-和-parallel-old)auto    - [3-10：为什么新生代都是复制算法，老年代都是标记整理算法](#3-10为什么新生代都是复制算法老年代都是标记整理算法)auto- [4. JVM内存模型（堆栈五大分区）](#4-jvm内存模型堆栈五大分区)auto    - [4-1：堆的分区](#4-1堆的分区)auto        - [4-1-1：分区的目的](#4-1-1分区的目的)auto        - [4-1-2：Minor GC与Full GC分别什么时候发生？](#4-1-2minor-gc与full-gc分别什么时候发生)auto        - [4-1-3：Minor Gc和Full GC 有什么不同呢？](#4-1-3minor-gc和full-gc-有什么不同呢)auto        - [4-1-5：年轻代](#4-1-5年轻代)auto            - [4-1-5-1：为什么会有年轻代](#4-1-5-1为什么会有年轻代)auto            - [4-1-5-2：年轻代中的GC](#4-1-5-2年轻代中的gc)auto            - [6-5：为什么是8：1：1](#6-5为什么是811)auto        - [4-1-6：老年代](#4-1-6老年代)auto        - [4-1-7：持久代](#4-1-7持久代)auto        - [4-1-8：对象在堆内存移动](#4-1-8对象在堆内存移动)auto            - [4-1-8-1：如何判断发生GC时对象在堆内存移动呢？](#4-1-8-1如何判断发生gc时对象在堆内存移动呢)auto        - [4-1-9：Java中对象并不是都在堆上分配内存的](#4-1-9java中对象并不是都在堆上分配内存的)auto    - [4-2：栈](#4-2栈)auto        - [4-1-1：栈的实现](#4-1-1栈的实现)auto        - [4-1-2：栈堆存放什么东西](#4-1-2栈堆存放什么东西)auto        - [4-1-2：什么是栈](#4-1-2什么是栈)auto        - [4-1-3：栈帧](#4-1-3栈帧)auto            - [4-1-3-1：栈帧结构](#4-1-3-1栈帧结构)auto        - [4-1-4：虚拟机栈和本地⽅法栈为什么是私有的?](#4-1-4虚拟机栈和本地⽅法栈为什么是私有的)auto    - [4-3：堆与栈的区别](#4-3堆与栈的区别)auto        - [4-3-1：](#4-3-1)auto    - [4-4：程序计数器](#4-4程序计数器)auto        - [4-4-1：为什么要有程序计数器（作用）](#4-4-1为什么要有程序计数器作用)auto        - [4-4-2：程序计数器为什么是私有的?](#4-4-2程序计数器为什么是私有的)auto    - [4-4：元空间](#4-4元空间)auto        - [4-4-1：Java 8的metaspace (元空间)](#4-4-1java-8的metaspace-元空间)auto        - [4-4-2：为什么要进行元空间代替持久代呢?](#4-4-2为什么要进行元空间代替持久代呢)auto- [5.Java内存结构（JMM）](#5java内存结构jmm)auto    - [5-1：为什么需要Java内存模型？](#5-1为什么需要java内存模型)auto        - [5-1-1：什么是Java内存模型？](#5-1-1什么是java内存模型)auto        - [5-1-2：Java内存模型的两大内存是啥？](#5-1-2java内存模型的两大内存是啥)auto        - [5-1-3：内存如何工作](#5-1-3内存如何工作)auto    - [5-2：什么是JMM](#5-2什么是jmm)auto- [6.Java对象的创建过程（对象头等概念）](#6java对象的创建过程对象头等概念)auto    - [6-1：内存分配的两种⽅式选择](#6-1内存分配的两种⽅式选择)auto    - [6-2：虚拟机如何保证线程安全](#6-2虚拟机如何保证线程安全)auto    - [6-3：对象的访问定位有哪两种⽅式?](#6-3对象的访问定位有哪两种⽅式)auto        - [6-3-1：访问定位两种方式的优缺点](#6-3-1访问定位两种方式的优缺点)auto- [7.对象头](#7对象头)auto- [8.对象分配规则](#8对象分配规则)auto- [8.内存泄露与内存溢出](#8内存泄露与内存溢出)auto    - [8-1：什么是内存泄漏](#8-1什么是内存泄漏)auto        - [8-1-1：如何检测内存泄露？](#8-1-1如何检测内存泄露)auto    - [8-2：什么是内存溢出](#8-2什么是内存溢出)auto        - [8-2-2：手写出现内存溢出的情形](#8-2-2手写出现内存溢出的情形)auto    - [8-3：内存溢出，内存泄漏区别](#8-3内存溢出内存泄漏区别)auto    - [8-4：如何避免内存泄露、溢出](#8-4如何避免内存泄露溢出)auto    - [8-5：内存结构的溢出与泄露](#8-5内存结构的溢出与泄露)auto        - [8-5-1：溢出](#8-5-1溢出)auto            - [8-5-1-1：溢出例子](#8-5-1-1溢出例子)auto        - [8-5-2：泄露](#8-5-2泄露)auto- [9.调优工具](#9调优工具)auto- [10.## 3-2：强、软、弱、虚引用](#10-3-2强软弱虚引用)auto    - [10-1:虚引用与软引用和弱引用的一个区别](#10-1虚引用与软引用和弱引用的一个区别)auto- [10.JVM进程有哪些线程启动? (拼多多)](#10jvm进程有哪些线程启动-拼多多)auto- [11.jvm启动模式之client 与server](#11jvm启动模式之client-与server)auto- [12.简述JVM中静态分派和动态分派(引申:重载和重写)](#12简述jvm中静态分派和动态分派引申重载和重写)autoauto<!-- /TOC -->

# --------------JVM--------------------------------------------------------------------------------------

# 1. JVM

## 1-1：JVM1.8新特性

1. JDK 1.7 版本中，Java 类信息、常量池、静态变量都存储在 Perm（永久代）里。
   类的元数据和静态变量在类加载的时候分配到 Perm，
   当类被卸载的时候垃圾收集器从 Perm 处理掉类的元数据和静态变量。　　　
2. JDK 1.8 的对 JVM 架构的改造将类元数据放到本地内存中，
   将常量池和静态变量放到 Java 堆里。
   HotSopt VM 将会为类的元数据明确分配和释放本地内存。
   在这种架构下，类元信息就突破了原来 -XX:MaxPermSize 的限制，
   现在可以使用更多的本地内存。
   这样就从一定程度上解决了原来在运行时生成大量类的造成经常 Full GC 问题，
   如运行时使用反射、代理等。

## 1-2：JDK1.8默认垃圾回收器

默认使用 Parallel Scavenge（新生代）+ Serial Old（老年代）

# 2.类加载

## 1-1：类的生命周期

类的生命周期包括：加载、连接、初始化、使用和卸载

## 1-2：类的加载过程（37期）

类的加载过程分为：加载->连接->初始化。连接过程又可分为三步:验证->准备->解析
1. 加载，
      1. 通过全类名获取定义此类的二进制字节流
      2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
2. 连接，连接又包含三块内容：验证、准备、初始化。
   * 1）验证，验证阶段用于检查被加载的类是否有正确的内部结构，
             并和其他类协调一致。即是否满足java虚拟机的约束。
   * 2）准备，为类的静态变量分配内存，并将其初始化为默认值；
   * 3）解析，解析阶段的目的，就是将这些符号引用解析为实际引用。
             如果符号引用指向一个未被加载的类，
             或者未被加载类的字段或方法，
             那么解析将触发这个类的加载
             但未必会触发解析与初始化
3. 初始化，类的初始化阶段，虚拟机主要对类变量进行初始化。
         虚拟机调用< clinit>方法，进行类变量的初始化。
4. 使用，new出对象程序中使用
5. 卸载，执行垃圾回收
    卸载类需要满足3个要求:
         1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
         2. 该类没有在其他任何地方被引用
         3. 该类的类加载器的实例已被GC

### 1-2-1：符号引用于直接饮用

## 1-3：类加载机制

1. `全盘负责`，当一个类加载器负责加载某个Class时，
   该Class所依赖的和引用的其他Class也将由该类加载器负责载入，
   除非显示使用另外一个类加载器来载入
2. `父类委托`，先让父类加载器试图加载该类，
   只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
3. `缓存机制`，缓存机制将会保证所有加载过的Class都会被缓存，
   当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，
   只有缓存区不存在，系统才会读取该类对应的二进制数据，
   并将其转换成Class对象，存入缓存区。

## 1-4：知道哪些类加载器?

`引导类加载器 bootstrap class loader`
   启动类加载器主要加载的是JVM自身需要的类，
   这个类加载使用C++语言实现的，是虚拟机自身的一部分，
   它负责将 /lib路径下的核心类库或-Xbootclasspath
   参数指定的路径下的jar包加载到内存中，
   注意必由于虚拟机是按照文件名识别加载jar包的，
   如rt.jar，如果文件名不被虚拟机识别，
   即使把jar包丢到lib目录下也是没有作用的
   (出于安全考虑，Bootstrap启动类加载器
   只加载包名为java、javax、sun等开头的类

`扩展类加载器 extensions class loader`
　　它负责加载JAVA_HOME/lib/ext目录下或者由
    系统变量-Djava.ext.dir指定位路径中的类库，
    开发者可以直接使用标准扩展类加载器。

`应用程序类加载器 application class loader`
   应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。
   它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，
   也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，
   一般情况下该类加载是程序中默认的类加载器，
   通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

`自定义类加载器 java.lang.classloder`
　　就是自定义啦，通过继承java.lang.ClassLoader类的方式

### 1-4-1：类加载器之间的关系
　　
    启动类加载器，由C++实现，没有父类。
　　拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null
　　系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader
　　自定义类加载器，父类加载器肯定为AppClassLoader。

## 1-5：创建并使用自定义类加载器

我们可以通过继承ClassLoader来实现自己的类加载器。
如果要实现自定义类，通过重写findClass方法
```java
public class Hello {
   public void test(String str){
       System.out.println(str);}}
--------------------------------------------------------------------------
public class MyClassloader extends ClassLoader {
    private byte[] getBytes(String fileName) throws IOException {
        File file = new File(fileName);
        long len = file.length();
        byte[] raw = new byte[(int) len];
        try (FileInputStream fin = new FileInputStream(file)) {
            //一次性读取Class文件的全部二进制数据
            int read = fin.read(raw);
            if (read != len) {
                throw new IOException("无法读取全部文件");
            }
            return raw;}}
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class clazz = null;
        //将包路径的(.)替换为斜线(/)
        String fileStub = name.replace(".", "/");
        String classFileName = fileStub + ".class";
        File classFile = new File(classFileName);

        //如果Class文件存在，系统负责将该文件转换为Class对象
        if (classFile.exists()) {
            try {
                //将Class文件的二进制数据读入数组
                byte[] raw = getBytes(classFileName);
                //调用ClassLoader的defineClass方法将二进制数据转换为Class对象
                clazz = defineClass(name, raw, 0, raw.length);
            } catch (IOException e) {
                e.printStackTrace();}}
        //如果clazz为null,表明加载失败，抛出异常
        if (null == clazz) {
            throw new ClassNotFoundException(name);
        }
        return clazz;}
----------------------------------------------------------------------------------------
    public static void main(String[] args) throws Exception {
        String classPath = "loader.Hello";
        MyClassloader myClassloader = new MyClassloader();
        Class<?> aClass = myClassloader.loadClass(classPath);
        Method main = aClass.getMethod("test", String.class);
        System.out.println(main);
        main.invoke(aClass.newInstance(), "Hello World");}}
//输出结果
//Hello World
```


## 1-5：双亲委派模型流程

每一个类都有一个对应的的类加载器。
系统中的 ClassLoder 在协同工作的时候会默认使用 
双亲委派模型 。即在类加载的时候，
系统会首先判断当前类是否被加载过。
已经被加载的类会直接返回，否则才会尝试加载。
加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，
因此所有的请求最终都应该传送到顶层的
启动类加载器 BootstrapClassLoader 中。
当父类加载器无法处理时，才由自己来处理。
当父类加载器为null时，
会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

### 1-5-1：双亲委派模型带来了什么好处呢？

双亲委派模型保证了Java程序的稳定运行，
可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，
相同的类文件被不同的类加载器加载产生的是两个不同的类），
也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，
而是每个类加载器加载自己的话就会出现一些问题，
比如我们编写一个称为 java.lang.Object 类的话，
那么程序运行的时候，系统就会出现多个不同的 Object 类。

### 1-5-2：如果我们不想⽤双亲委派模型怎么办？

自定义加载器的话，需要继承 ClassLoader 。
如果我们不想打破双亲委派模型，就重写 ClassLoader 
类中的 findClass() 方法即可，
无法被父类加载器加载的类最终会通过这个方法被加载。
但是，如果想打破双亲委派模型则需要重写 loadClass() 方法

### 1-5-3：自己写一个类能不能被加载？

不能，因为双亲委派机制可以打破，
但是不会实现成功的原因在于针对java开头的类，
jvm实现中已经保证了必须由bootatrp来加载
但是如果非要加载的话，可以放在用户目录下进行加载

### 1-5-4：如何破坏双亲委派机制

自定义类加载器，重写loadClass方法；
使用线程上下文类加载器；

# 3.垃圾回收

## 3-1：什么是GC

GC是垃圾收集的意思
内存处理是编程人员容易出现问题的地方，
忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， 
Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， 
Java 语言没有提供释放已分配内存的显示操作方法
GC是在堆空间和永久区

### 3-1-1：垃圾回收的优点

1. 可以有效的防止内存泄露
2. 有效的使用可以使用的内存。

### 3-1-2：什么样的对象需要回收

对象到GC Roots没有引用链， 那么这个对象不可用， 需要回收

### 3-1-3：垃圾回收器可以马上回收内存吗？

不可以？？？？？？

### 3-1-4：有什么办法主动通知虚拟机进行垃圾回收？

程序员可以手动执行 System.gc()，
通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。

## 3-2：垃圾回收器的基本原理是什么？

对于 GC 来说，当程序员创建对象时，
 GC 就开始监控这个对象的地址、大小以及使用情况。
GC 采用有向图的方式记录和管理堆(heap)中的所有对象。
通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。
当 GC 确定一些对象为"不可达"时， GC 就有责任回收这些内存空间。

## 3-3：如何判断对象已经死亡？

1. 引用计数法
给对象中添加一个引用计数器，每当有一个地方引用它，
计数器就加 1；当引用失效，计数器就减 1；
任何时候计数器为 0 的对象就是不可能再被使用的。
这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，
其最主要的原因是它很难解决对象之间相互循环引用的问题。 
所谓对象之间的相互引用问题，比如说对象 objA 和 objB 相互引用着对方之外，
这两个对象之间再无任何引用。但是他们因为互相引用对方，
导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

2. 可达性分析算法
这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起点，
从这些节点开始向下搜索，节点所走过的路径称为引用链，
当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

### 3-3-1：可作为GC Roots的对象？

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法引用的对象

### 3-3-2：不可达的对象是否非死不可

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，
这时候它们暂时处于“缓刑阶段”，要真正宣告一
个对象死亡，至少要经历两次标记过程;可达性分析法中
不可达的对象被第一次标记并且进行一次筛选，筛选的
条件是此对象是否有必要执行finalize方法。
当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调
用过时，虚拟机将这两种情况初为沿右必要执行。
被判定为需要执行的对象将会被放在一个队列中进行第二次标
记，除非这个对象与引用链上的任何一个对象简历关联，
否则就会真的回收。

## 3-4：如何判断一个类是无用的类

1. 该类所有的实例都已经被回收，
       也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，
       无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，
这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 3-5：如何判断一个常量是废弃常量？

假如在常量池中存在字符串 "abc"，
如果当前没有任何 String 对象引用该字符串常量的话，
就说明常量 "abc" 就是废弃常量，
如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

## 3-6：如何减少 GC 的次数

1. 对象不用时最好显示置为 NULL
   一般而言，为Null的对象都会被作为垃圾处理，
   所以将不用的对象显示地设为Null，
   有利于GC收集器判定垃圾，从而提高了GC的效率。
2. 尽量少使用 System,gc()
   此函数建议JVM进行主GC，虽然只是建议而非一定，
   但很多情况下它会触发主GC，从而增加主GC的频率，
   也即增加了间歇性停顿的次数。
3. 尽量少使用静态变量
   静态变量属于全局变量，不会被GC回收，他们会一直占用内存。
4. 尽量使用 StringBuffer,而不使用 String 来累加字符串
   由于String是固定长的字符串对象，累加String对象时，
   并非在一个String对象中扩增，而是重新创建新的String对象，
   如str5 = str1 + str2 + str3 + str4，
   这条语句执行过程中会产生多个垃圾对象，
   因为对 + 操作时都必须创建新的String对象，
   但这些过度对象对系统来说是没有意义的，
   只会增加更多的垃圾。
   避免这种情况可以改用StringBuffer来累加字符串，
   因StringBuffer是可变长的，
   它在原有的基础上进行扩展，不会产生中间对象。
5. 分散对象创建或删除的时间
   集中在短时间内大量创建新对象，
   特别是大对象，会导致突然需要大量内存，
   JVM在面临这种情况时，只能进行主GC，
   以回收内存或整合内存碎片，从而增加主GC的频率。
   集中删除对象，道理也是一样的。
   它使得突然出现了大量的垃圾对象，
   空闲时间必然减少，从而大大增加了下一次创建新对象时强制主GC的机会。
6. 尽量少用 finaliza 函数
7. 如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory
8. 能用基本类型入 INT 就不用对象 Integer
   基本类型变量占用的内存资源比包装类对象占用的少得多，如果没有必要，最好使用基本变量。
9.  增大-Xmx 的值

## 3-7：垃圾回收算法

1. `标记-清除算法`
算法分为“标记”和“清除”阶段：
⾸先标记出所有需要回收的对象，
在标记完成后统⼀回收所有被标记的对象。
它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到。
这种垃圾收集算法会带来两个明显的问题：
1. 效率问题
2. 空间问题（标记清除后会产⽣⼤量不连续的碎⽚）
2. `复制算法`
为了解决效率问题， 它可以将内存分为⼤⼩相同的两块，
每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，
就将还存活的对象复制到另⼀块去，
然后再把使⽤的空间⼀次清理掉。
这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。
3. `标记-整理算法`
根据⽼年代的特点特出的⼀种标记算法，
标记过程仍然与“标记-清除”算法⼀样，
但后续步骤不是直接对可回收对象回收，
⽽是让所有存活的对象向⼀端移动，
然后直接清理掉端边界以外的内存。
4. `分代收集算法`
根据对象存活周期的不同将内存分为⼏块。
⼀般将java堆分为新⽣代和⽼年代，
这样我们就可以根据各个年代的特点
选择合适的垃圾收集算法。

## 3-8：垃圾回收器

### 3-8-1：Serial收集器

不仅只会使⽤⼀条垃圾收集线程去完成垃圾收集⼯作，
更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程，
直到它收集结束。
`优势：`
1. 简单⽽⾼效
2. 由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。 

### 3-8-2：ParNew收集器

除了使⽤多线程进⾏垃圾收集外，
其余⾏为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。
新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。

### 3-8-3：Parallel Scavenge收集器

Parallel Scavenge 收集器关注点是吞吐量
（高效率的利用 CPU）。
CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间
（提高用户体验）。
所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 
Parallel Scavenge 收集器
提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，
如果对于收集器运作不太了解的话，
手工优化存在困难的话可以选择
把内存管理优化交给虚拟机去完成也是一个不错的选择。
新生代采用复制算法，老年代采用标记-整理算法。 

### 3-8-4：Serial Old收集器

Serial 收集器的老年代版本，
它同样是一个单线程收集器。
它主要有两大用途：
一种用途是在 JDK1.5 以及以前的版本中
与 Parallel Scavenge 收集器搭配使用，
另一种用途是作为 CMS 收集器的后备方案。

### 3-8-5：Parallel Old收集器

Parallel Scavenge 收集器的老年代版本。
使用多线程和“标记-整理”算法。
在注重吞吐量以及 CPU 资源的场合，
都可以优先考虑 Parallel Scavenge 收集器
和 Parallel Old 收集器。

### 3-8-6：CMS收集器

CMS（Concurrent Mark Sweep）收集器
是一种以获取最短回收停顿时间为目标的收集器。
它非常符合在注重用户体验的应用上使用。
CMS（Concurrent Mark Sweep）收集器是并发收集器，
它第一次基本上实现了让垃圾收集线程与用户线程同时工作。
整个过程分为四个步骤：

1. 初始标记： 暂停所有的其他线程，
             并记录下直接与 root 相连的对象，
             速度很快 ；
2. 并发标记： 同时开启 GC 和用户线程，
             用一个闭包结构去记录可达对象。
             但在这个阶段结束，这个闭包结构并不能
             保证包含当前所有的可达对象。
             因为用户线程可能会不断的更新引用域，
             所以GC线程无法保证可达性分析的实时性。
             所以这个算法里会跟踪记录这些发生引用更新的地方。
3. 重新标记： 重新标记阶段就是为了修正并发标记期间
             因为用户程序继续运行而导致标记
             产生变动的那一部分对象的标记记录，
             这个阶段的停顿时间一般会比
             初始标记阶段的时间稍长，
             远远比并发标记阶段时间短
4. 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

`优点:`
      并发，低停顿
`缺点：`
      1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，
                       但是会因为占用了一部分线程使应用程序变慢
      2、无法处理浮动垃圾：在最后一步并发清理过程中，
                        用户线程执行也会产生垃圾，
                        但是这部分垃圾是在标记之后，
                        所以只有等到下一次gc的时候清理掉，
                        这部分垃圾叫浮动垃圾。由于并发清理的时候，
                        用户线程也在运行，
                        就需要保证用户线程在运行的时候
                        需要留有部分内存以供使用。
                        但是当这部分内存不足以
                        给用户线程正常使用时，
                        就会出现一次 “Concurrent Mode Failure”，
                        一旦出现了“Concurrent Mode Failure”，
                        便会开启后备方案，
                        临时使用SerialOld收集器进行收集工作。
      3、CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，
         将会给大对象空间的分配带来很大的麻烦，
         往往会出现老年代还有很大的空间但无法
         找到足够大的连续空间来分配当前对象，
         不得不提前触发一次FullGC，
         为了解决这个问题CMS提供了一个开关参数，
         用于在CMS顶不住，
         要进行FullGC时开启内存碎片的合并整理过程，
         但是内存整理的过程是无法并发的，
         空间碎片没有了但是停顿时间变长了

#### 3-8-6-1：产生 concurrent mode failure 真正的原因

应该是Full GC 导致抛这个错
主要原因是因为分配速率太快导致堆不够用，回收不过来因此产生 full gc。
也有可能是发起 cms gc 设置的堆的阈值太高。

#### 3-8-6-2：CMS 出现FullGC的原因

1、年轻代晋升到老年代没有足够的连续空间，
   很有可能是内存碎片导致的，因此会触发FULL GC
2、在并发过程中JVM觉得在
   并发过程结束之前堆就会满，需要提前触发FullGC
CMS失败后使用备案SerialOld收集器

#### 3-8-6-3：cms怎么解决内存碎片的问题

1. 增大Xmx或者减少Xmn
2. 在应用访问量最低的时候，在程序中主动调用System.gc()。
3. 在应用启动并完成所有初始化工作后，主动调用System.gc()，
   它可以将初始化的数据压缩到一个单独的chunk中，以腾出更多的连续内存空间给新生代晋升使用。
4. 降低-XX:CMSInitiatingOccupancyFraction参数以提早执行CMSGC动作，
   虽然CMSGC不会进行内存碎片的压缩整理，但它会合并老生代中相邻的free空间。
   这样就可以容纳更多的新生代晋升行为。

#### 3-8-6-4：CMS GC发生concurrent mode failure时的full GC为什么是单线程的?




### 3-8-7：G1收集器

G1 (Garbage-First) 是一款面向服务器的垃圾收集器,
主要针对配备多颗处理器及大容量内存的机器
以极高概率满足 GC 停顿时间要求的同时,
还具备高吞吐量性能特征.
主要特点就是并发性强、分代收集、
标记整理进行空间整合，可以预测停顿时间。
1. 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，
             使用多个 CPU（CPU 或者 CPU 核心）来缩短 
             Stop-The-World 停顿时间。
             部分其他收集器原本需要停顿 
             Java 线程执行的 GC 动作，
             G1 收集器仍然可以通过并发的方式
             让 java 程序继续执行。
2. 分代收集：虽然 G1 可以不需要其他收集器配合
            就能独立管理整个 GC 堆，
            但是还是保留了分代的概念。
3. 空间整合：与 CMS 的“标记--清理”算法不同，
            G1 从整体来看是基于“标记整理”算法实现的收集器；
            从局部上来看是基于“复制”算法实现的。
4. 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，
                降低停顿时间是 G1 和 CMS 共同的关注点，
                但 G1 除了追求低停顿外，
                还能建立可预测的停顿时间模型，
                能让使用者明确指定在一个长度
                为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

1. 初始标记
2. 并发标记
3. 最终标记
           将并发阶段对象变化记录在线程Remenbered Set Logs里面，
           最终把Remembered Set Logs的数据合
           并到Remembered Set中，这一阶段需要停顿线程，
           但是可并行执行。
4. 筛选回收
           筛选回收，
           对每一个region的价值和成本进行筛选，
           根据用户期望的GC停顿时间，
           得到最好的回收方案并回收。

`优点：`
1、空间整合：g1使用Region独立区域概念，
            g1利用的是标记复制法，
            不会产生垃圾碎片
2、分代收集：g1可以自己管理新生代和老年代
3、并行于并发：g1可以通过机器的多核来
              并发处理 stop - The - world停顿，
              减少停顿时间，
              并且可不停顿java线程执行GC动作，
              可通过并发方式让GC和java程序同时执行。
4、可预测停顿：g1除了追求停顿时间，
              还建立了可预测停顿时间模型，
              能让制定的M毫秒时间片段内，
              消耗在垃圾回收器上的时间不超过N毫秒

### 3-8-8：CMS与G1区别

`区别一： 使用范围不一样`
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用
`区别二： STW的时间`
CMS收集器以最小的停顿时间为目标的收集器。
G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）
`区别三： 垃圾碎片`
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
`区别四： 垃圾回收的过程不一样`

### 3-8-9：吞吐有限和响应有限的垃圾收集器如何选择

1. 吞吐量优先
新生代采用Paralle Scavenge,
老年代采用Parallel Old.并配置
多个线程进行回收。
设置参数来调整最大垃圾收集停顿时间和吞吐量的大小。
2. 响应时间优先
设置老年代的收集器是CMS
 (最短时间，spark streaming采用这个)。
 年轻代是ParnNiew(多线程)。

## 3-9：为什么要分代回收？分代回收背后的思想？

绝大多数对象都是朝生夕死的
熬过越多次垃圾收集过程的对象就越难以消亡
本身就是根据这两个特性进行了设计:
收集器应该将Java堆划分 出不同的区域，
然后将回收对象依据其年龄
年龄即对象熬过垃圾收集过程的次数
分配到不同的区域之中存储。
如果一个区域中大多数对象都是朝生夕灭，
难以熬过垃圾收集过程的话，
那么把它们集中放在一起，
每次回收时只关注如何保留少量存活
而不是去标记那些大量将要被回收的对象，
就能以较低代价回收到大量的空间;
如果剩下的都是难以消亡的对象，
那把它们集中放在一块，
虚拟机便可以使用较低的频率来回收这个区域，
这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。
在Java堆划分出不同的区域之后，
垃圾收集器才可以每次只回收其中
某一个或者某些部分的区域
因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分;
也才能够针对不同的区域安排
与里面存储对象存亡特征相匹配的垃圾收集算法
因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。

### 3-9-1：young gc、old gc、full gc、mixed gc区别

因为GC分为两大类，分别是Partial GC（部分回收）和Full GC（整堆回收）。

1. 部分收集，分为 young gc、old gc、mixed gc。
   young gc：指的是单单收集年轻代的 GC。
   old gc：指的是单单收集老年代的 GC。
   mixed gc：这个是 G1 收集器特有的，指的是收集整个年轻代和部分老年代的 GC。

2. 整堆回收，指的是收取整个堆，包括年轻代、老年代，如果有永久代的话还包括永久代。
3. Major GC 指代的是单单老年代的 GC，也就是和 old gc 等价的，
4. Minor GC，其指的就是年轻代的 gc。

#### 3-9-1-1：新生代的 GC 如何避免全堆扫描？




#### 3-9-1-1：young gc 触发条件是什么？

因为在年轻代的 eden 快要被占满的时候会触发 young gc。
因为有一些收集器的回收实现是在 full gc 前会让先执行以下 young gc。
比如 Parallel Scavenge，不过有参数可以调整让其不进行 young gc。
可能还有别的实现也有这种操作，不过正常情况下就当做 eden 区快满了即可。
eden 快满的触发因素有两个，一个是为对象分配内存不够，一个是为 TLAB 分配内存不够。

##### 3-9-1-1-1：TLAB你了解多少？

TLAB是为了避免对象分配时的竞争而设计的

因为生成对象需要向堆中的新生代申请内存空间，而堆又是全局共享的，
像新生代内存又是规整的，是通过一个指针来划分的。
内存是紧凑的，新对象创建指针就右移对象大小size即可，
这叫指针加法。
但是如果多个线程都在分配对象，那么这个指针就会成为热点资源，
需要互斥那分配的效率就低了。
于是出现了TLAB这个概念，为一个线程分配的内存申请区域。
这个区域只允许这一个线程申请分配对象，允许所有线程访问这块内存区域。
TLAB 主导思想，我认为就是划一块区域给一个线程，
这样每个线程只需要在自己的那亩地申请对象内存，
不需要争抢热点指针。
当这块内存用完了之后再去申请即可。
不过每次申请的大小不固定，会根据该线程启动到现在的历史信息来调整，
比如这个线程一直在分配内存那么 TLAB 就大一些，
如果这个线程基本上不会申请分配内存那 TLAB 就小一些。

##### 3-9-1-1-2：PLAB你了解多少？

主要是用在年轻代对象晋升到老年代时
在多线程并行执行 Yong GC 时，可能有很多对象需要晋升到老年代，
此时老年代的指针就“热”起来了，于是搞了个 PLAB。
先从老年代 freelist（空闲链表） 申请一块空间，
然后在这一块空间中就可以通过指针加法（bump the pointer）来分配内存，
这样对 freelist 竞争也少了，分配空间也快了。





#### 3-9-1-2：full gc 触发条件有哪些？

1. 在要进行 young gc 的时候，
   根据之前统计数据发现年轻代平均晋升大小比现在老年代剩余空间要大，
   那就会触发 full gc。
2. 有永久代的话如果永久代满了也会触发 full gc。
3. 老年代空间不足，大对象直接在老年代申请分配，
   如果此时老年代空间不足则会触发 full gc。
4. 担保失败，新生代的to区放不下从eden和from拷贝过来对象，
   或者新生代对象 gc 年龄到达阈值需要晋升这两种情况，
   老年代如果放不下的话都会触发 full gc。
5. 执行 System.gc()、jmap -dump 等命令会触发 full gc。


## 3-10：为什么有些新老年代的收集器不能组合使用比如 ParNew 和 Parallel Old？

HotSpot VM 自身的分代收集器实现有一套框架，只有在框架内的实现才能互相搭配使用。





## 3-10：为什么新生代都是复制算法，老年代都是标记整理算法

因为新生代对象生存时间比较短，80%都是要回收的对象，
采用标记-清除算法则内存空间碎片化严重，
采用复制算法可以灵活高效，且便与整理空间。
标记整理算法解决来标记-清除算法的内存碎片化的问题，
又解决了复制算法的两个Survivor区的问题，
因为老年代的空间比较大，
不可能采用复制算法，特别占用内存空间，




# 4. JVM内存模型（堆栈五大分区）

1. 堆
Java堆是用来存放实例对象和数组对象的，
由于存在逃逸分析找术(分析这个对象不会被其他方法或者线程调用)，
也可以分布在栽上，随着出栈而销毁，
同时，java堆也是垃圾回收的主要区域，
由于现在垃圾收集器基本都采用分代垃圾收集算法，
所以Java堆还可以细分为:新生代和老年代
Java堆在物理上可以不连续，只要逻辑连续就好。
在堆上分配对象的方法有:指针碰撞和空闲列表，
指针碰撞是在堆内存规整的情景下，
所有用过和空闲的内存中间有明确的分界线，
而空闲列表用空闲列表来记录内存的使用情况，
规整是由垃圾回收器是否压缩整理决定。空间不足抛出OutOfMemoryError.
堆上对象的访问方式:通过栈上的 reference数据来操作堆上的具体对象。
目前主流的访问了式有使用句柄和直接指针两种。
句柄的话，Java堆中将会划分出一块内存来作为句柄池reference中存储的就是对像的句柄地址，
而句柄中包含了对象实例数据与类型数据各自的具体地址信息，
直接指针的话，reference中存储的直接就是对象的地址，前者稳定后者效率高
2. 方法区
方法区与Java堆一样，是各个线程共享的内存区域，
特用于存储已被虚拟机加载的类信息，
常量、静态变量，其中运行时常量池、
用于存放编译器生成的各类字面量和符号引用
(字面量：1.文本字符串，2.八种基本数据类型的值，
3.被声明为final的常量，
符号引用：1.类和方法的权限定名，
2.字段的名称和描述符3.方法的名称和描述符)
运行时常量池相对于Class常量池具有动态性，
可以在运行期间利用intern方法将常量池放入池中，
空间不足抛出OOMError
3. 虚拟机栈
虚拟机栈是java方法执行的内存模型，
线程私有，每个方法执行都会创建一个栈帧，
用于存储局部变量表、操作数栈、动态链接
(运行时将方法区的符号引用转化为直接引用，表示真的可以调用了)
和方法出口等信息围每一个方法从调用直至执行结束，
就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
StackOverflowError:线程请求的栈深度大于虚拟机所允许的深度。
OutofMemoryError:如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。
4. 本地方法栈
本地方法栈则是为虚拟机使用到的Native方法服务
作用：本地方法栈用于管理本地方法的调用
5. 程序计数器
   记录当前线程所执行到的字节码的行号。
   每个线程都有一个程序计数器，唯一没有OutOfMemoryError情况的内存区域。

## 4-1：堆的分区

新生代和老年代

`新生代`又可以进一步划分为一个Eden区和两个Survivor区，
Eden，也叫伊甸区，是进行内存分配的地方，
是一块连续的空闲内存区域，在里面进行内存分配速度非常快，
因为不需要进行可用内存块的查找。
新对象总是在Eden区中生成，
只有经受住了一定的考验后才能顺利的进入到Survivor区中。
把Survivor区划分为2块，
也是也是为了满足垃圾回收的需要，
因为在新生代中经历了回收未必就能进入老年代中。
系统总是把对象放在Eden区和一个Srvivor区，
在垃圾回收时，
根据其存活时间被复制到另一个Survivor区或者老年代中，
则这之前的Survivor去和Eden区中剩下的都是需要被回收的对象，
只对这两个区域进行清除即可，
两个Survivor区是交替使用，循环往复，
在下一次垃圾回收时，
之前被清除的存活区又用来放置存活下来的对象了。
一般来说，年轻代区域较小，
而且大部分对象是需要进行清除的，采用了"复制算法"进行垃圾回收。
`老年代`
在新生代中经历了N次回收后仍然没有被清除的对象，
就会被放到老年代中，都是生命周期较长的对象。
对于老年代和永久代，采用标记-整理的算法。
标记的过程是找出当前还存活对对象，
并进行标记；清除则是遍历整个老年区，
找已经标记的对象并进行清除，
然后把存活的对象移动到整个内存区的一端，
使得另一端是一块连续的空间，方便进行内存分配和复制。

### 4-1-1：分区的目的

JVM在程序运行过程当中，会创建大量的对象，
这些对象，大部分是短周期的对象，小部分是长周期的对象，
对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，
对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。
为解决这种矛盾，JVM的内存管理采用分代的策略。
新生区由于对象产生的比较多并且大都是朝生夕灭的，
所以直接采用复制算法。而养老区生命力很强，
则采用标记-清理算法，针对不同情况使用不同算法。

### 4-1-2：Minor GC与Full GC分别什么时候发生？

1. Minor GC：当新对象生成，但在Eden申请空间失败时就会触发，
   对Eden进行GC，清除掉非存活的对象，
   并且把存活的对象移动到Survivor区中的其中一块。
   前面提到的考验就是Minor GC，
   也就是说对象经过了Minor GC才能够进入到存活区中。
   这种形式的GC只会在新生代中进行，
   因为大部分对象都是从Eden区开始的，
   同时Eden不会分配的太大，
   所以对Eden区的GC会非常地频繁。
2. Full GC：对整个堆进行整理，
   包括了新生代老年代和永久代。
   Full GC要对整个块进行回收，
   所以要比Minor GC慢很多，
   因此应该尽可能的减少Full GC的次数。

### 4-1-3：Minor Gc和Full GC 有什么不同呢？

⼤多数情况下，对象在新⽣代中eden 区分配。
当 eden 区没有⾜够空间进⾏分配时，
虚拟机将发起⼀次Minor GC。
1. 新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， 
                        Minor GC⾮常频繁，回收速度⼀般也⽐较快。
2. ⽼年代GC（Major GC/Full GC）:指发⽣在⽼年代的GC，
                              出现了Major GC经常会伴随⾄少⼀次的Minor GC
                              也并⾮绝对，Major GC的速度⼀般会⽐Minor GC的慢10倍以上。


### 4-1-5：年轻代

年轻代主要存放新创建的对象，
内存大小相对会比较小，
垃圾回收会比较频繁。
年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。
当对象在堆创建时，将进入年轻代的Eden Space。
垃圾回收器进行垃圾回收时，
扫描Eden Space和A Suvivor Space，如果对象仍然存活，
则复制到B Suvivor Space，
如果B Suvivor Space已经满，则复制到Old Gen。同时，
在扫描Suvivor Space时，
如果对象已经经过了几次的扫描仍然存活，
JVM认为其为一个持久化对象，
则将其移到Old Gen。扫描完毕后，
JVM将Eden Space和A Suvivor Space清空，
然后交换A和B的角色
下次垃圾回收时会扫描Eden Space和B Suvivor Space。
这么做主要是为了减少内存碎片的产生。
Young Gen垃圾回收时，
采用将存活对象复制到到空的Suvivor Space的方式
来确保尽量不存在内存碎片，
采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。

#### 4-1-5-1：为什么会有年轻代

分代的理由就是优化GC性能。
如果没有分代，那我们所有的对象都在一块，
GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。
而我们的很多对象都是一瞬间消失，
如果分代的话，我们把新创建的对象放到某一地方，
当GC的时候先把这块存一瞬间消失对象的区域进行回收，
这样就会腾出很大的空间出来。

#### 4-1-5-2：年轻代中的GC

HotSpot JVM把年轻代分为了三部分：
1个Eden区和2个Survivor区（分别叫from和to）。
默认比例为8：1,
一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),
这些对象经过第一次Minor GC后，如果仍然存活，
将会被移到Survivor区。
对象在Survivor区中每熬过一次Minor GC，
年龄就会增加1岁，
当它的年龄增加到一定程度时，
就会被移动到年老代中。
因为年轻代中的对象基本都是朝生夕死的(80%以上)，
所以在年轻代的垃圾回收算法使用的是复制算法，
复制算法的基本思想就是将内存分为两块，
每次只用其中一块，当这一块内存用完，
就将还活着的对象复制到另外一块上面。
复制算法不会产生内存碎片。
在GC开始的时候，
对象只会存在于Eden区和名为“From”的Survivor区，
Survivor区“To”是空的。
紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，
而在“From”区中，
仍存活的对象会根据他们的年龄值来决定去向。
年龄达到一定值(年龄阈值，
可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，
没有达到阈值的对象会被复制到“To”区域。
经过这次GC后，Eden区和From区已经被清空。
这个时候，“From”和“To”会交换他们的角色，
也就是新的“To”就是上次GC前的“From”，
新的“From”就是上次GC前的“To”。
不管怎样，都会保证名为To的Survivor区域是空的。
Minor GC会一直重复这样的过程，直到“To”区被填满，
“To”区被填满之后，会将所有对象移动到年老代中。

#### 6-5：为什么是8：1：1

假设当内存使用达到98%时才GC就有点晚了，应该是多一些预留10%内存空间，
这预留下来的空间我们称为S区（有两个s区  s1 和  s0），
S区是用来存储新生代GC后存活下来的对象，而我们知道新生代GC算法使用的是复制回收算法。
所以我们实际GC发生是在，新生代内存使用达到90%时开始进行，
复制存活的对象到S1区，要知道GC结束后在S1区活下来的对象，
在下一次GC的范围是，eden区和S1，把这两部分存活的对象放入S0区，
如此反复，下一次GC范围是eden区和S0区，一句话每次GC范围是eden区+一个S区。
（比例是，eden：s1:s0=80%:10%:10%=8:1:1）这里的eden区（80%） 和其中的一个  S区（10%） 合起来共占据90%，
GC就是清理的他们，始终保持着其中一个  S  区是空留的，保证GC的时候复制存活的对象有个存储的地方。
这样做的好处是
高效！！！，GC 算法总体就是三种：1 复制  2 标记  3标记整理，
垃圾回收算法将这几种选择起来相互组合。毫无疑问，只存在少量存活的对象，
只需复制少量存活的对象，远远比标记和标记整理高效多。

### 4-1-6：老年代

年老代主要存放JVM认为生命周期比较长的对象
（经过几次的Young Gen的垃圾回收后仍然存在），
内存大小相对会比较大，
垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。
年老代主要采用压缩的方式来避免内存碎片
（将存活对象移动到内存片的一边，也就是内存整理）。
当然，有些垃圾回收器
（譬如CMS垃圾回收器）
出于效率的原因，可能会不进行压缩。

### 4-1-7：持久代

持久代主要存放类定义、字节码和常量等很少会变更的信息。

### 4-1-8：对象在堆内存移动

可能在GC的时候会发生

#### 4-1-8-1：如何判断发生GC时对象在堆内存移动呢？

### 4-1-9：Java中对象并不是都在堆上分配内存的

在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。
但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。
JIT编译器就可以在编译期间根据逃逸分析的结果，
来决定是否可以将对象的内存分配从堆转化为栈。
也就是说随着JIT编译器的发展，在编译期间，
如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，
那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。
就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。

## 4-2：栈

### 4-1-1：栈的实现

一个是用java本身的集合

类型Stack类型；
另一个是借用LinkedList来间接实现Stack。

### 4-1-2：栈堆存放什么东西

存放基本类型 的变量数据和对象的引用，但对象本身不存放在栈中，
而是存放在堆（new出来的对象）或者常量池中（字符串常量对象存放的常量池中），
局部变量

2.堆：存放使用new创建的对象，全局变量

### 4-1-2：什么是栈

一端被称为栈顶，相对地，把另一端称为栈底。
向一个栈插入新元素又称作进栈、入栈或压栈，
它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，
使其相邻的元素成为新的栈顶元素。
主管程序运行，生命周期和线程同步，
线程结束，栈内存就释放了。不存在垃圾回收问题

### 4-1-3：栈帧

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，
它是虚拟机运行时数据区中的虚拟机栈的栈元素。
栈帧表示程序的函数调用记录，而栈帧又是记录在栈上面，
栈上保持了N个栈帧的实体，
那就可以说栈帧将栈分割成了N个记录块，
但是这些记录块大小不是固定的，
因为栈帧不仅保存诸如：
函数入参、出参、返回地址和上一个栈帧的栈底指针等信息，
还保存了函数内部的自动变量
甚至可以是动态分配内存，alloca函数就可以实现，但在某些系统中不行
，因此，不是所有的栈帧的大小都相同。

#### 4-1-3-1：栈帧结构

1. `局部变量表`
在编译程序代码的时候就可以确定栈帧中需要多大的局部变量表，
具体大小可在编译后的 Class 文件中看到。
局部变量表的容量以 Variable Slot（变量槽）为最小单位，
每个变量槽都可以存储 32 位长度的内存空间。
在方法执行时，
虚拟机使用局部变量表完成参数值到参数变量列表的传递过程的，
如果执行的是实例方法，
那局部变量表中第 0 位索引的 Slot 默认是
用于传递方法所属对象实例的引用
（在方法中可以通过关键字 this 来访问到这个隐含的参数）。
其余参数则按照参数表顺序排列，
占用从 1 开始的局部变量 Slot。
基本类型数据以及引用和returnAddress（返回地址）
占用一个变量槽，long 和 double 需要两个。
2. `操作数栈`
同样也可以在编译期确定大小。
Frame 被创建时，操作栈是空的。
操作栈的每个项可以存放 JVM 的各种类型数据，
其中 long 和 double 类型（64位数据）占用两个栈深。
方法执行的过程中，
会有各种字节码指令往操作数栈中写入和提取内容，
也就是出栈和入栈操作（与 Java 栈中栈帧操作类似）。
操作栈调用其它有返回结果的方法时，
会把结果 push 到栈上（通过操作数栈来进行参数传递）。
3. `动态链接`
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，
持有这个引用是为了支持方法调用过程中的动态链接。
在类加载阶段中的解析阶段会将符号引用转为直接引用，
这种转化也称为静态解析。
另外的一部分将在运行时转化为直接引用，这部分称为动态链接。
4. `返回地址`
方法开始执行后，只有2种方式可以退出 ：方法返回指令，异常退出。
5. `帧数据区`
   
### 4-1-4：虚拟机栈和本地⽅法栈为什么是私有的?

为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地⽅法栈是线程私有的。

## 4-3：堆与栈的区别

栈是线程独享的，堆是线程共享的
堆中主要存放对象实例。栈（局部变量表）
中主要存放各种基本数据类型、对象的引用。

### 4-3-1：

## 4-4：程序计数器

### 4-4-1：为什么要有程序计数器（作用）

比如说在多线程中，为了让每个线程正常工作就提出了程序计数器，
每个线程都有自己的程序计数器这样当线程执行切换的时候就可以在上次执行的基础上继续执行，
仅仅从一条线程线性执行的角度而言，
代码是一条一条的往下执行的，
这个时候就是程序计数器；
JVM就是通过读取程序计数器的值来决定下一条需要执行的字节码指令，
进而进行选择语句、循环、异常处理等；

### 4-4-2：程序计数器为什么是私有的?

程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。



## 4-4：元空间

### 4-4-1：Java 8的metaspace (元空间)

方法区是所有线程共享。
主要用于存储类的信息、常量池、方法数据、方法代码等。
方法区是JVM的规范，
永久代(PermGen space )是HotSpot对这种规范的实现。
在JDK1.8中，HotSpot已经没有永久代，取而代之的是Metaspace( 元空间)。
元空间的本质和永久代类似，
都是对JVM规范中方法区的实现。
不过元空间与永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。

### 4-4-2：为什么要进行元空间代替持久代呢?

1. 字符串存在永久代中，容易出现性能问题和内存溢出。
2. 类及方法的信息等比较难确定其大小，
   因此对于永久代的大小指定比较困难，
   太小容易出现永久代溢出，太大则容易导致老年代溢出。
3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。

# 5.Java内存结构（JMM）

## 5-1：为什么需要Java内存模型？

屏蔽各种硬件和操作系统的内存访问差异

### 5-1-1：什么是Java内存模型？

1. 定义程序中各种变量的访问规则
2. 把变量值存储到内存的底层细节
3. 从内存中取出变量值的底层细节

### 5-1-2：Java内存模型的两大内存是啥？

1. 主内存
  * Java堆中对象实例数据部分
  * 对应于物理硬件的内存
2. 工作内存
  * Java栈中的部分区域
  * 优先存储于寄存器和高速缓存

### 5-1-3：内存如何工作

线程对变量的操作（读取赋值等）必须在工作内存中进行，
首先要将变量从主内存拷贝到自己的工作内存空间，
然后对变量进行操作，操作完成后再将变量写会主内存

## 5-2：什么是JMM

JMM是Java内存模型，
本身是一种抽象的概念，
实际上并不存在，
它描述的是一组规则或规范，
通过这组规范定义了程序中各个变量
（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

# 6.Java对象的创建过程（对象头等概念）

`Step1:类加载检查`
虚拟机遇到一条 new 指令时，
首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，
并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。
如果没有，那必须先执行相应的类加载过程。
`Step2:分配内存`
在类加载检查通过后，
接下来虚拟机将为新生对象分配内存。
对象所需的内存大小在类加载完成后便可确定，
为对象分配空间的任务等同于把一块确定大小的
内存从Java堆中划分出来。
`Step3:初始化零值`
内存分配完成后，
虚拟机需要将分配到的内存空间都初始化为零值
（不包括对象头），
这一步操作保证了对象的实例字段
在Java代码中可以不赋初始值就直接使用，
程序能访问到这些字段的数据类型所对应的零值。
`Step4:设置对象头`
初始化零值完成之后，
虚拟机要对对象进行必要的设置，
例如这个对象是哪个类的实例、
如何才能找到类的元数据信息、
对象的哈希码、
对象的 GC 分代年龄等信息。 
这些信息存放在对象头中。 
另外，根据虚拟机当前运行状态的不同，
如是否启用偏向锁等，对象头会有不同的设置方式。
`Step5:执行 init 方法`
在上面工作都完成之后，
从虚拟机的视角来看，
一个新的对象已经产生了，
但从 Java 程序的视角来看，
对象创建才刚开始，<init> 方法还没有执行，
所有的字段都还为零。
所以一般来说，
执行 new 指令之后会接着执行 <init> 方法，
把对象按照程序员的意愿进行初始化，
这样一个真正可用的对象才算完全产生出来。

## 6-1：内存分配的两种⽅式选择

分配⽅式有 “指针碰撞” 和 “空闲列表” 两种
选择以上两种⽅式中的哪⼀种，
取决于 Java 堆内存是否规整。
⽽ Java 堆内存是否规整，
取决于 GC收集器的算法是"标记-清除"，还是"标记-整理"，

## 6-2：虚拟机如何保证线程安全

1. CAS+失败重试： 虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
2. TLAB： 为每⼀个线程预先在Eden区分配⼀块内存， 
          JVM在给线程中的对象分配内存时，
          ⾸先在TLAB分配，
          当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，
          再采⽤上述的CAS进⾏内存分配

## 6-3：对象的访问定位有哪两种⽅式?

①使⽤句柄
   * 如果使⽤句柄的话，
     那么Java堆中将会划分出⼀块内存来作为句柄池， 
     reference 中存储的就是对象的句柄地址，
     ⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
②直接指针
  * 如果使⽤直接指针访问，
    那么 Java 堆对象的布局中就
    必须考虑如何放置访问类型数据的相关信息，
    ⽽reference 中存储的直接就是对象的地址

### 6-3-1：访问定位两种方式的优缺点

1. 使⽤句柄来访问的最⼤好处是 reference 
   中存储的是稳定的句柄地址，
   在对象被移动时只会改变句柄中的实例数据指针，
   ⽽ reference 本身不需要修改。
2. 使⽤直接指针访问⽅式最⼤的好处就是速度快，
   它节省了⼀次指针定位的时间开销。

# 7.对象头

HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：
对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。  
HotSpot虚拟机的对象头包括两部分信息，
第一部分用于存储对象自身的运行时数据， 
如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等
对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，
虚拟机通过这个指针来确定这个对象是哪个类的实例。
并不是所有的虚拟机实现都必须在对象数据上保留类型指针，
换句话说查找对象的元数据信息并不一定要经过对象本身。
另外，如果对象是一个Java数组，
那在对象头中还必须有一块用于记录数组长度的数据，
因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，
但是从数组的元数据中无法确定数组的大小

# 8.对象分配规则

1. 对象优先分配在Eden区，
   如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。
   这样做的目的是避免在Eden区和两个Survivor区
   之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
3. 长期存活的对象进入老年代。
   虚拟机为每个对象定义了一个年龄计数器，
   如果对象经过了1次Minor GC那么对象会进入Survivor区，
   之后每经过一次Minor GC那么对象的年龄加1，
   知道达到阀值对象进入老年区。
4. 动态判断对象的年龄。
   如果Survivor区中相同年龄的
   所有对象大小的总和大于Survivor空间的一半，
   年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，
   JVM会计算Survivor区移至老年区的对象的平均大小，
   如果这个值大于老年区的剩余值大小则进行一次Full GC，
   如果小于检查HandlePromotionFailure设置，
   如果true则只进行Monitor GC,如果false则进行Full GC。 

# 8.内存泄露与内存溢出

## 8-1：什么是内存泄漏

指一个不再被程序使用的对象或变量一直被占据在内存中。 

### 8-1-1：如何检测内存泄露？

可以通过一些性能监测分析工具， 如 JProfiler、 Optimizeit Profiler。

## 8-2：什么是内存溢出

指程序申请内存时，没有足够的内存供申请者使用，
或者说，给了你一块存储int类型数据的存储空间，
但是你却存储long类型的数据，那么结果就是内存不够用，

### 8-2-2：手写出现内存溢出的情形
```java
public class Test {

    public void testHeap(){
        for(;;){
              ArrayList list = new ArrayList (2000);
          }
    }
    int num=1;
    public void testStack(){
        num++;
        this.testStack();
     }
    
    public static void main(String[] args){
        Test  t  = new Test ();
        t.testHeap();
        t.testStack();   
    }
}
```

## 8-3：内存溢出，内存泄漏区别

1. 内存泄露积累起来将导致内存溢出。
2. 内存泄露可以通过完善代码来避免；
          内存溢出可以通过调整配置来减少发生频率，
          但无法彻底避免。

## 8-4：如何避免内存泄露、溢出

1. 尽早释放无用对象的引用。
2. 使用临时变量的时候，
   让引用变量在退出活动域后自动设置为null，
   暗示垃圾收集器来收集该对象，
   防止发生内存泄露。
3. 程序进行字符串处理时，
   尽量避免使用String，
   而应使用StringBuffer，
   因为每一个String对象都会独立占用内存一块区域

## 8-5：内存结构的溢出与泄露

### 8-5-1：溢出

`栈溢出(StackOverflowError)`
栈溢出就是方法执行是创建的栈帧超过了栈的深度。
那么最有可能的就是方法递归调用产生这种结果。
`堆溢出(OutOfMemoryError:java heap space)`
堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出
`计数器溢出`
不会发生溢出，因为它所需要存储的内容仅仅
就是下一个需要待执行的命令的地址，
无论代码有多少，最坏情况下死循环也不会让这块内存区域超限

#### 8-5-1-1：溢出例子

```java
public class testCode {
    public void testHeap(){//堆溢出
        List<byte[]> list = new ArrayList<>();
        int i=0;
        while (true){
            list.add(new byte[5*1024*1024]);
            System.out.println("count is: "+(++i));
        }
    }
    int num = 1;
    public void testStack(){ //栈溢出
        num++;
        this.testStack();
    }
    public static void main(String[] agrs){
       testCode t = new testCode();
        t.testHeap();
        t.testStack();
    }
}
```

### 8-5-2：泄露

`堆泄露`
非静态内部类创建静态实例造成的内存泄漏
单例造成的内存泄漏
线程造成的内存泄漏

`栈泄露`
比如说栈中的元素已经弹出，
已经没有用了。但是事实上，
被弹出的元素依然存在于某个数组中，
它依然被某个数组所引用，GC是无法回收被引用着的对象的。



# 9.调优工具

常用调优工具分为两类

1. jdk自带监控工具：jconsole和jvisualvm，
2. 第三方监控工具：MAT(Memory Analyzer Tool)、GChisto。

jconsole，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控
jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
MAT，一个基于Eclipse的内存分析工具，是一个快速、
     功能丰富的Java heap分析工具，
     它可以帮助我们查找内存泄漏和减少内存消耗
GChisto，一款专业分析gc日志的工具

# 10.## 3-2：强、软、弱、虚引用

1. `强引用（StrongReference）`
如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，
Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，
也不会靠随意回收具有强引用的对象来解决内存不足问题。
2. `软引用（SoftReference）`
如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，
如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，
该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，
如果软引用所引用的对象被垃圾回收，
JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。
3. `弱引用（WeakReference）`
如果一个对象只具有弱引用，弱引用关联的对象只能生存到下一次垃圾回收之前。
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。
在垃圾回收器线程扫描它所管辖的内存区域的过程中，
一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，
都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 
因此不一定会很快发现那些只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，
如果弱引用所引用的对象被垃圾回收，
Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。
4. `虚引用（PhantomReference）`
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，
那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
虚引用主要用来跟踪对象被垃圾回收的活动。

## 10-1:虚引用与软引用和弱引用的一个区别

虚引用必须和引用队列（ReferenceQueue）联合使用。
当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
程序可以通过判断引用队列中是否已经加入了虚引用，
来了解被引用的对象是否将要被垃圾回收。
程序如果发现某个虚引用已经被加入到引用队列，
那么就可以在所引用的对象的内存被回收之前采取必要的行动。

# 10.JVM进程有哪些线程启动? (拼多多)

1. main主线程，执行我们指定的启动类的main方法
2. Reference Handler处理引 用的线程，
   用于处理引用对象本身(软引用、弱引用、虚引用)的垃圾回收问题
3. Finalizer调用对象的finalize方法的线程，就是垃圾回收的线程
4. Signal Dispatcher分发处理发送给JVM信号的线程
5. Attach Listener负责接收外部的命令的线程

# 11.jvm启动模式之client 与server

jvm启动时，通过-server 或-client参数指定启动模式。

(1)编译器方面:
当虚拟机运行在client 模式时，使用的是一一个代号为 c1的轻量级编译器，
而server模式启动时，虚拟机采用的是相对重量级，代号为c2的编译器: 
c2编译器比cl编译器编译的相对彻底，服务起来之后，性能高。

(2)gc方面:
cilent模式下的新生代(Serial 收集器)和老年代(Serial Old)
选择的是串行gc server模式下的新生代选择并行回收ge,老年代选择并行ge

(3)启动方面:
client模式启动快，编译快，内存占用少，针对桌面应用程序设计，
优化客户端环境的启动时间。
server模式启动慢，编译更完全，编译器是自适应编译器，效率高，
针对服务端应用设计，优化服务器环境的最大化程序执行速度

# 12.简述JVM中静态分派和动态分派(引申:重载和重写)

1.静态分派:依赖静态类型定位方法的分派，发生在编译时期，奥型应用为方法的秋.
(重载的参数是通过静态类型确定的，直接调用父类)
2、动态分配:在运行时期根据实际类型来确定方法的分派，发生在程序运行时，
典型应用
是方法的重写，也是多态的一种体现。 根据转型来确定是否调用父类还是子类的方法。
虚方法和非虚方法:
(1)非虚方法(所有statie方法+final/private方法)通过invokespecial指令调用，对这个
非虚方法的符号引用将转为对应的直接引用，即转为直接引用方法，在编译完成时就确定唯
一的调用方法。
(2)虚方法是通过invokevirtual 指令调用，且会有静态或者动态分派分派。具体先根据编
译期时方法接收者和方法参数的静态类型来分派，再在运行期根据只根据方法接收者的实际
类型来分派。