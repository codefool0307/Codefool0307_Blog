<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-09-02 15:03:02
 * @FilePath: \docs\4.interview\7-Mysql面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

<!-- TOC -->

- [1.索引](#1索引)
  - [1-1：索引是什么](#1-1索引是什么)
  - [1-2：为什么要用索引（优点）](#1-2为什么要用索引优点)
  - [1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）](#1-3索引这么多优点为什么不对表中的每一个列创建一个索引呢缺点)
  - [1-4：索引的主要原理，常用算法](#1-4索引的主要原理常用算法)
  - [1-5：创建索引原则（使用场景）：](#1-5创建索引原则使用场景)
  - [1-6：创建索引的注意事项](#1-6创建索引的注意事项)
  - [1-7：为什么索引能够提高查询速度](#1-7为什么索引能够提高查询速度)
  - [1-8：创建索引的三种方式](#1-8创建索引的三种方式)
  - [1-9：最左前缀原则](#1-9最左前缀原则)
  - [1-10：最左匹配原则](#1-10最左匹配原则)
- [2.索引的分类](#2索引的分类)
  - [2-1：索引的分类](#2-1索引的分类)
  - [2-2：各种索引定义](#2-2各种索引定义)
- [3.索引的结构](#3索引的结构)
  - [3-1：mysql索引的结构](#3-1mysql索引的结构)
  - [3-2：B+树比B树的优势](#3-2b树比b树的优势)
  - [3-3：B+树与红黑树比较](#3-3b树与红黑树比较)
  - [3-4：B+树与hash索引比较](#3-4b树与hash索引比较)
  - [3-5：聚簇索引与非聚簇索引概念](#3-5聚簇索引与非聚簇索引概念)
  - [3-6：聚簇索引的优缺点](#3-6聚簇索引的优缺点)
  - [3-7：非聚簇索引的优缺点](#3-7非聚簇索引的优缺点)
- [4.数据库优化](#4数据库优化)
  - [4-1：为什么要优化](#4-1为什么要优化)
  - [4-2：索引优化](#4-2索引优化)
  - [4-3：查询优化](#4-3查询优化)
  - [4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决](#4-4当mysql单表记录数过大时数据库的crud性能会明显下降如何解决)
  - [4-5：垂直分表](#4-5垂直分表)
  - [4-6：水平分表](#4-6水平分表)
  - [4-7：分库分表，id如何处理](#4-7分库分表id如何处理)
  - [4-8：SQL的生命周期](#4-8sql的生命周期)
  - [4-9：mysql分页，超大分页怎么处理？](#4-9mysql分页超大分页怎么处理)
  - [4-10：慢查询优化](#4-10慢查询优化)
  - [4-11：为什么要尽量设定一个主键?](#4-11为什么要尽量设定一个主键)
  - [4-12：主键使用自增ID还是UUID?](#4-12主键使用自增id还是uuid)
  - [4-13：字段为什么要求定义为not null?](#4-13字段为什么要求定义为not-null)
- [5.事务](#5事务)
  - [5-1：什么是事务](#5-1什么是事务)
  - [5-2：数据库事务特性](#5-2数据库事务特性)
  - [5-3：为什么保证原子性和持久化](#5-3为什么保证原子性和持久化)
  - [5-3：四大隔离级别](#5-3四大隔离级别)
  - [5-4：并发事务带来什么问题](#5-4并发事务带来什么问题)
  - [5-5：数据库崩溃时事务的恢复机制](#5-5数据库崩溃时事务的恢复机制)
  - [5-7：Undo Log缺陷如何解决？](#5-7undo-log缺陷如何解决)
- [6.数据库基础知识](#6数据库基础知识)
  - [6-1：为什么要使用数据库](#6-1为什么要使用数据库)
  - [6-2: 什么是SQL？](#6-2-什么是sql)
  - [6-3：什么是MySQL?](#6-3什么是mysql)
  - [6-4：数据库三大范式是什么](#6-4数据库三大范式是什么)
  - [6-5：mysql有关权限的表都有哪几个](#6-5mysql有关权限的表都有哪几个)
  - [6-6：MySQL的binlog有有几种录入格式？分别有什么区别？](#6-6mysql的binlog有有几种录入格式分别有什么区别)
  - [6-7：mysql的数据类型](#6-7mysql的数据类型)
- [7.mysql引擎](#7mysql引擎)
  - [7-1：MySQL存储引擎MyISAM与InnoDB区别](#7-1mysql存储引擎myisam与innodb区别)
  - [7-2：InnoDB引擎的4大特性](#7-2innodb引擎的4大特性)
  - [7-3：InnoDB存储引擎的锁的算法：](#7-3innodb存储引擎的锁的算法)
  - [7-4：MyISAM和InnoDB存储引擎使用的锁：](#7-4myisam和innodb存储引擎使用的锁)
  - [7-5：表级锁和行级锁对比：](#7-5表级锁和行级锁对比)
- [8.锁](#8锁)
  - [8-1：隔离级别与锁的关系](#8-1隔离级别与锁的关系)
  - [8-2：封锁粒度](#8-2封锁粒度)
- [9.什么是慢查询](#9什么是慢查询)
- [10.应用](#10应用)
  - [10.1：一条SQL语句执行得很慢的原因有哪些](#101一条sql语句执行得很慢的原因有哪些)
  - [10.2：为什么数据库会选错了索引](#102为什么数据库会选错了索引)
- [11.常用sql的语句](#11常用sql的语句)
  - [11-1：SQL语句主要分为哪几类](#11-1sql语句主要分为哪几类)
  - [11-2：超键、候选键、主键、外键分别是什么？](#11-2超键候选键主键外键分别是什么)
  - [11-3：为什么用自增列作为主键](#11-3为什么用自增列作为主键)
  - [11-4：truncate、 delete区别](#11-4truncate-delete区别)
  - [11-5：什么是临时表，临时表什么时候删除?](#11-5什么是临时表临时表什么时候删除)
  - [11-6：非关系型数据库和关系型数据库区别，优势比较?](#11-6非关系型数据库和关系型数据库区别优势比较)
  - [11-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?](#11-7什么是-内连接外连接交叉连接笛卡尔积等)
  - [11-8：varchar与char的区别](#11-8varchar与char的区别)
  - [11-9：count(*)、count(1)、count(column)的区别](#11-9countcount1countcolumn的区别)
  - [11-10：SQL 约束有哪几种？](#11-10sql-约束有哪几种)
  - [11-11：六种关联查询](#11-11六种关联查询)
  - [11-12：什么是子查询](#11-12什么是子查询)
  - [11-13：子查询的三种情况](#11-13子查询的三种情况)
  - [11-14：mysql中 in 和 exists 区别](#11-14mysql中-in-和-exists-区别)
  - [11-15：varchar(50)中50的涵义](#11-15varchar50中50的涵义)
  - [11-16：int(20)中20的涵义](#11-16int20中20的涵义)
  - [11-17：FLOAT和DOUBLE的区别是什么？](#11-17float和double的区别是什么)
  - [11-18：UNION与UNION ALL的区别？](#11-18union与union-all的区别)
- [12.主从复制](#12主从复制)
  - [12-1：什么是主从复制：](#12-1什么是主从复制)
  - [12-2：主从复制的作用（好处，或者说为什么要做主从）：](#12-2主从复制的作用好处或者说为什么要做主从)
  - [12-3：主从复制的原理（重中之重，面试必问）](#12-3主从复制的原理重中之重面试必问)
  - [12-1：主从复制的几种方式](#12-1主从复制的几种方式)

<!-- /TOC -->
# 1.索引

## 1-1：索引是什么

索引（Index）是帮助 MySQL 高效获取数据的数据结构，是一种排好序的数据结构

## 1-2：为什么要用索引（优点）

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会
   更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 1-4：索引的主要原理，常用算法

通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

## 1-5：创建索引原则（使用场景）：

1. 对于查询频率高的字段创建索引；
2. 对排序、分组、联合查询频率高的字段创建索引； 
3. 索引的数目不宜太多

   * 因为每创建一个索引都会占用相应的物理控件，过多的索引会导致insert、update、delete语句的执行效率降低；

4. 若在实际中，需要将多个列设置索引时，可以采用多列索引

5. 选择唯一性索引

   * 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯
     一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

6. 尽量使用数据量少的索引

   * 如果索引的值很长，那么查询的速度会受到影响。

7. 尽量使用前缀来索引

   * 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字
     段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

## 1-6：创建索引的注意事项

1. 限制表上的索引数目。
 
2. 避免在取值朝一个方向增长的字段（例如：日期类型的字段）上，建立索引；对复合索引，避免将这种类型的字段放置在最前面。由于字段的取值总是朝一个方向增长，新记录总是存放在索引的最后一个叶页中，从而不断地引起该叶页的访问竞争、新叶页的分配、中间分支页的拆分。此外，如果所建索引是聚集索引，表中数据按照索引的排列顺序存放，所有的插入操作都集中在最后一个数据页上进行，从而引起插入“热点”。
 
3. 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用。因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。
 
4. 删除不再使用，或者很少被使用的索引。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再被需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。


## 1-7：为什么索引能够提高查询速度

如果我们写select * from user where name = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

定位到记录所在的页：需要遍历双向链表，找到所在的页

从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

使用索引之后，其实就是通过二分查找的思想将无序的数据变成有序(相对)

## 1-8：创建索引的三种方式


## 1-9：最左前缀原则

以最左边的为起点任何连续的索引都能匹配上。

（1）如果第一个字段是范围查询需要单独建一个索引；

（2）在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；

当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！

## 1-10：最左匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

# 2.索引的分类

## 2-1：索引的分类

1. 主键索引
2. 二级索引
   * 唯一索引
   * 普通索引
   * 前缀索引
   * 全文索引

## 2-2：各种索引定义

1. 主键索引：数据表的主键列使用的就是主键索引。

在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。

2. 二级索引(辅助索引)

因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。

3. 唯一索引(Unique Key) ：目的是为了该属性列的数据的唯一性，而不是为了查询效率。

4. 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。

5. 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更
   小， 因为只取前几个字符。

6. 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息

7. 覆盖索引：如果一个索引包含（或者说覆盖）所有需要查询的字段的值

# 3.索引的结构

## 3-1：mysql索引的结构

1. B树索引与B+树索引

2. 聚簇索引与非聚簇索引

3. Hash索引

4. 全文索引

5. 空间索引

## 3-2：B+树比B树的优势

1. B+树空间利用率更高，可减少I/O次数

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘1O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。也就是说: B+树中每
个非叶子节点没有指向某个关健字具体信息的指针，所以好个节点可以存放更多的关键字数量，减少了I/0操作。

2. 增删文件(节点)时，效率更高
因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。

3. B+树的查询效率更加稳定
因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相
当。


## 3-3：B+树与红黑树比较

1. 更少的查找次数

复杂度和树高h相关，红黑树的树高h很明显比B+Tee大非常多，查找的次数也就更多。

2. 利用磁盘预读特性

为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻
道，并且只需要很短的旋转时间，速度会非常快。

## 3-4：B+树与hash索引比较

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值。当然了，这个前提是，键值都是唯
   一的。 如果键值不是唯的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据:

2. 如果是范围查询检索，原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索:


## 3-5：聚簇索引与非聚簇索引概念

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。

非聚集索引即索引结构和数据分开存放的索引。

## 3-6：聚簇索引的优缺点

一、优点

由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

二、缺点
1. 对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
2. 由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。
3. 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。

## 3-7：非聚簇索引的优缺点

一、优点

更新代价比聚集索引要小，非聚集索引的叶子节点是不存放数据的

二、缺点

非聚集索引也依赖于有序的数据
可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 
当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。


# 4.数据库优化

## 4-1：为什么要优化

1. 避免网站页面出现访问错误

   由于慢查询造成页面无法加载
   由于阻塞造成数据无法提交
   增加数据库的稳定性

2. 很多数据库问题都是由于低效的查询引起的

## 4-2：索引优化

书本

## 4-3：查询优化

书本

## 4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决

1. 限定数据的范围
务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

2. 读/写分离
经典的数据库拆分方案，主库负责写，从库负责读；

3. 垂直分区
根据数据库里面数据表的相关性进行拆分。 

4. 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

## 4-5：垂直分表

垂直拆分的优点： 可以使得列数据变小，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让
事务变得更加复杂

## 4-6：水平分表

 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂

一般是水平分库，数据库分片的两种常见方案：

1. 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
2. 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 


## 4-7：分库分表，id如何处理

方式1——UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示
   比如文件的名字。

方式2——数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独
立部署数据库实例，成本高，还会有性能瓶颈。

方式3——利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编
码更加复杂，增加了系统成本。


## 4-8：SQL的生命周期

1. 建立服务器与数据库连接
2. 数据库拿到SQL
3. 解析执行
4. 读取数据到内存，进行业务逻辑处理
5. 发给客户端
6. 关闭连接，释放资源


## 4-9：mysql分页，超大分页怎么处理？

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.

从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.

                     
## 4-10：慢查询优化

1. 索引没起作用的情况

       1. 使用LIKE关键字的查询语句

               在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。

       2. 使用多列索引的查询语句

               MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。

2. 优化数据库结构

              合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

          1. 将字段很多的表分解成多个表 

                对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

          2. 增加中间表

                对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

3. 分解关联查询

         将一个大的查询分解为多个小查询是很有必要的。

         很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：     

4. 优化LIMIT分页

## 4-11：为什么要尽量设定一个主键?

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

## 4-12：主键使用自增ID还是UUID?

推荐使用自增ID,不要使用UUID.

因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

## 4-13：字段为什么要求定义为not null?

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.

# 5.事务

## 5-1：什么是事务

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

## 5-2：数据库事务特性

1. 原⼦性（Atomicity）：事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要
   么完全不起作⽤；
2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据
   库是独⽴的；
4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故
   障也不应该对其有任何影响。

## 5-3：为什么保证原子性和持久化

首先原子性方面，更新数据前记录Undo log。

为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩
溃，undo log是完整的， 可以用来回滚事务。如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。


## 5-3：四大隔离级别

1. 读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。
2. 读取已提交： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发
               ⽣。
3. 可重复读：   对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏
               读和不可重复读，但幻读仍有可能发⽣。
4. 可串⾏化：   最⾼的隔离级别， 该级别可以防⽌脏读、不可重复读以及幻读。


## 5-4：并发事务带来什么问题

1. 脏读: 
2. 不可重复读: 
3. 幻读: 

书本

## 5-5：数据库崩溃时事务的恢复机制

为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方，这个存储数据备份的地方称为UndoLog。然后进行数据的修改。如果出现了错误或者
用户执行了回滚，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

## 5-7：Undo Log缺陷如何解决？

每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。

因此引入了另外一种机制来实现持久化，即Redo Log。

Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经
持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

# 6.数据库基础知识
## 6-1：为什么要使用数据库


## 6-2: 什么是SQL？


## 6-3：什么是MySQL?


## 6-4：数据库三大范式是什么

第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主
键.

## 6-5：mysql有关权限的表都有哪几个

user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。

## 6-6：MySQL的binlog有有几种录入格式？分别有什么区别？

有三种格式,statement,row和mixed.

statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.

row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.

mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

## 6-7：mysql的数据类型

整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

浮点数类型：FLOAT、DOUBLE、DECIMAL

字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

日期类型：Date、DateTime、TimeStamp、Time、Year


# 7.mysql引擎

## 7-1：MySQL存储引擎MyISAM与InnoDB区别

## 7-2：InnoDB引擎的4大特性

1.插入缓冲（insert buffer)
提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效

只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。

2.二次写(double write)

Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入

在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write
doublewrite组成：
内存中的doublewrite buffer,大小2M。
物理磁盘上共享表空间中连续的128个页，即2个区（extend），大小同样为2M。
对缓冲池的脏页进行刷新时，不是直接写磁盘，而是会通过memcpy()函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite 再分两次，每次1M顺序地写入共享表空间的物理磁盘上，在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer 中的页写入各个 表空间文件中，此时的写入则是离散的。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，innodb可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。



3.自适应哈希索引(ahi)

Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数
关闭

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1),即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般3-4层，故需要3-4次的查询。

innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
AHI有一个要求，就是对这个页的连续访问模式必须是一样的。
例如对于（a,b）访问模式情况：
where a = xxx
where a = xxx and b = xxx

特点
　　1、无序，没有树高
　　2、降低对二级索引树的频繁访问资源，索引树高<=4，访问索引：访问树、根节点、叶子节点
　　3、自适应
3、缺陷
　　1、hash自适应索引会占用innodb buffer pool；
　　2、自适应hash索引只适合搜索等值的查询，如select * from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；
　　3、极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读。

 

4.预读(read ahead)
InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）
为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。

## 7-3：InnoDB存储引擎的锁的算法：

Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock： record+gap 锁定⼀个范围，包含记录本身

## 7-4：MyISAM和InnoDB存储引擎使用的锁：

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

## 7-5：表级锁和行级锁对比：

表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

# 8.锁

## 8-1：隔离级别与锁的关系



## 8-2：封锁粒度


# 9.什么是慢查询

它用来记录在MySQL中响应时间超过阀值的语句日志记录

# 10.应用

## 10.1：一条SQL语句执行得很慢的原因有哪些

要分两种情形：

1. 大多数情况是正常的，只是偶尔会出现很慢的情况。
   
   * 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
   * 执行的时候，遇到锁，如表锁、行锁。

2. 在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。
   
   * 没有用上索引
   * 数据库选错了索引

## 10.2：为什么数据库会选错了索引

系统在执行的时候，会进行预测，是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？

扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，需要走两次索引，而且，我们也不知道符合 这个条件的数据有多少行，万一真的是n条，那就惨了，所以系统是有可能走全表扫描而不走索引的

系统如何进行预判主要依赖于索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。

这个区分度也叫做基数，系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的

那么出现失误的地方就是采样，比如采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后，系统就不走索引了，直接走全部扫描了。

主要是由于统计的失误，导致系统没有走索引，而是走了全表扫描。


# 11.常用sql的语句

## 11-1：SQL语句主要分为哪几类

DDL-------数据定义语言
DQL-------数据查询语言
DML-------数据操纵语言
DTL-------事务控制语言
DCL-------数据控制语言

## 11-2：超键、候选键、主键、外键分别是什么？

超键：一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）

外键：在一个表中存在的另一个表的主键称此表的外键。

## 11-3：为什么用自增列作为主键

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

## 11-4：truncate、 delete区别

## 11-5：什么是临时表，临时表什么时候删除?

临时表可以手动删除：

临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。

## 11-6：非关系型数据库和关系型数据库区别，优势比较?

非关系型数据库的优势：

 - 性能：NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。

 - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：

 - 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
 
 - 事务支持：使得对于安全性能很高的数据访问要求得以实现。

## 11-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?

1. 内连接: 只连接匹配的行

2. 左外连接: 包含左边表的全部行，以及右边表中全部匹配的行

3. 右外连接: 包含右边表的全部行，以及左边表中全部匹配的行

4. 全外连接: 包含左、右两个表的全部行。

5. 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 11-8：varchar与char的区别

书本

## 11-9：count(*)、count(1)、count(column)的区别

count(*)对行的数目进行计算,包含NULL，count(1)这个用法和count(*)的结果是一样的

count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

## 11-10：SQL 约束有哪几种？

NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
CHECK: 用于控制字段的值范围。

## 11-11：六种关联查询

1. 交叉连接(CROSS JOIN)
2. 内连接(INNER JOIN)
3. 外连接(LEFT JOIN/RIGHT JOIN)
4. 交叉连接
5. 联合查询(UNION 与 UNION ALL)
6. 全连接(FULL JOIN)
   
## 11-12：什么是子查询

在select嵌套select

## 11-13：子查询的三种情况

1. 子查询结果只要是单行单列， 肯定在 WHERE 后面作为条件

2. 子查询结果是多行单列，结果类似于一个数组，父查询使用 in 运算符

3. 子查询结果只要是多列，肯定在 From 后面作为表


## 11-14：mysql中 in 和 exists 区别

1. exists()适合B表比A表数据大的情况

2. 当A表数据与B表数据一样大时,in与exists效率差不多,可任选一个使用

## 11-15：varchar(50)中50的涵义

varchar(50)中50的涵义最多存放50个字符

## 11-16：int(20)中20的涵义

int(M)只是用来显示数据的宽度，比如说int（20），mysql会自动补0

## 11-17：FLOAT和DOUBLE的区别是什么？

1. 在内存中占有的字节数不同

　　　　单精度浮点数在机内存占4个字节

　　　　双精度浮点数在机内存占8个字节

2. 有效数字位数不同

　　　　单精度浮点数有效数字8位

　　　　双精度浮点数有效数字16位

3. 数值取值范围

4. 在程序中处理速度不同

　　　　一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快

## 11-18：UNION与UNION ALL的区别？

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union All：对两个结果集进行并集操作，包括重复行，不进行排序；


# 12.主从复制

## 12-1：什么是主从复制：

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。

## 12-2：主从复制的作用（好处，或者说为什么要做主从）：

1、做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。

2、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

3、读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。

## 12-3：主从复制的原理（重中之重，面试必问）

1. 数据库有个bin-log二进制文件，记录了所有sql语句。

2. 我们的目标就是把主数据库的bin-log文件的sql语句复制过来。

3. 让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。

4. 具体需要三个线程来操作：

binlog输出线程。每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。

在从库里，当复制开始的时候，从库就会创建两个线程进行处理：

从库I/O线程。当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。

从库的SQL线程。从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。

可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。

步骤一：主库db的更新事件(update、insert、delete)被写到binlog

步骤二：从库发起连接，连接到主库

步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库

步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log

步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db


## 12-1：主从复制的几种方式

1. 同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。不会使用，比如，在WEB前端页面上，用户增加了条记录，需要
   等待很长时间。

2. 异步复制:如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。

3. 半同步复制:master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。

