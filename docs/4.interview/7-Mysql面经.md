<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-16 11:09:46
 * @FilePath: \docs\4.interview\7-Mysql面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

# 数据库的特性




## 四大隔离级别

1. 读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。
2. 读取已提交： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发
               ⽣。
3. 可重复读：   对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏
               读和不可重复读，但幻读仍有可能发⽣。
4. 可串⾏化：   最⾼的隔离级别， 该级别可以防⽌脏读、不可重复读以及幻读。



# 存储引擎


# 索引

## 索引是什么

索引（Index）是帮助 MySQL 高效获取数据的数据结构，是一种排好序的数据结构

## 为什么要用索引

由于我们自己在书写sql的时候查询语句写的不合理，使用过多的查询语句等等问题导致性能下降、执行时间长、等待时间长等问题，那么就引入了索引的概念

## 索引的优缺点

优点：
1. 提高数据检索效率，降低数据的IO成本
2. 降低数据排序成本，降低CPU消耗

缺点：
1. 索引也是一张表，索引本身也是要占用空间的
2. 索引虽然提高了查询速度，但是降低了更新表的速度

## 索引的分类

1. 单值索引
2. 唯一索引
3. 复合索引
4. 主键索引

## mysql的索引结构

1. B树

2. B+树

## B树与B+树的区别

1. B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)
2. 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。 

## B+树相比于B树的查询优势

1) B+树的磁盘读写代价更低 
　　
B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 
2) B+树的查询效率更加稳定 
　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## B+树与红黑树比较

## B+树与hash索引比较

# MySQL优化

## 索引优化

## 查询优化

# 聚集索引与非聚集索引



# 事务

## 什么是事务

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

## 数据库事务特性

1. 原⼦性（Atomicity）：事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要
   么完全不起作⽤；
2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据
   库是独⽴的；
4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故
   障也不应该对其有任何影响。


## 并发事务带来什么问题

1. 脏读: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交到数据库中，这时另外⼀
   个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没有提交的数据，那么另外⼀个事务
   读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

2. 不可重复读（Unrepeatableread） : 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束时，另⼀
   个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改导致第⼀个事务
   两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不⼀样的情况，因此称为不可
   重复读。

3. 幻读（Phantom read） : 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接着另⼀
   个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了⼀些原本不存在
   的记录，就好像发⽣了幻觉⼀样，所以称为幻读。

## InnoDB存储引擎的锁的算法：

Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock： record+gap 锁定⼀个范围，包含记录本身










## myisam和innodb区别，为什么一个用聚簇索引一个用非聚簇索引 因为两个数据文件结果不一样





# mysql引擎

## MyISAM和InnoDB区别

MyISAM是MySQL的默认数据库引擎。虽然性能极佳，⽽且提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和⾏级锁，⽽且最⼤的缺陷就是崩溃后⽆法安全恢复。不过， 5.5版本之后， MySQL引⼊了InnoDB（事务性数据库引擎）， MySQL 5.5版本后默认的存储引擎为InnoDB。
⼤多数时候我们使⽤的都是 InnoDB 存储引擎，但是在某些情况下使⽤ MyISAM 也是合适的⽐如读密集
的情况下。

比较9条




## 聚集索引



## 1. 联合索引
## 2.给一个语句，判断是否走索引
## 3.为什么范围查询不走索引
## 4. 慢查询怎么排查
## 5.除了索引还有什么优化的方向

## mysql索引下推，回表，cache机制

## 单个删和批量删的sql执行效率怎么样呢？

## mysql 索引介绍


## 如果判断一个用户id存在在一张表里面

## 数据库在什么情况下会发生死锁？

## 解决死锁的方法

## 数据库的隔离级别及解决的问题 怎么设置可串行化

## 聚簇索引和非聚簇索引 及使用的场景

## 数据库八股文和Mysql主从同步机制，binlog的原理

## Mysql主从同步机制，redo log和bin log的区别


# ACID特性



# MySQL引擎

## -1：你知道哪几种引擎
常用引擎有：

1. InnoDB

2. MyISAM

除此之外还有Memory

##  引擎区别

见书p63


## 索引类型

# mangodb和mysql

## -1：mangodb和mysql的区别

![avatar](http://code.clouddn.com/11-xxx.jpg)

## -2：mysql优缺点

优势：

在不同的引擎上有不同 的存储方式。

查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。

开源数据库的份额在不断增加，mysql的份额页在持续增长。

   缺点：

在海量数据处理的时候效率会显著变慢。


## -3：mangodb优缺点

1. 快速
2. 高扩展
3. json存储格式
4. 主库遇到问题无法继续提供服务时，副本集选举一个主库继续提供服务
   
缺点：

不支持事务，而且开发文档不是很完全，完善。

## -4：mangodb一个文件相当于mysql的一个什么？

不知道



## mysql的四个隔离级别以及默认隔离级别

p57

## 那么MySQL可重复读是如何实现的呢？

使用的的一种叫MVCC的控制方式，多版本并发控制，类似于乐观锁的一种实现方式

实现方式：

InnoDB在每行记录后面保存两个隐藏的列来，分别保存了这个行的创建时间和行的删除时间。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1

在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号<=当前版本号的数据

此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了

## 数据库的隔离级别，能否解决幻读，间隙锁如何生效

