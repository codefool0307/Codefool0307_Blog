<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-09-02 15:03:02
 * @FilePath: \docs\4.interview\7-Mysql面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

<!-- TOC -->

- [1.索引](#1索引)
  - [1-1：索引是什么](#1-1索引是什么)
  - [1-2：为什么要用索引（优点）](#1-2为什么要用索引优点)
  - [1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）](#1-3索引这么多优点为什么不对表中的每一个列创建一个索引呢缺点)
  - [1-4：索引的主要原理，常用算法](#1-4索引的主要原理常用算法)
  - [1-5：创建索引原则（使用场景）：](#1-5创建索引原则使用场景)
  - [1-6：创建索引的注意事项](#1-6创建索引的注意事项)
  - [1-7：为什么索引能够提高查询速度](#1-7为什么索引能够提高查询速度)
  - [1-8：创建索引的三种方式](#1-8创建索引的三种方式)
  - [1-9：最左前缀原则](#1-9最左前缀原则)
  - [1-10：最左匹配原则](#1-10最左匹配原则)
- [2.索引的分类](#2索引的分类)
  - [2-1：索引的分类](#2-1索引的分类)
  - [2-2：各种索引定义](#2-2各种索引定义)
- [3.索引的结构](#3索引的结构)
  - [3-1：mysql索引的结构](#3-1mysql索引的结构)
  - [3-2：B+树比B树的优势](#3-2b树比b树的优势)
  - [3-3：B+树与红黑树比较](#3-3b树与红黑树比较)
  - [3-4：B+树与hash索引比较](#3-4b树与hash索引比较)
  - [3-5：聚簇索引与非聚簇索引概念](#3-5聚簇索引与非聚簇索引概念)
  - [3-6：聚簇索引的优缺点](#3-6聚簇索引的优缺点)
  - [3-7：非聚簇索引的优缺点](#3-7非聚簇索引的优缺点)
- [4.数据库优化](#4数据库优化)
  - [4-1：为什么要优化](#4-1为什么要优化)
  - [4-2：索引优化](#4-2索引优化)
  - [4-3：查询优化](#4-3查询优化)
  - [4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决](#4-4当mysql单表记录数过大时数据库的crud性能会明显下降如何解决)
  - [4-5：垂直分表](#4-5垂直分表)
  - [4-6：水平分表](#4-6水平分表)
  - [4-7：为什么要分库分表？](#4-7为什么要分库分表)
  - [4-8：分库分表，id如何处理](#4-8分库分表id如何处理)
  - [4-9：为什么 MySQL 不推荐使用 uuid 或者雪花 id 作为主键？](#4-9为什么-mysql-不推荐使用-uuid-或者雪花-id-作为主键)
  - [4-10：使用自增id的缺点](#4-10使用自增id的缺点)
  - [4-11：SQL的生命周期](#4-11sql的生命周期)
  - [4-12：mysql分页，超大分页怎么处理？](#4-12mysql分页超大分页怎么处理)
  - [4-13：慢查询优化](#4-13慢查询优化)
  - [4-14：为什么要尽量设定一个主键?](#4-14为什么要尽量设定一个主键)
  - [4-15：主键使用自增ID还是UUID?](#4-15主键使用自增id还是uuid)
  - [4-16：字段为什么要求定义为not null?](#4-16字段为什么要求定义为not-null)
- [5.事务](#5事务)
  - [5-1：什么是事务](#5-1什么是事务)
  - [5-2：数据库事务特性](#5-2数据库事务特性)
  - [5-3：为什么保证原子性和持久化](#5-3为什么保证原子性和持久化)
  - [5-4：四大隔离级别](#5-4四大隔离级别)
  - [5-5：隔离级别的原理](#5-5隔离级别的原理)
  - [5-6：MySQL 中RC和RR隔离级别的区别](#5-6mysql-中rc和rr隔离级别的区别)
  - [5-7：隔离级别用来做什么](#5-7隔离级别用来做什么)
  - [5-8：并发事务带来什么问题](#5-8并发事务带来什么问题)
  - [5-9：数据库崩溃时事务的恢复机制](#5-9数据库崩溃时事务的恢复机制)
  - [5-10：Undo Log缺陷如何解决？](#5-10undo-log缺陷如何解决)
- [6.数据库基础知识](#6数据库基础知识)
  - [6-1：为什么要使用数据库](#6-1为什么要使用数据库)
  - [6-2: 什么是SQL？](#6-2-什么是sql)
  - [6-3：什么是MySQL?](#6-3什么是mysql)
  - [6-4：数据库三大范式是什么](#6-4数据库三大范式是什么)
  - [6-5：mysql有关权限的表都有哪几个](#6-5mysql有关权限的表都有哪几个)
  - [6-6：MySQL的binlog有有几种录入格式？分别有什么区别？](#6-6mysql的binlog有有几种录入格式分别有什么区别)
  - [6-7：mysql的数据类型](#6-7mysql的数据类型)
- [7.mysql引擎](#7mysql引擎)
  - [7-1：MySQL存储引擎MyISAM与InnoDB区别](#7-1mysql存储引擎myisam与innodb区别)
  - [7-2：InnoDB引擎的4大特性](#7-2innodb引擎的4大特性)
  - [7-3：InnoDB存储引擎的锁的算法](#7-3innodb存储引擎的锁的算法)
  - [7-4：MyISAM和InnoDB存储引擎使用的锁](#7-4myisam和innodb存储引擎使用的锁)
  - [7-5：表级锁和行级锁对比：](#7-5表级锁和行级锁对比)
  - [7-6：Innodb如何加锁](#7-6innodb如何加锁)
  - [7-7：Innodb解决死锁](#7-7innodb解决死锁)
- [8.锁](#8锁)
  - [8-1：隔离级别与锁的关系](#8-1隔离级别与锁的关系)
  - [8-2：封锁粒度](#8-2封锁粒度)
  - [8-3：锁的类型](#8-3锁的类型)
  - [8-4：三级封锁协议](#8-4三级封锁协议)
  - [8-5：封锁粒度](#8-5封锁粒度)
  - [8-6：排它锁](#8-6排它锁)
  - [8-7：排他锁和共享锁的兼容性](#8-7排他锁和共享锁的兼容性)
- [9.阻塞](#9阻塞)
  - [9-1：什么是阻塞](#9-1什么是阻塞)
  - [9-2：阻塞的优化](#9-2阻塞的优化)
- [10.什么是慢查询](#10什么是慢查询)
- [11.应用](#11应用)
  - [11.1：一条SQL语句执行得很慢的原因有哪些](#111一条sql语句执行得很慢的原因有哪些)
  - [11.2：为什么数据库会选错了索引](#112为什么数据库会选错了索引)
- [12.常用sql的语句](#12常用sql的语句)
  - [12-1：SQL语句主要分为哪几类](#12-1sql语句主要分为哪几类)
  - [12-2：超键、候选键、主键、外键分别是什么？](#12-2超键候选键主键外键分别是什么)
  - [12-3：为什么用自增列作为主键](#12-3为什么用自增列作为主键)
  - [12-4：truncate、 delete区别](#12-4truncate-delete区别)
  - [12-5：什么是临时表，临时表什么时候删除?](#12-5什么是临时表临时表什么时候删除)
  - [12-6：非关系型数据库和关系型数据库区别，优势比较?](#12-6非关系型数据库和关系型数据库区别优势比较)
  - [12-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?](#12-7什么是-内连接外连接交叉连接笛卡尔积等)
  - [12-8：varchar与char的区别](#12-8varchar与char的区别)
  - [12-9：count(*)、count(1)、count(column)的区别](#12-9countcount1countcolumn的区别)
  - [12-10：SQL 约束有哪几种？](#12-10sql-约束有哪几种)
  - [12-11：六种关联查询](#12-11六种关联查询)
  - [12-12：什么是子查询](#12-12什么是子查询)
  - [12-13：子查询的三种情况](#12-13子查询的三种情况)
  - [12-14：mysql中 in 和 exists 区别](#12-14mysql中-in-和-exists-区别)
  - [12-15：varchar(50)中50的涵义](#12-15varchar50中50的涵义)
  - [12-16：int(20)中20的涵义](#12-16int20中20的涵义)
  - [12-17：FLOAT和DOUBLE的区别是什么？](#12-17float和double的区别是什么)
  - [12-18：UNION与UNION ALL的区别？](#12-18union与union-all的区别)
  - [12-19：数据库热备份与冷备份](#12-19数据库热备份与冷备份)
- [13.主从复制](#13主从复制)
  - [13-1：什么是主从复制：](#13-1什么是主从复制)
  - [13-2：主从复制的作用（好处，或者说为什么要做主从）：](#13-2主从复制的作用好处或者说为什么要做主从)
  - [13-3：主从复制的原理（重中之重，面试必问）](#13-3主从复制的原理重中之重面试必问)
  - [13-4：主从复制的几种方式](#13-4主从复制的几种方式)
- [14.视图](#14视图)
  - [14-1：为什么要使用视图？什么是视图？那些特点？](#14-1为什么要使用视图什么是视图那些特点)
- [15.存储过程与函数](#15存储过程与函数)
  - [15-1：什么是存储过程？](#15-1什么是存储过程)
  - [15-2：有哪些优缺点？](#15-2有哪些优缺点)
- [16.触发器](#16触发器)
  - [16-1：什么是触发器？](#16-1什么是触发器)
  - [16-2：触发器的使用场景有哪些？](#16-2触发器的使用场景有哪些)
  - [16-3：MySQL中都有哪些触发器？](#16-3mysql中都有哪些触发器)
- [17.JDBC](#17jdbc)
  - [17-1：JDBC数据库连接步骤](#17-1jdbc数据库连接步骤)
  - [17-2：JDBC中的Statement 和PreparedStatement的区别？](#17-2jdbc中的statement-和preparedstatement的区别)
  - [17-3：JDBC中大数据量的分页解决方法?](#17-3jdbc中大数据量的分页解决方法)
  - [17-4：说说数据库连接池工作原理和实现方案？](#17-4说说数据库连接池工作原理和实现方案)
  - [17-5：Java中如何进行事务的处理?](#17-5java中如何进行事务的处理)
  - [17-6：execute，executeQuery，executeUpdate的区别是什么？](#17-6executeexecutequeryexecuteupdate的区别是什么)
  - [17-7：PreparedStatement的缺点是什么，怎么解决这个问题？](#17-7preparedstatement的缺点是什么怎么解决这个问题)
  - [17-8：JDBC的DriverManager是用来做什么的？](#17-8jdbc的drivermanager是用来做什么的)
  - [17-9：JDBC的ResultSet是什么?](#17-9jdbc的resultset是什么)
  - [17-10：有哪些不同的ResultSet？](#17-10有哪些不同的resultset)
  - [17-11：JDBC的DataSource是什么，有什么好处](#17-11jdbc的datasource是什么有什么好处)
  - [17-12：如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？](#17-12如何通过jdbc的datasource和apache-tomcat的jndi来创建连接池)
  - [17-13：常见的JDBC异常有哪些？](#17-13常见的jdbc异常有哪些)
  - [17-14：JDBC中存在哪些不同类型的锁?](#17-14jdbc中存在哪些不同类型的锁)
  - [17-15：java.util.Date和java.sql.Date有什么区别？](#17-15javautildate和javasqldate有什么区别)
  - [17-16：SQLWarning是什么，在程序中如何获取SQLWarning？](#17-16sqlwarning是什么在程序中如何获取sqlwarning)
  - [17-17：如果java.sql.SQLException: No suitable driver found该怎么办？](#17-17如果javasqlsqlexception-no-suitable-driver-found该怎么办)
  - [17-18：JDBC的RowSet是什么，有哪些不同的RowSet？](#17-18jdbc的rowset是什么有哪些不同的rowset)
  - [17-19：什么是JDBC的最佳实践？](#17-19什么是jdbc的最佳实践)

<!-- /TOC -->
# 1.索引

## 1-1：索引是什么

索引（Index）是帮助 MySQL 高效获取数据的数据结构，是一种排好序的数据结构

## 1-2：为什么要用索引（优点）

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会
   更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 1-4：索引的主要原理，常用算法

通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

## 1-5：创建索引原则（使用场景）：

1. 对于查询频率高的字段创建索引；
2. 对排序、分组、联合查询频率高的字段创建索引； 
3. 索引的数目不宜太多

   * 因为每创建一个索引都会占用相应的物理控件，过多的索引会导致insert、update、delete语句的执行效率降低；

4. 若在实际中，需要将多个列设置索引时，可以采用多列索引

5. 选择唯一性索引

   * 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯
     一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

6. 尽量使用数据量少的索引

   * 如果索引的值很长，那么查询的速度会受到影响。

7. 尽量使用前缀来索引

   * 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字
     段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

## 1-6：创建索引的注意事项

1. 限制表上的索引数目。
 
2. 避免在取值朝一个方向增长的字段（例如：日期类型的字段）上，建立索引；对复合索引，避免将这种类型的字段放置在最前面。由于字段的取值总是朝一个方向增长，新记录总是存放在索引的最后一个叶页中，从而不断地引起该叶页的访问竞争、新叶页的分配、中间分支页的拆分。此外，如果所建索引是聚集索引，表中数据按照索引的排列顺序存放，所有的插入操作都集中在最后一个数据页上进行，从而引起插入“热点”。
 
3. 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用。因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。
 
4. 删除不再使用，或者很少被使用的索引。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再被需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。


## 1-7：为什么索引能够提高查询速度

如果我们写select * from user where name = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

定位到记录所在的页：需要遍历双向链表，找到所在的页

从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

使用索引之后，其实就是通过二分查找的思想将无序的数据变成有序(相对)

## 1-8：创建索引的三种方式


## 1-9：最左前缀原则

以最左边的为起点任何连续的索引都能匹配上。

（1）如果第一个字段是范围查询需要单独建一个索引；

（2）在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；

当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！

## 1-10：最左匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

# 2.索引的分类

## 2-1：索引的分类

1. 主键索引
2. 二级索引
   * 唯一索引
   * 普通索引
   * 前缀索引
   * 全文索引

## 2-2：各种索引定义

1. 主键索引：数据表的主键列使用的就是主键索引。

在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。

2. 二级索引(辅助索引)

因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。

3. 唯一索引(Unique Key) ：目的是为了该属性列的数据的唯一性，而不是为了查询效率。

4. 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。

5. 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更
   小， 因为只取前几个字符。

6. 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息

7. 覆盖索引：如果一个索引包含（或者说覆盖）所有需要查询的字段的值

# 3.索引的结构

## 3-1：mysql索引的结构

1. B树索引与B+树索引

2. 聚簇索引与非聚簇索引

3. Hash索引

4. 全文索引

5. 空间索引

## 3-2：B+树比B树的优势

1. B+树空间利用率更高，可减少I/O次数

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘1O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。也就是说: B+树中每
个非叶子节点没有指向某个关健字具体信息的指针，所以好个节点可以存放更多的关键字数量，减少了I/0操作。

2. 增删文件(节点)时，效率更高
因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。

3. B+树的查询效率更加稳定
因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相
当。


## 3-3：B+树与红黑树比较

1. 更少的查找次数

复杂度和树高h相关，红黑树的树高h很明显比B+Tee大非常多，查找的次数也就更多。

2. 利用磁盘预读特性

为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻
道，并且只需要很短的旋转时间，速度会非常快。

## 3-4：B+树与hash索引比较

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值。当然了，这个前提是，键值都是唯
   一的。 如果键值不是唯的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据:

2. 如果是范围查询检索，原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索:


## 3-5：聚簇索引与非聚簇索引概念

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。

非聚集索引即索引结构和数据分开存放的索引。

## 3-6：聚簇索引的优缺点

一、优点

由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

二、缺点
1. 对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
2. 由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。
3. 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。

## 3-7：非聚簇索引的优缺点

一、优点

更新代价比聚集索引要小，非聚集索引的叶子节点是不存放数据的

二、缺点

非聚集索引也依赖于有序的数据
可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 
当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。


# 4.数据库优化

## 4-1：为什么要优化

1. 避免网站页面出现访问错误

   由于慢查询造成页面无法加载
   由于阻塞造成数据无法提交
   增加数据库的稳定性

2. 很多数据库问题都是由于低效的查询引起的

## 4-2：索引优化

书本

## 4-3：查询优化

书本

## 4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决

1. 限定数据的范围
务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

2. 读/写分离
经典的数据库拆分方案，主库负责写，从库负责读；

3. 垂直分区
根据数据库里面数据表的相关性进行拆分。 

4. 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

## 4-5：垂直分表

垂直拆分的优点： 可以使得列数据变小，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让
事务变得更加复杂

## 4-6：水平分表

 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂

一般是水平分库，数据库分片的两种常见方案：

1. 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
2. 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 

## 4-7：为什么要分库分表？

当一张表的数据达到几千万时，查询一次所花的时间会变长。这时候，如果有联合查询的话，可能会卡死在那儿，甚至把系统给拖垮。

而分库分表的目的就在于此：减小数据库的负担，提高数据库的效率，缩短查询时间。另外，因为分库分表这种改造是可控的，底层还是基于RDBMS，因此整个数据库的运维体系以及相关基础设施都是可重用的。

## 4-8：分库分表，id如何处理

方式1——UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示
   比如文件的名字。

方式2——数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独
立部署数据库实例，成本高，还会有性能瓶颈。

方式3——利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编
码更加复杂，增加了系统成本。

## 4-9：为什么 MySQL 不推荐使用 uuid 或者雪花 id 作为主键？

自增的主键的值是顺序的,所以Innodb把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候：

①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费

②新插入的行一定会在原有的最大数据行下一行,mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗

③减少了页分裂和碎片的产生

因为uuid相对顺序的自增id来说是毫无规律可言的,新行的值不一定要比之前的主键的值要大,所以innodb无法做到总是把新行插入到索引的最后,而是需要为新行寻找新的合适的位置从而来分配新的空间。

这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致一些问题：

①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO

②因为写入是乱序的,innodb不得不频繁的做页分裂操作,以便为新的行分配空间,页分裂导致移动大量的数据，一次插入最少需要修改三个页以上

③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片

在把随机值（uuid和雪花id）载入到聚簇索引(innodb默认的索引类型)以后,有时候会需要做一次OPTIMEIZE TABLE来重建表并优化页的填充，这将又需要一定的时间消耗。

## 4-10：使用自增id的缺点

①别人一旦爬取你的数据库,就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况

②对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争

③Auto_Increment锁机制会造成自增锁的抢夺,有一定的性能损失

## 4-11：SQL的生命周期

1. 建立服务器与数据库连接
2. 数据库拿到SQL
3. 解析执行
4. 读取数据到内存，进行业务逻辑处理
5. 发给客户端
6. 关闭连接，释放资源


## 4-12：mysql分页，超大分页怎么处理？

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.

从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.

                     
## 4-13：慢查询优化

1. 索引没起作用的情况

       1. 使用LIKE关键字的查询语句

               在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。

       2. 使用多列索引的查询语句

               MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。

2. 优化数据库结构

              合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

          1. 将字段很多的表分解成多个表 

                对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

          2. 增加中间表

                对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

3. 分解关联查询

         将一个大的查询分解为多个小查询是很有必要的。

         很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，例如：     

4. 优化LIMIT分页

## 4-14：为什么要尽量设定一个主键?

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

## 4-15：主键使用自增ID还是UUID?

推荐使用自增ID,不要使用UUID.

因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.

## 4-16：字段为什么要求定义为not null?

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.

# 5.事务

## 5-1：什么是事务

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

## 5-2：数据库事务特性

1. 原⼦性（Atomicity）：事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要
   么完全不起作⽤；
2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据
   库是独⽴的；
4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故
   障也不应该对其有任何影响。

## 5-3：为什么保证原子性和持久化

首先原子性方面，更新数据前记录Undo log。

为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩
溃，undo log是完整的， 可以用来回滚事务。如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。


## 5-4：四大隔离级别

1. 读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。
2. 读取已提交： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发
               ⽣。
3. 可重复读：   对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏
               读和不可重复读，但幻读仍有可能发⽣。
4. 可串⾏化：   最⾼的隔离级别， 该级别可以防⽌脏读、不可重复读以及幻读。

## 5-5：隔离级别的原理

1. READ_UNCOMMITED 的原理:

  - 事务对当前被读取的数据不加锁；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级共享锁，直到事务结束才释放。

2. READ_COMMITED 的原理:

  - 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

3. REPEATABLE READ 的原理:

  - 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

4. SERIALIZABLE 的原理:

  - 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
  - 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

## 5-6：MySQL 中RC和RR隔离级别的区别

1. RR支持gap lock，而RC则没有gap lock（间隙锁）。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般
   要好于RR；

2. RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以
   从锁方面来看，RC的并发应该要好于RR；

3. RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin log

4. RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，而RR隔离级别时，事务中的一致性读的是以第一条select语句的运行时，作为本事
   务的一致性读的建立时间点的。只能读取该时间点之前已经提交的数据

5. RC隔离级别下的update语句，使用的是半一致性读(semi consistent)；而RR隔离级别的update语句使用的是当前读；当前读会发生锁的阻塞

## 5-7：隔离级别用来做什么

隔离级别用于决定如何控制并发用户读写数据的操作


## 5-8：并发事务带来什么问题

1. 脏读: 
2. 不可重复读: 
3. 幻读: 

书本

## 5-9：数据库崩溃时事务的恢复机制

为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方，这个存储数据备份的地方称为UndoLog。然后进行数据的修改。如果出现了错误或者
用户执行了回滚，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

## 5-10：Undo Log缺陷如何解决？

每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。

因此引入了另外一种机制来实现持久化，即Redo Log。

Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经
持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

# 6.数据库基础知识
## 6-1：为什么要使用数据库


## 6-2: 什么是SQL？


## 6-3：什么是MySQL?


## 6-4：数据库三大范式是什么

第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主
键.

## 6-5：mysql有关权限的表都有哪几个

user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。

## 6-6：MySQL的binlog有有几种录入格式？分别有什么区别？

有三种格式,statement,row和mixed.

statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.

row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.

mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

## 6-7：mysql的数据类型

整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

浮点数类型：FLOAT、DOUBLE、DECIMAL

字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

日期类型：Date、DateTime、TimeStamp、Time、Year


# 7.mysql引擎

## 7-1：MySQL存储引擎MyISAM与InnoDB区别

## 7-2：InnoDB引擎的4大特性

1.插入缓冲（insert buffer)
提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效

只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。

2.二次写(double write)

Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入

在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write
doublewrite组成：
内存中的doublewrite buffer,大小2M。
物理磁盘上共享表空间中连续的128个页，即2个区（extend），大小同样为2M。
对缓冲池的脏页进行刷新时，不是直接写磁盘，而是会通过memcpy()函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite 再分两次，每次1M顺序地写入共享表空间的物理磁盘上，在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer 中的页写入各个 表空间文件中，此时的写入则是离散的。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，innodb可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。



3.自适应哈希索引(ahi)

Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数
关闭

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1),即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般3-4层，故需要3-4次的查询。

innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
AHI有一个要求，就是对这个页的连续访问模式必须是一样的。
例如对于（a,b）访问模式情况：
where a = xxx
where a = xxx and b = xxx

特点
　　1、无序，没有树高
　　2、降低对二级索引树的频繁访问资源，索引树高<=4，访问索引：访问树、根节点、叶子节点
　　3、自适应
3、缺陷
　　1、hash自适应索引会占用innodb buffer pool；
　　2、自适应hash索引只适合搜索等值的查询，如select * from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；
　　3、极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读。

 

4.预读(read ahead)
InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）
为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。

## 7-3：InnoDB存储引擎的锁的算法

Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock： record+gap 锁定⼀个范围，包含记录本身

## 7-4：MyISAM和InnoDB存储引擎使用的锁

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

## 7-5：表级锁和行级锁对比：

表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

## 7-6：Innodb如何加锁

## 7-7：Innodb解决死锁

# 8.锁

## 8-1：隔离级别与锁的关系

SQL使用锁来实现事务的隔离。事务获取锁这种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。

比如说

读未提交，可以通过写操作加“持续-X锁”实现。

读已提交，可以通过写操作加“持续-X”锁，读操作加“临时-S锁”实现。

可重复读，可以通过写操作加“持续-X”锁，读操作加“持续-S锁”实现。

## 8-2：封锁粒度

## 8-3：锁的类型

书本

## 8-4：三级封锁协议

## 8-5：封锁粒度

## 8-6：排它锁

a.当试图修改数据时，事务只能为所依赖的数据资源请求排他锁。

b.一旦某个事务得到了排他锁，则这个事务将一直持有排他锁直到事务完成。

c.排他锁和其他任何类型的锁在多事务中不能在同一阶段作用于同一个资源。

如：当前事务获得了某个资源的排他锁，则其他事务不能获得该资源的任何其他类型的锁。其他事务获得了某个资源的任何其他类型的锁，则当前事务不能获得该资源的排他锁。

## 8-7：排他锁和共享锁的兼容性

（1）如果数据正在由一个事务进行修改，则其他事务既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。

（2）如果数据正在由一个事务读取，则其他事务不能修改该数据（至少默认不能）。

# 9.阻塞

## 9-1：什么是阻塞

当多个事务都需要对某一资源进行锁定时，默认情况下会发生阻塞。被阻塞的请求会一直等待，直到原来的事务释放相关的锁。锁定超时期限可以限制，这样就可以限制被
阻塞的请求在超时之前要等待的时间。

比如说

有两个事务

事务A请求资源S1，事务不对资源S1进行操作

事务A用锁A锁定资源S1，事务B请求对资源S1进行不兼容的锁定（锁B）,锁B的请求被阻塞，事务B将进入等待状态

事务A正在释放锁A，事务B等待锁A释放，

事务A的锁A已释放，事务B用锁B锁定资源S1

## 9-2：阻塞的优化



# 10.什么是慢查询

它用来记录在MySQL中响应时间超过阀值的语句日志记录

# 11.应用

## 11.1：一条SQL语句执行得很慢的原因有哪些

要分两种情形：

1. 大多数情况是正常的，只是偶尔会出现很慢的情况。
   
   * 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
   * 执行的时候，遇到锁，如表锁、行锁。

2. 在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。
   
   * 没有用上索引
   * 数据库选错了索引

## 11.2：为什么数据库会选错了索引

系统在执行的时候，会进行预测，是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？

扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，需要走两次索引，而且，我们也不知道符合 这个条件的数据有多少行，万一真的是n条，那就惨了，所以系统是有可能走全表扫描而不走索引的

系统如何进行预判主要依赖于索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。

这个区分度也叫做基数，系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的

那么出现失误的地方就是采样，比如采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后，系统就不走索引了，直接走全部扫描了。

主要是由于统计的失误，导致系统没有走索引，而是走了全表扫描。


# 12.常用sql的语句

## 12-1：SQL语句主要分为哪几类

DDL-------数据定义语言
DQL-------数据查询语言
DML-------数据操纵语言
DTL-------事务控制语言
DCL-------数据控制语言

## 12-2：超键、候选键、主键、外键分别是什么？

超键：一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）

外键：在一个表中存在的另一个表的主键称此表的外键。

## 12-3：为什么用自增列作为主键

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

## 12-4：truncate、 delete区别

## 12-5：什么是临时表，临时表什么时候删除?

临时表可以手动删除：

临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。

## 12-6：非关系型数据库和关系型数据库区别，优势比较?

非关系型数据库的优势：

 - 性能：NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。

 - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：

 - 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
 
 - 事务支持：使得对于安全性能很高的数据访问要求得以实现。

## 12-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?

1. 内连接: 只连接匹配的行

2. 左外连接: 包含左边表的全部行，以及右边表中全部匹配的行

3. 右外连接: 包含右边表的全部行，以及左边表中全部匹配的行

4. 全外连接: 包含左、右两个表的全部行。

5. 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 12-8：varchar与char的区别

书本

## 12-9：count(*)、count(1)、count(column)的区别

count(*)对行的数目进行计算,包含NULL，count(1)这个用法和count(*)的结果是一样的

count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

## 12-10：SQL 约束有哪几种？

NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
CHECK: 用于控制字段的值范围。

## 12-11：六种关联查询

1. 交叉连接(CROSS JOIN)
2. 内连接(INNER JOIN)
3. 外连接(LEFT JOIN/RIGHT JOIN)
4. 交叉连接
5. 联合查询(UNION 与 UNION ALL)
6. 全连接(FULL JOIN)
   
## 12-12：什么是子查询

在select嵌套select

## 12-13：子查询的三种情况

1. 子查询结果只要是单行单列， 肯定在 WHERE 后面作为条件

2. 子查询结果是多行单列，结果类似于一个数组，父查询使用 in 运算符

3. 子查询结果只要是多列，肯定在 From 后面作为表


## 12-14：mysql中 in 和 exists 区别

1. exists()适合B表比A表数据大的情况

2. 当A表数据与B表数据一样大时,in与exists效率差不多,可任选一个使用

## 12-15：varchar(50)中50的涵义

varchar(50)中50的涵义最多存放50个字符

## 12-16：int(20)中20的涵义

int(M)只是用来显示数据的宽度，比如说int（20），mysql会自动补0

## 12-17：FLOAT和DOUBLE的区别是什么？

1. 在内存中占有的字节数不同

　　　　单精度浮点数在机内存占4个字节

　　　　双精度浮点数在机内存占8个字节

2. 有效数字位数不同

　　　　单精度浮点数有效数字8位

　　　　双精度浮点数有效数字16位

3. 数值取值范围

4. 在程序中处理速度不同

　　　　一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快

## 12-18：UNION与UNION ALL的区别？

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union All：对两个结果集进行并集操作，包括重复行，不进行排序；

## 12-19：数据库热备份与冷备份

书本

# 13.主从复制

## 13-1：什么是主从复制：

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。

## 13-2：主从复制的作用（好处，或者说为什么要做主从）：

1、做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。

2、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

3、读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。

## 13-3：主从复制的原理（重中之重，面试必问）

步骤一：主库db的更新事件(update、insert、delete)被写到binlog

步骤二：从库发起连接，连接到主库

步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库

步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log

具体需要三个线程来操作：

binlog输出线程。每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。

在从库里，当复制开始的时候，从库就会创建两个线程进行处理：

从库I/O线程。当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。

从库的SQL线程。从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。


## 13-4：主从复制的几种方式

1. 同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。不会使用，比如，在WEB前端页面上，用户增加了条记录，需要
   等待很长时间。

2. 异步复制:如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。

3. 半同步复制:master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。

# 14.视图

## 14-1：为什么要使用视图？什么是视图？那些特点？

视图是虚拟的表

1. 重用SQL语句；

2. 简化复杂的SQL操作（可以方便的重用它而不必知道它的基本查询细节）；

3. 使用表的组成部分而不是整个表；

4. 保护数据（可以给用户授予表的部分访问权限而不是整个表的访问权限）；

5. 更改数据格式和表示（视图可返回与底层表的表示和格式不同的数据）。

# 15.存储过程与函数

## 15-1：什么是存储过程？

预先用SQL语句写好并用一个指定的名称存储起来，只需调用execute,即可自动完成命令。

## 15-2：有哪些优缺点？

1. 一般SQL语句每执行一次就编译一次,使用存储过程创建进行编译，可提高数据库执行速度。

2. 当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时），可将此复杂操作用存储过程封装起来。

3. 存储过程可以重复使用,可减少数据库开发人员的工作量

4. 安全性高,可设定只有某此用户才具有对指定存储过程的使用权

# 16.触发器

## 16-1：什么是触发器？

数据库触发器是在数据库中发生特定操作时运行的特殊存储过程

## 16-2：触发器的使用场景有哪些？

1. 复杂的审计

可以使用触发器来跟踪对表所做的更改。

比如说认为这是涉及敏感操作的信息，进行了更改。

2. 执行业务规则

每次添加或修改客户记录时检查客户状态。

## 16-3：MySQL中都有哪些触发器？

不知道

# 17.JDBC

## 17-1：JDBC数据库连接步骤

1.注册数据库驱动
2.建立数据库连接
3.创建一个Statement
4.执行SQL语句
5.处理结果集
6.关闭数据库连接

## 17-2：JDBC中的Statement 和PreparedStatement的区别？

PreparedStatement是预编译的SQL语句，效率高于Statement。
PreparedStatement支持?操作符，相对于Statement更加灵活。
PreparedStatement可以防止SQL注入，安全性高于Statement。
CallableStatement适用于执行存储过程。

## 17-3：JDBC中大数据量的分页解决方法?

最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。

## 17-4：说说数据库连接池工作原理和实现方案？

客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数
决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。
实现方案：连接池使用集合来进行装载，返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代
理的Connection对象放回到连接池中，等待下一次重复利用。

## 17-5：Java中如何进行事务的处理?

Connection类中提供了4个事务处理方法:

setAutoCommit(Boolean autoCommit):设置是否自动提交事务,默认为自动提交,即为true,通过设置false禁止自动提交事务;
commit():提交事务;
rollback():回滚事务.
savepoint:保存点

注意：savepoint不会结束当前事务，普通提交和回滚都会结束当前事务的

## 17-6：execute，executeQuery，executeUpdate的区别是什么？

Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者
update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。

Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用
executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的

java.util.SQLException。

Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，
它就是更新的条数，如果是DDL的话，就返回0。
只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。

## 17-7：PreparedStatement的缺点是什么，怎么解决这个问题？

PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案：

分别进行单条查询——这样做性能很差，不推荐。
使用存储过程——这取决于数据库的实现，不是所有数据库都支持。
动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。
在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。

## 17-8：JDBC的DriverManager是用来做什么的？

JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。
当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面
然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。

## 17-9：JDBC的ResultSet是什么?
在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。
ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。
默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet
当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。
可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。

## 17-10：有哪些不同的ResultSet？

一共有三种ResultSet对象。

ResultSet.TYPE_FORWARD_ONLY：这是默认的类型，它的游标只能往下移。
ResultSet.TYPE_SCROLL_INSENSITIVE：游标可以上下移动，一旦它创建后，数据库里的数据再发生修改，对它来说是透明的。
ResultSet.TYPE_SCROLL_SENSITIVE：游标可以上下移动，如果生成后数据库还发生了修改操作，它是能够感知到的。

ResultSet有两种并发类型。

ResultSet.CONCUR_READ_ONLY:ResultSet是只读的，这是默认类型。
ResultSet.CONCUR_UPDATABLE:我们可以使用ResultSet的更新方法来更新里面的数据。

## 17-11：JDBC的DataSource是什么，有什么好处

跟DriverManager相比，它的功能要更强大。我们可以用它来创建数据库连接，当然驱动的实现类会实际去完成这个工作。除了能创建连接外，它还提供了如下的特性：

缓存PreparedStatement以便更快的执行
可以设置连接超时时间
提供日志记录的功能
ResultSet大小的最大阈值设置
通过JNDI的支持，可以为servlet容器提供连接池的功能

## 17-12：如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？

在META-INF目录下配置context.xml文件【文件内容可以在tomcat默认页面的 JNDI Resources下Configure Tomcat's Resource Factory找到】

导入Mysql或oracle开发包到tomcat的lib目录下

初始化JNDI->获取JNDI容器->检索以XXX为名字在JNDI容器存放的连接池


## 17-13：常见的JDBC异常有哪些？

java.sql.SQLException——这是JDBC异常的基类。
java.sql.BatchUpdateException——当批处理操作执行失败的时候可能会抛出这个异常。这取决于具体的JDBC驱动的实现，它也可能直接抛出基类异常java.sql.SQLException。
java.sql.SQLWarning——SQL操作出现的警告信息。
java.sql.DataTruncation——字段值由于某些非正常原因被截断了（不是因为超过对应字段类型的长度限制）。

## 17-14：JDBC中存在哪些不同类型的锁?

乐观锁——只有当更新数据的时候才会锁定记录。
悲观锁——从查询到更新和提交整个过程都会对数据记录进行加锁。

## 17-15：java.util.Date和java.sql.Date有什么区别？

java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段

## 17-16：SQLWarning是什么，在程序中如何获取SQLWarning？

SQLWarning是SQLException的子类，通过Connection, Statement, Result的getWarnings方法都可以获取到它。 SQLWarning不会中断查询语句的执行，只是用来提示用户存在相关的警告信息。

## 17-17：如果java.sql.SQLException: No suitable driver found该怎么办？

如果你的SQL URL串格式不正确的话，就会抛出这样的异常。不管是使用DriverManager还是JNDI数据源来创建连接都有可能抛出这种异常。它的异常栈看起来会像下面这样。


## 17-18：JDBC的RowSet是什么，有哪些不同的RowSet？

RowSet用于存储查询的数据结果，和ResultSet相比，它更具灵活性。RowSet继承自ResultSet，因此ResultSet能干的，它们也能，而ResultSet做不到的，它们还是可以。RowSet接口定义在javax.sql包里。

RowSet提供的额外的特性有：

提供了Java Bean的功能，可以通过settter和getter方法来设置和获取属性。RowSet使用了JavaBean的事件驱动模型，它可以给注册的组件发送事件通知，比如游标的移动，行的增删改，以及RowSet内容的修改等。
RowSet对象默认是可滚动，可更新的，因此如果数据库系统不支持ResultSet实现类似的功能，可以使用RowSet来实现。
RowSet分为两大类：

A. 连接型RowSet——这类对象与数据库进行连接，和ResultSet很类似。JDBC接口只提供了一种连接型RowSet，javax.sql.rowset.JdbcRowSet，它的标准实现是com.sun.rowset.JdbcRowSetImpl。
B. 离线型RowSet——这类对象不需要和数据库进行连接，因此它们更轻量级，更容易序列化。它们适用于在网络间传递数据。

有四种不同的离线型RowSet的实现。

CachedRowSet——可以通过他们获取连接，执行查询并读取ResultSet的数据到RowSet里。我们可以在离线时对数据进行维护和更新，然后重新连接到数据库里，并回写改动的数据。
WebRowSet继承自CachedRowSet——他可以读写XML文档。
JoinRowSet继承自WebRowSet——它不用连接数据库就可以执行SQL的join操作。
FilteredRowSet继承自WebRowSet——我们可以用它来设置过滤规则，这样只有选中的数据才可见。

## 17-19：什么是JDBC的最佳实践？

数据库资源是非常昂贵的，用完了应该尽快关闭它。Connection, Statement, ResultSet等JDBC对象都有close方法，调用它就好了。
养成在代码中显式关闭掉ResultSet，Statement，Connection的习惯，如果你用的是连接池的话，连接用完后会放回池里，但是没有关闭的ResultSet和Statement就会造成资源泄漏了。
在finally块中关闭资源，保证即便出了异常也能正常关闭。
大量类似的查询应当使用批处理完成。
尽量使用PreparedStatement而不是Statement，以避免SQL注入，同时还能通过预编译和缓存机制提升执行的效率。
如果你要将大量数据读入到ResultSet中，应该合理的设置fetchSize以便提升性能。
你用的数据库可能没有支持所有的隔离级别，用之前先仔细确认下。
数据库隔离级别越高性能越差，确保你的数据库连接设置的隔离级别是最优的。
如果在WEB程序中创建数据库连接，最好通过JNDI使用JDBC的数据源，这样可以对连接进行重用。
如果你需要长时间对ResultSet进行操作的话，尽量使用离线的RowSet。

