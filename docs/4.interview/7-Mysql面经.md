<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-27 13:50:08
 * @FilePath: \docs\4.interview\7-Mysql面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

<!-- TOC -->

- [1.索引](#1索引)
  - [1-1：索引是什么](#1-1索引是什么)
  - [1-2：为什么要用索引（优点）](#1-2为什么要用索引优点)
  - [1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）](#1-3索引这么多优点为什么不对表中的每一个列创建一个索引呢缺点)
  - [1-4：索引的主要原理，常用算法](#1-4索引的主要原理常用算法)
  - [1-5：创建索引原则（使用场景）：](#1-5创建索引原则使用场景)
  - [1-6：创建索引的注意事项](#1-6创建索引的注意事项)
  - [1-7：为什么索引能够提高查询速度](#1-7为什么索引能够提高查询速度)
  - [1-8：创建索引的三种方式](#1-8创建索引的三种方式)
  - [1-9：最左前缀原则](#1-9最左前缀原则)
  - [1-10：最左匹配原则](#1-10最左匹配原则)
- [2.索引的分类](#2索引的分类)
  - [2-1：索引的分类](#2-1索引的分类)
  - [2-2：各种索引定义](#2-2各种索引定义)
- [3.索引的结构](#3索引的结构)
  - [3-1：mysql索引的结构](#3-1mysql索引的结构)
  - [3-2：B+树比B树的优势](#3-2b树比b树的优势)
  - [3-3：B+树与红黑树比较](#3-3b树与红黑树比较)
  - [3-4：B+树与hash索引比较](#3-4b树与hash索引比较)
  - [3-5：聚簇索引与非聚簇索引概念](#3-5聚簇索引与非聚簇索引概念)
  - [3-6：聚簇索引的优缺点](#3-6聚簇索引的优缺点)
  - [3-7：非聚簇索引的优缺点](#3-7非聚簇索引的优缺点)
- [4.数据库优化](#4数据库优化)
  - [4-1：为什么要优化](#4-1为什么要优化)
  - [4-2：索引优化](#4-2索引优化)
  - [4-3：查询优化](#4-3查询优化)
  - [4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决](#4-4当mysql单表记录数过大时数据库的crud性能会明显下降如何解决)
  - [4-5：垂直分表](#4-5垂直分表)
  - [4-6：水平分表](#4-6水平分表)
  - [4-7：分库分表，id如何处理](#4-7分库分表id如何处理)
- [5. 事务](#5-事务)
  - [5-1：什么是事务](#5-1什么是事务)
  - [5-2：数据库事务特性](#5-2数据库事务特性)
  - [5-3：四大隔离级别](#5-3四大隔离级别)
  - [5-4：并发事务带来什么问题](#5-4并发事务带来什么问题)
- [6.数据库基础知识](#6数据库基础知识)
  - [6-1：为什么要使用数据库](#6-1为什么要使用数据库)
  - [6-2: 什么是SQL？](#6-2-什么是sql)
  - [6-3：什么是MySQL?](#6-3什么是mysql)
  - [6-4：数据库三大范式是什么](#6-4数据库三大范式是什么)
  - [6-5：mysql有关权限的表都有哪几个](#6-5mysql有关权限的表都有哪几个)
  - [6-6：MySQL的binlog有有几种录入格式？分别有什么区别？](#6-6mysql的binlog有有几种录入格式分别有什么区别)
  - [6-7：mysql的数据类型](#6-7mysql的数据类型)
- [7.mysql引擎](#7mysql引擎)
  - [7-1：MySQL存储引擎MyISAM与InnoDB区别](#7-1mysql存储引擎myisam与innodb区别)
  - [7-2：InnoDB引擎的4大特性](#7-2innodb引擎的4大特性)
  - [7-3：InnoDB存储引擎的锁的算法：](#7-3innodb存储引擎的锁的算法)
  - [7-4：MyISAM和InnoDB存储引擎使用的锁：](#7-4myisam和innodb存储引擎使用的锁)
  - [7-5：表级锁和行级锁对比：](#7-5表级锁和行级锁对比)
- [8.锁](#8锁)
  - [8-1：隔离级别与锁的关系](#8-1隔离级别与锁的关系)
  - [8-2：封锁粒度](#8-2封锁粒度)
- [9.什么是慢查询](#9什么是慢查询)
- [10.应用](#10应用)
  - [10.1：一条SQL语句执行得很慢的原因有哪些](#101一条sql语句执行得很慢的原因有哪些)
  - [10.2：为什么数据库会选错了索引](#102为什么数据库会选错了索引)

<!-- /TOC -->
# 1.索引

## 1-1：索引是什么

索引（Index）是帮助 MySQL 高效获取数据的数据结构，是一种排好序的数据结构

## 1-2：为什么要用索引（优点）

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 1-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会
   更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 1-4：索引的主要原理，常用算法

通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

## 1-5：创建索引原则（使用场景）：

1. 对于查询频率高的字段创建索引；
2. 对排序、分组、联合查询频率高的字段创建索引； 
3. 索引的数目不宜太多

   * 因为每创建一个索引都会占用相应的物理控件，过多的索引会导致insert、update、delete语句的执行效率降低；

4. 若在实际中，需要将多个列设置索引时，可以采用多列索引

5. 选择唯一性索引

   * 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯
     一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

6. 尽量使用数据量少的索引

   * 如果索引的值很长，那么查询的速度会受到影响。

7. 尽量使用前缀来索引

   * 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字
     段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

## 1-6：创建索引的注意事项

1. 限制表上的索引数目。
 
2. 避免在取值朝一个方向增长的字段（例如：日期类型的字段）上，建立索引；对复合索引，避免将这种类型的字段放置在最前面。由于字段的取值总是朝一个方向增长，新记录总是存放在索引的最后一个叶页中，从而不断地引起该叶页的访问竞争、新叶页的分配、中间分支页的拆分。此外，如果所建索引是聚集索引，表中数据按照索引的排列顺序存放，所有的插入操作都集中在最后一个数据页上进行，从而引起插入“热点”。
 
3. 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用。因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。
 
4. 删除不再使用，或者很少被使用的索引。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再被需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。


## 1-7：为什么索引能够提高查询速度

如果我们写select * from user where name = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

定位到记录所在的页：需要遍历双向链表，找到所在的页

从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

使用索引之后，其实就是通过二分查找的思想将无序的数据变成有序(相对)

## 1-8：创建索引的三种方式


## 1-9：最左前缀原则

以最左边的为起点任何连续的索引都能匹配上。

（1）如果第一个字段是范围查询需要单独建一个索引；

（2）在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；

当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！

## 1-10：最左匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

# 2.索引的分类

## 2-1：索引的分类

1. 主键索引
2. 二级索引
   * 唯一索引
   * 普通索引
   * 前缀索引
   * 全文索引

## 2-2：各种索引定义

1. 主键索引：数据表的主键列使用的就是主键索引。

在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。

2. 二级索引(辅助索引)

因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。

3. 唯一索引(Unique Key) ：目的是为了该属性列的数据的唯一性，而不是为了查询效率。

4. 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。

5. 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更
   小， 因为只取前几个字符。

6. 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息

7. 覆盖索引：如果一个索引包含（或者说覆盖）所有需要查询的字段的值

# 3.索引的结构

## 3-1：mysql索引的结构

1. B树索引与B+树索引

2. 聚簇索引与非聚簇索引

3. Hash索引

4. 全文索引

5. 空间索引

## 3-2：B+树比B树的优势

1. B+树空间利用率更高，可减少I/O次数

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘1O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。也就是说: B+树中每
个非叶子节点没有指向某个关健字具体信息的指针，所以好个节点可以存放更多的关键字数量，减少了I/0操作。

2. 增删文件(节点)时，效率更高
因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。

3. B+树的查询效率更加稳定
因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相
当。


## 3-3：B+树与红黑树比较

1. 更少的查找次数

复杂度和树高h相关，红黑树的树高h很明显比B+Tee大非常多，查找的次数也就更多。

2. 利用磁盘预读特性

为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻
道，并且只需要很短的旋转时间，速度会非常快。

## 3-4：B+树与hash索引比较

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值。当然了，这个前提是，键值都是唯
   一的。 如果键值不是唯的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据:

2. 如果是范围查询检索，原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索:


## 3-5：聚簇索引与非聚簇索引概念

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。

非聚集索引即索引结构和数据分开存放的索引。

## 3-6：聚簇索引的优缺点

一、优点

由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

二、缺点
1. 对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
2. 由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。
3. 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。

## 3-7：非聚簇索引的优缺点

一、优点

更新代价比聚集索引要小，非聚集索引的叶子节点是不存放数据的

二、缺点

非聚集索引也依赖于有序的数据
可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 
当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。


# 4.数据库优化

## 4-1：为什么要优化

1. 避免网站页面出现访问错误

   由于慢查询造成页面无法加载
   由于阻塞造成数据无法提交
   增加数据库的稳定性

2. 很多数据库问题都是由于低效的查询引起的

## 4-2：索引优化

书本

## 4-3：查询优化

书本

## 4-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决

1. 限定数据的范围
务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

2. 读/写分离
经典的数据库拆分方案，主库负责写，从库负责读；

3. 垂直分区
根据数据库里面数据表的相关性进行拆分。 

4. 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

## 4-5：垂直分表

垂直拆分的优点： 可以使得列数据变小，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让
事务变得更加复杂

## 4-6：水平分表

 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂

一般是水平分库，数据库分片的两种常见方案：

1. 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
2. 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 


## 4-7：分库分表，id如何处理

方式1——UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示
   比如文件的名字。

方式2——数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独
立部署数据库实例，成本高，还会有性能瓶颈。

方式3——利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编
码更加复杂，增加了系统成本。

# 5. 事务

## 5-1：什么是事务

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

## 5-2：数据库事务特性

1. 原⼦性（Atomicity）：事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要
   么完全不起作⽤；
2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据
   库是独⽴的；
4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故
   障也不应该对其有任何影响。


3、什么是脏读？幻读？不可重复读？
4、什么是事务的隔离级别？MySQL的默认隔离级别是什么？


## 5-3：四大隔离级别

1. 读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。
2. 读取已提交： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发
               ⽣。
3. 可重复读：   对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏
               读和不可重复读，但幻读仍有可能发⽣。
4. 可串⾏化：   最⾼的隔离级别， 该级别可以防⽌脏读、不可重复读以及幻读。


## 5-4：并发事务带来什么问题

1. 脏读: 
2. 不可重复读: 
3. 幻读: 

书本

# 6.数据库基础知识
## 6-1：为什么要使用数据库


## 6-2: 什么是SQL？


## 6-3：什么是MySQL?


## 6-4：数据库三大范式是什么

1.第一范式（1NF）:列不可再分
1.每一列属性都是不可再分的属性值，确保每一列的原子性

2.两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据


2.第二范式（2NF）属性完全依赖于主键
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键

3.第三范式（3NF）属性不依赖于其它非主属性    属性直接依赖于主键
数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。


## 6-5：mysql有关权限的表都有哪几个

user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。

## 6-6：MySQL的binlog有有几种录入格式？分别有什么区别？

MySQL binlog日志有三种格式，分别为Statement,MiXED和ROW.

1.Statement：每一条会修改数据的sql都会记录在binlog中。

优点:

binlog文件较小

日志是包含用户执行的原始SQL,方便统计和审计

出现最早，兼容较好

缺点：

存在安全隐患，可能导致主从不一致

对一些系统函数不能准确复制或是不能复制

2.ROW不记录sql语句上下文相关信息，仅保存哪条记录被修改。

优点:

相比statement更加安全的复制格式

在某些情况下复制速度更快（SQL复杂，表有主键）

系统的特殊函数也可以复制

更少的锁

在复制时，对于更新和删除语句检查是否有主键，如果有则直接执行，如果没有，看是否有二级索引，如再没有，则全表扫描

缺点：

binlog比较大（myql5.6支持binlog_row_image）

单语句更新（删除）表的行数过多，会形成大量binlog

无法从binlog看见用户执行SQL（5.6中增加binlog_row_query_log_events记录用户的query）

3.Mixed: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。

优点:

混合使用row和statement格式，对于DDL记录statument,对于table里的行操作记录为row格式。

如果使用innodb表，事务级别使用了READ_COMMITTED or READ_UMCOMMITTED日志级别只能使用row格式。

但是使用ROW格式中DDL语句还是会记录成statement格式。

缺点:

mixed模式中，那么在以下几种情况下自动将binlog模式由SBR模式改成RBR模式。

当DML语句更新一个NDB表

当函数中包含UUID时

2个及以上auto_increment字段的表被更新时

行任何insert delayed语句时

用UDF时

视图中必须要求使用RBR时，例如创建视图使用了UUID()函数

## 6-7：mysql的数据类型

整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

浮点数类型：FLOAT、DOUBLE、DECIMAL

字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

日期类型：Date、DateTime、TimeStamp、Time、Year


# 7.mysql引擎

## 7-1：MySQL存储引擎MyISAM与InnoDB区别

## 7-2：InnoDB引擎的4大特性

1.插入缓冲（insert buffer)
提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效

只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。

2.二次写(double write)

Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入

在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write
doublewrite组成：
内存中的doublewrite buffer,大小2M。
物理磁盘上共享表空间中连续的128个页，即2个区（extend），大小同样为2M。
对缓冲池的脏页进行刷新时，不是直接写磁盘，而是会通过memcpy()函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite 再分两次，每次1M顺序地写入共享表空间的物理磁盘上，在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer 中的页写入各个 表空间文件中，此时的写入则是离散的。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，innodb可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。



3.自适应哈希索引(ahi)

Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数
关闭

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1),即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般3-4层，故需要3-4次的查询。

innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
AHI有一个要求，就是对这个页的连续访问模式必须是一样的。
例如对于（a,b）访问模式情况：
where a = xxx
where a = xxx and b = xxx

特点
　　1、无序，没有树高
　　2、降低对二级索引树的频繁访问资源，索引树高<=4，访问索引：访问树、根节点、叶子节点
　　3、自适应
3、缺陷
　　1、hash自适应索引会占用innodb buffer pool；
　　2、自适应hash索引只适合搜索等值的查询，如select * from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；
　　3、极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读。

 

4.预读(read ahead)
InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）
为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。

## 7-3：InnoDB存储引擎的锁的算法：

Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock： record+gap 锁定⼀个范围，包含记录本身

## 7-4：MyISAM和InnoDB存储引擎使用的锁：

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

## 7-5：表级锁和行级锁对比：

表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

# 8.锁

## 8-1：隔离级别与锁的关系

事务的隔离级别就是通过锁的机制来实现

## 8-2：封锁粒度


# 9.什么是慢查询

它用来记录在MySQL中响应时间超过阀值的语句日志记录

# 10.应用

## 10.1：一条SQL语句执行得很慢的原因有哪些

要分两种情形：

1. 大多数情况是正常的，只是偶尔会出现很慢的情况。
   
   * 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。
   * 执行的时候，遇到锁，如表锁、行锁。

2. 在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。
   * 没有用上索引
   * 数据库选错了索引

## 10.2：为什么数据库会选错了索引

系统在执行的时候，会进行预测，是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？

扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，需要走两次索引，而且，我们也不知道符合 这个条件的数据有多少行，万一真的是n条，那就惨了，所以系统是有可能走全表扫描而不走索引的

系统如何进行预判主要依赖于索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。

这个区分度也叫做基数，系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的

那么出现失误的地方就是采样，比如采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后，系统就不走索引了，直接走全部扫描了。

主要是由于统计的失误，导致系统没有走索引，而是走了全表扫描。