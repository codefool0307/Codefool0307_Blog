# 1.Spring---概述

## 1-1:什么是spring

1. Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)容器的轻量级应用平台

2. IoC让相互协作的组件保持松散的耦合，
   而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件

3. 我认为spring最主要的目的就是简化java开发，主要依赖依赖注入和aop
   同时为了简化java开发的复杂程度，spring采取了不同的策略：
      1. 基于POJO的轻量级和最小侵入性编程；
      2. 通过依赖注入和面向接口实现松耦合；
      3. 基于切面和惯例进行声明式编程；
      4. 通过切面和模板减少样板式代码。

## 1-2:Spring的优缺点是什么

`优点：`
   1，方便解耦，简化开发
       Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理
   2，方便程序的测试
      spring对Junit4支持，可以通过注解方便的测试Spring程序
   3，声明式事务的支持
      只需要通过配置就可以完成对事务的管理，而无需手动编程
   4，容器提供了AOP技术，利用它可以很容易实现一些拦截，
      如权限拦截，运行期监控等。
   5，降低JavaEE API的使用难度
     Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使
     这些API应用难度大大降低。
   6，spring对于主流的应用框架提供了很好的支持，
      例如mybatis等。
  
`缺点：`
   使用了大量的反射机制，反射机制非常占用内存。

# 2.spring---模块组成

1. spring core：提供了框架的基本组成部分，
               包括控制反转（IOC）和依赖注入（DI）功能。
2. spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。
3. spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。
4. spring jdbc：提供了一个JDBC的抽象层，用于简化JDBC。
               消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析
5. spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。
6. spring Web：提供了针对 Web 开发的集成特性，例如文件上传，
               利用 servlet listeners 进行 ioc容器初始化
               和针对 Web 的 ApplicationContext。
7. spring test：主要为测试提供支持的，
                支持使用JUnit或TestNG
                对Spring组件进行单元测试和集成测试。

## 2-1:核心容器（spring context应用上下文) 模块

1. 首先是提供spring框架的基础功能，
   BeanFactory是任何以spring为基础的应用的最主要的部分。
   Spring 框架都是基于这个模块创建的，它使Spring成为一个容器。

2. Bean 工厂是工厂模式的一个实现，提供了控制反转功能，
   用来把应用的配置和依赖从真正的应用代码中分离。
   最常用的就是XmlBeanFactory ，它根据XML文件中的定义加载beans。
   该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。

# 3.spring---事件

Spring 提供了以下5种标准的事件：
1. 上下文更新事件（ContextRefreshedEvent）
   在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。
2. 上下文开始事件（ContextStartedEvent）：
   当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。
3. 上下文停止事件（ContextStoppedEvent）：
   当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。
4. 上下文关闭事件（ContextClosedEvent）：
   当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。
5. 请求处理事件（RequestHandledEvent）：
   在Web应用中，当一个http请求（request）结束触发该事件。
   如果一个bean实现了ApplicationListener接口，
   当一个ApplicationEvent 被发布以后，bean会自动被通知。

# 4.spring---组件

1. 接口 - 定义功能。
2. Bean 类 - 它包含属性，setter 和 getter 方法，函数等。
3. Bean 配置文件 - 包含类的信息以及如何配置它们。
4. Spring 面向切面编程（AOP） - 提供面向切面编程的功能。
5. 用户程序 - 它使用接口

# 5.Spring---配置方式

`1、XML 配置文件。`

Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。
这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。
它们通常以 bean 标签开头。

```java
<bean id="studentBean" class="org.edureka.firstSpring.StudentBean">
    <property name="name" value="Edureka"></property>
</bean>
```

`2、注解配置。`

可以通过在相关的类，方法或字段声明上使用注解，
将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。
默认情况下，Spring 容器中未打开注解装配。
因此，需要在使用它之前在 Spring 配置文件中启用它。

```java
<beans>
<context:annotation-config/>
<!-- bean definitions go here -->
</beans>
```

`3、Java Config 配置。`

Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。
@Bean 注解扮演与bean标签元素相同的角色。
@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 Bean 间依赖关系。

```java
@Configuration
public class StudentConfig {
    
    @Bean
    public StudentBean myStudent() {
        return new StudentBean();}}
```

## 5-1:什么是 Spring 配置文件

Spring 配置文件是 XML 文件。该文件主要包含类信息。
它描述了这些类是如何配置以及相互引入的。
但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，
那么在大项目中管理变得非常困难

# 6.Spring---设计模式

1. 工厂模式:通过 BeanFactory 或 ApplicationContext 创建 bean 对象。

2. 单例模式:Bean默认为单例模式。
    xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>
    注解：@Scope(value = "singleton")

3. 代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;

4. 模板模式:
   Spring 中 jdbcTemplate、hibernateTemplate 等
   以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
   一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，
   而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。

5. 观察者模式:
   Spring 事件驱动模型就是观察者模式，
   比如我们每次添加商品的时候都需要重新更新商品索引，
   这个时候就可以利用观察者模式来解决这个问题。

6. 适配器模式
   
   * 在SpringAOP和SpringMVC中都有适配器模式
     虽然Spring AOP 的实现是基于代理模式，
     但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，
     比如说Spring预定义要通过对应的适配器，
     适配成 MethodInterceptor接口(方法拦截器)类型的对象
     如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice
  
  * spring MVC中的适配器模式
    在Spring MVC中，DispatcherServlet根据请求信息
    调用HandlerMapping，
    解析请求对应的Handler。
    解析到对应的 Handler,也就是我们平常说的 Controller 控制器后，
    开始由HandlerAdapter 适配器处理。
    HandlerAdapter 作为期望接口，
    具体的适配器实现类用于对目标类进行适配，
    Controller 作为需要适配的类。
    因为Spring MVC 中的 Controller 种类众多，
    不同类型的 Controller 通过不同的方法来对请求进行处理。
    如果不利用适配器模式的话，
    DispatcherServlet 直接获取对应类型的 Controller，
    需要的自行来判断

7. 装饰者模式
   当我们需要修改原有的功能，
   但我们又不愿直接去修改原有的代码时，
   设计一个Decorator套在原有代码外面
   Spring 中配置 DataSource 的时候，
   DataSource 可能是不同的数据库和数据源。
   我们能否根据客户的需求在少
   修改原有类的代码下动态切换不同的数据源
   这个时候就要用到装饰者模式。
   Spring 中用到的包装器模式
   在类名上含有 Wrapper或者 Decorator。
   这些类基本上都是动态地给一个对象添加一些额外的职责

# 7.spring---循环依赖

就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，
然后去创建 B 对象的时候，又发现 B 对象依赖 C，
然后去创建 C 对象的时候，又发现 C 对象依赖 A。

## 7-1：什么是三级缓存

1. 第一级缓存：单例缓存池 singletonObjects。
2. 第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。
3. 第三级缓存：singletonFactories 单例对象工厂缓存

先从一级缓存singletonObjects中去获取，
如果获取到 Bean 就直接返回。
如果获取不到或者对象正在创建中，
那就再从二级缓存earlySingletonObjects中获取，
如果获取到就直接返回。
如果前两级缓存都没成功返回，
且允许 singletonFactories(allowEarlyReference=true)
通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。
如果获取到了就从singletonFactories中移除，
并且放进earlySingletonObjects。
其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。

## 7-2：什么是早期暴露的对象

你是一个不完整的对象，你的属性还没有值，
你的对象也没有被初始化。这就是早期暴露的对象，
只是提前拿出来给你认识认识。但他非常重要。
这是多级缓存解决循环依赖问题的一个巧妙的地方。

## 7-3：如何解决循环依赖

主要是用三级缓存来解决循环依赖问题

比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决

1. 使用context.getBean(A.class)，
   旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，
   显然初次获取A是不存在的，因此走A的创建之路~
2. 实例化A（注意此处仅仅是实例化），
   并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
3. 初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
4. 为了完成依赖注入B，会通过getBean(B)去容器内找B。
   但此时B在容器内不存在，就走向B的创建之路~
5. 实例化B，并将其放入缓存。（此时B也能够被引用了）
6. 初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
7. 此处重要：初始化B时会调用getBean(A)去容器内找到A，
   因为A已经实例化完成了并且放进了缓存里，
   所以这个时候去看缓存里是已经存在A的引用了的，
   所以getBean(A)能够正常返回
8. B初始化成功（此时已经注入A成功了，已成功持有A的引用了），
   return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中
9. 因为B实例已经成功返回了，因此最终A也初始化成功
10. 到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，

# 8.spring----读取配置或者注解过程

先通过扫描指定包路径下的spring注解，
比如@Component、@Service、@Lazy @Sope
等spring识别的注解或者是xml配置的属性(通过读取流,解析成Document，Document)
然后spring会解析这些属性，将这些属性封装到BeanDefintaion这个接口的实现类中.

# 9.IOC------概念

因为在没有使用spring之前， 我们一般都是通过程序代码直接操控对象的调用，
现在，又了spring的ioc之后，我们可以把操控对象的调用权交给了容器，通过
容器来实现对象组件的装配和管理。
ioc主要是对组件对象的控制权，从程序代码转移到了外部容器。

## 9-1:IOC的好处

1. 因为对象的创建对于内存不是一个简单的事情，在对象关系比较复杂的时候，
   如果依赖关系需要程序猿来维护的话，那是相当头疼的
   现在有了ioc，解耦，由容器去维护具体的对象
2. 比如我们需要在类的产生过程中做一些处理，
   如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的

## 9-2:Spring的 IOC 容器比New对象究竟好在哪

比如说甲乙双方卖袜子，
甲乙可以在对方不真实存在的情况下独立存在，
而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。
甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。
因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。
那么交易就能很可靠很灵活的产生和进行了。

这样我就可以把我的资源集中管理，并且降低了资源双方的依赖程度

## 9-3:除了spring还有那些框架使用了IOC

Google 支持的 Guice 和 Dagger2

## 9-4:IOC功能

1. 依赖注入
2. 依赖检查
3. 自动装配
4. 支持集合
5. 指定初始化方法和销毁方法
6. 支持回调某些方法（但是需要实现 Spring 接口，略有侵入）

# 10.IOC----耦合

耦合指的就是两个类之间的联系的紧密程度

## 10-1:如何实现低（松）耦合

1、使用类的向上转型或接口回调的方式进行解耦
  利用多态的思想

2、利用适配器模式进行解耦
   所谓的强耦合不就是类之间存在着直接关系，
   从而使得他们俩联系特别紧密，那我在他们之间加一层，
   使直接关系变成间接关系

## 10-2：举例如何实现松耦合

第一种，利用多态

```java
1.创建基类
public class Base{
       public void say(){
            System.out.println("I am Base");
        }
    }
2. 创建a类
public class A extends Base{

        @Override
        public void say() {
            System.out.println("I am A");
        }
    }
3. 创建b类
public class B extends Base{

        @Override
        public void say() {
            System.out.println("I am B");
        }
    }

4. 创建c类
public class C{
        public void put(Base base){
            base.say();
        }
    }
```

第二种，采用适配器模式

```java
public class A{
        public void aSay() {System.out.println("I am A");}}
        
   public class Base{
        public A a;
        public Base(A a){this.a=a;}
        public void baseSay(){a.aSay();}}

    public class B{
        public void put(Base base){base.baseSay();}}

    public static void main(String[] args){
        A a=new A();
        Base base=new Base(a);
        B b=new B();
        b.put(base);
    }
```

# 11.IOC------原理

就是将对象的创建和管理交由spring管理。
ioc容器本质上是一个map，存放着各种bean对象，
key是bean对象名，value是bean配置信息。
bean对象的创建、依赖关系都交由ioc容器完成，
使用时不需要关心bean对象什么时候创建
也不需要手动维护对象间的关系。
ioc容器相当于一个第三方的容器，
关联着使用资源的双方。
比如一个user类和userinfo类，
user类要使用userinfo类的属性，
需要调用时创建user类和userinfo类的的对象，
然后进行属性注入。
但是如果将user和userinfo都交由ioc容器管理，
调用时只需要从ioc容器中取出user对象，
那么user对象需要的userinfo属性会在ioc容器中进行注入，
取出的user对象是已经完成依赖注入的对象。

# 12.IOC-----实现方式

1. 依赖注入
2. 以来查找

# 13.IOC-----实现机制

Spring 中的 IoC 的实现原理，就是工厂模式加反射机制

a. 加载配置文件，解析成 BeanDefinition 放在 Map 里。
b. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，
   拿出 Class 对象进行实例化，同时，如果有依赖关系，
   将递归调用 getBean 方法 —— 完成依赖注入。

## 13-1：自己设计SpringIOC，如何设计--修改

1. 第一步、实现低级容器
   IoC 在 Spring 里，只需要低级容器也就是BeanFactory就可以实现，
   BeanFactory 简单粗暴，可以理解为就是个 HashMap，
   Key 是 BeanName，Value 是 Bean 实例。
   通常只提供注册（put），获取（get）这两个功能。

   主要包含：
   1. 加载配置文件，解析成 BeanDefinition 放在 Map 里。
   2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，
      拿出 Class 对象进行实例化，同时，如果有依赖关系，
      将递归调用 getBean 方法 —— 完成依赖注入。

2. 第二步、实现高级容器

   因为ApplicationContext比 BeanFactory 多了更多的功能。
   他继承了多个接口。因此具备了更多的功能。
   例如资源的获取，支持多种消息（例如 JSP tag 的支持），
   对BeanFactory多了工具级别的支持。
   该接口定义了一个refresh方法，用于刷新整个容器，即重新加载/刷新所有的 bean。

# 14.IOC-----种类

一共是两种，分别是 BeanFactory、ApplicationContext

BeanFactory ，就像一个包含 Bean 集合的工厂类。
它会在客户端要求时实例化 Bean 对象
ApplicationContext 接口扩展了 BeanFactory 接口，
它在 BeanFactory 基础上提供了一些额外的功能
ApplicationContext 会自动初始化非懒加载的 Bean 对象

## 14-1:BeanFactory

是Spring里面最底层的接口，包含了各种Bean的定义，
读取bean配置文档，管理bean的加载、实例化，
控制bean的生命周期，维护bean之间的依赖关系。

### 14-1-1:常用的BeanFactory容器

最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean

## 14-2:ApplicationContext

ApplicationContext接口作为BeanFactory的派生，
除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：
   1. 可以支持国际化，主要通过继承MessageSource来实现的。
   2. 统一的资源文件访问方式。
   3. 提供在监听器中注册bean的事件。
   4. 同时加载多个配置文件。
   5. 载入多个（有继承关系）上下文 ，
      使得每一个上下文都专注于一个特定的层次，比如应用的web层。

### 14-2-1：常用的ApplicationContext容器

1、ClassPathXmlApplicationContext ：
  从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。
  应用程序上下文从程序环境变量中取得。

2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。

3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。

## 14-3：几个类的区别

### 14-3-1：BeanFactory与ApplicationContext区别

ApplicationContext和BeanFactory是Spring的两大核心接口。
都可以当做Spring的容器
其中ApplicationContext是 BeanFactory的子接口。
1. 依赖关系
   BeanFactory:是Spring里面最底层的接口，维护 bean之间的依赖关系。
   ApplicationContext 接口作为 BeanFactory的派生，除了提供BeanFactory所具有的功能外，
   还提供了更完整的框架功能

2. 加载方式
   BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时
   (调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring
   的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用
   getBean方法才会抛出异常。
   ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动
   时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注
   入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当
   你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的 BeanFactory，
   ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，
   程序启动较慢。

3. 创建方式
   BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，

4. 注册方式
   BeanFactory和 ApplicationContext 都支持 BeanPostProcessor、
   BeanFactoryPostProcessor的使用，但两者之间的区别是: BeanFactory需要手动注册，
   而ApplicationContext则是自动注册。

### 14-3-2：BeanFactory和FactoryBean的区别（51期）

BeanFactory是个Factory，也就是IOC容器或对象工厂，
FactoryBean是个Bean。在Spring中，
所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。
但对FactoryBean而言，这个Bean不是简单的Bean，
而是一个能生产或者修饰对象生成的工厂Bean,
它的实现与设计模式中的工厂模式和修饰器模式类似

# 15.IOC-----依赖注入

依赖注入是ioc的常见实现方式
比如说，由于某客户类只依赖于服务类的一个接口，
而不依赖于具体服务类，所以客户类只定义一个注入点。
在程序运行过程中，客户类不直接实例化具体服务类实例，
而是客户类的运行上下文环境或专门组件负责实例化服务类，
然后将其注入到客户类中，保证客户类的正常运行

所以依赖注入，组件之间的依赖关系由容器在应用系统运行期来决定，
也组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。

## 15-1:依赖注入的原则

因为依赖注入的目的就是松耦合，

所以我认为主要原则就是：

1. 保持简单的构造函数
   除了检查null、创建可创建类和存储依赖项供以后使用之外，它们不应该做任何事情

2. 不要假设接口是抽象的
   并非每个接口都是抽象的，由于从类中提取的接口可以很容易地单独与该类紧密耦合，使得接口作为抽象类毫无用处

3. 针对抽象类而非实现类的代码
   抽象类是灵活的——通常是接口但也不一定总是接口，
   接口(或抽象类)可以通过多种方式实现。 可以在实现完成前对接口进行编码。 
   如果对实现进行编码，将创建一个紧密耦合且不灵活的系统。 
   不要把自己限定在单一的实现中。 而使用抽象，编出可扩展、可重用及灵活的代码。

4. 根据接口生成的契约进行编码

## 15-2:依赖注入的原理

在于依赖注入容器IContainer，在这个容器下主要实现了：

1. 通过容器来保存可用服务的集合
    要用的特定对象、特定类、接口服务

2. 提供一种方式将各种部件与他们依赖的服务绑定到一起的注册服务；
    Add...函数或containerBuilder.Register函数

3. 为应用程序提供一种方式来请求已配置的对象：构造函数注入、属性注入.
    运行时，框架会一层层通过反射构造实例，最终得到完整对象。


## 15-3:依赖注入的优势

1. 查找定位操作与应用代码完全无关。
2. 不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。
3. 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。

## 15-4：spring的注入方式

1. 构造器注入
  依赖于构造方法的实现，在没有spring之前，大多数情况下，我们都是通过构造方法来创建类对象，
  Spring可以采用反射的方式，通过构造方法来完成注入

2. setter注入
   setter注入是通过setter方法注入
   首先将构造方法设置为无参的构造方法，然后利用setter注入为其设置新的值，也是通过java的反射技术得以实现的

3. 接口注入
   定义接口

### 11-4-1：三种方式的区别小结

1. 基于构造器的注入，会固定依赖注入的顺序；
   该方式不允许我们创建bean对象之间的循环依赖关系，
   这种限制其实是一种利用构造器来注入的益处
   没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；
2. 基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，
   而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，
   CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。
3. 使用直接在成员变量上写上注解来注入这种方式
   看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；

## 15-5：IOC与DI的的区别

1. 控制反转是一种思想；依赖注入是一种设计模式。
2. 依赖注入是实现控制反转的一种方式，
   但是控制反转还有其他实现方式，例如说ServiceLocator（服务定位器、依赖查找），
   所以不能将控制反转和依赖注入等同。

# 16.AOP------概念

由于在oop中产生了大量的代码重复，不太有利于各个模块的服用，
aop作为oop的一种补充，用于将那些与业务无关，
但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，
同时减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。
可用于权限认证、日志、事务处理等。

## 16-1：什么是 Aspect

@Aspect 注解的类就是切面
Aspect 由 PointCut 和 Advice 组成。
   它既包含了横切逻辑的定义，也包括了连接点的定义。
   Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。

## 16-2：什么是 JoinPoint

JoinPoint ，切点，程序运行中的一些时间点, 例如：
一个方法的执行。
或者是一个异常的处理。
在 Spring AOP 中，JoinPoint 总是方法的执行点。

## 16-3：什么是 PointCut

PointCut 是匹配 JoinPoint 的条件。

Advice 是和特定的 PointCut 关联的，
并且在 PointCut 相匹配的 JoinPoint 中执行。
在 Spring 中, 所有的方法都可以认为是 JoinPoint ，
但是我们并不希望在所有的方法上都添加 Advice 。
而 PointCut 的作用，就是提供一组规则 来匹配 JoinPoint ，
给满足规则的 JoinPoint 添加 Advice 。

## 16-4：JoinPoint 和 PointCut 的区别

1. 在 Spring AOP 中，所有的方法执行都是 JoinPoint 。
   而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，
   通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。
2. Advice 是在 JoinPoint 上执行的，
   而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。

首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。
然后，Advice 在查询到 JoinPoint 上执行逻辑。

## 16-5：什么是 Advice ？

通知。
比如说特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。
Spring AOP 使用一个 Advice 作为拦截器，
在 JoinPoint “周围”维护一系列的拦截器。

### 16-5-1：有哪些类型的 Advice？

前置通知 (@Before) 。
返回通知 (@AfterReturning) 。
异常通知 (@AfterThrowing) 。
后置通知 (@After)。
环绕通知 (@Around) :（优先级最高）

1. Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，
            并使用 @Before 注解标记进行配置。
2. After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，
                     并使用 @AfterReturning 注解标记进行配置。
3. After Throwing - 这些类型的 Advice 仅在 JoinPoint 
                    方法通过抛出异常退出并使用 
                    @AfterThrowing 注解标记配置时执行。
4. After Finally - 这些类型的 Advice 在连接点方法之后执行，
                   无论方法退出是正常还是异常返回，
                   并使用 @After 注解标记进行配置。
5. Around - 这些类型的 Advice 在连接点之前和之后执行，
            并使用 @Around 注解标记进行配置。

### 16-5-2:advice的执行顺序

②有异常情况下的执行顺序：
around before advice
before advice
target method 执行
around after advice
after advice
afterThrowing:异常发生
java.lang.RuntimeException: 异常发生

①没有异常情况下的执行顺序：
around before advice
before advice
target method 执行
around after advice
after advice
afterReturning

## 16-6：什么是Target

Target ，织入Advice的目标对象。目标对象也被称为Advised Object 。

因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，
因此 Advised Object 总是一个代理对象(Proxied Object) 。
注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象。
Advice + Target Object = Advised Object = Proxy 。

## 16-7：什么是编织（Weaving）

为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，叫做编织。
在 Spring AOP 中，编织在运行时执行，即动态代理

## 16-8：AOP中的切面、切点、连接点、通知，四者的关系

切面，一定要给spring 管理
切点，目的是为了将注解写在上面而已
pointcut是连接点的集合
通知---》配置切点

## 16-9:Spring AOP and AspectJ AOP 有什么区别

AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；
动态代理则以Spring AOP为代表。

（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也
称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的
AOP对象。

（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行
时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切
点做了增强处理，并回调原对象的方法。

# 17.AOP-----底层实现

AOP技术底层采用的是代理技术

1. 基于JDK的动态代理
   必须是面向接口的，只有实现了具体接口的类才能生成代理对象
2. 基于CGLIB动态代理
   对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式

同时Spring的传统AOP中根据类是否实现接口，来采用不同的代理方式
1. 如果实现类接口，使用JDK动态代理完成AOP
2. 如果没有实现接口，采用CGLIB动态代理完成AOP

## 17-1：aop有哪些实现方式

实现 AOP 的技术，主要分为两大类：

1. 静态代理 - 指使用 AOP 框架提供的命令进行编译，
             从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。
例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，
     实现类加载时编织时增强，从而实现链路追踪的透明埋点。
2. 动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，
            因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：
            JDK 动态代理
            CGLIB

## 17-2：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢

1. JDK 动态代理
   JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。
   JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。
2. CGLIB 动态代理
   如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。
   当然，Spring 也支持配置，强制使用CGLIB动态代理。
   CGLIB（Code Generation Library），是一个代码生成的类库，
   可以在运行时动态的生成某个类的子类，CGLIB 是通过继承的方式做的动态代理，
   因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。

### 17-2-1：spring AOP 默认使用jdk动态代理还是cglib

要看条件，如果实现了接口的类，是使用jdk。
如果没实现接口，就使用cglib。

## 17-3：动态代理步骤

### 17-3-1：JDK动态代理的步骤

1. 先检查委托类是否实现了相应接口，保证被访问方法在接口中也要有定义
2. 创建一个实现InvocationHandler接口的类
3. 在类中定义一个被代理对象的成员属性，为了扩展方便可以直接使用Object类，
   也可以根据需求定义相应的接口
4. 在invoke方法中实现对委托对象的调用，根据需求对方法进行增强
5. 使用Proxy.newProxyInstance(...)方法创建代理对象，并提供要给获取代理对象的方法

#### 17-3-1-1：JDK的动态代理为什么需要接口

1. 在需要继承proxy类获得有关方法和InvocationHandler构造方法传参的同时,
   java不能同时继承两个类，我们需要和想要代理的类建立联系，只能实现一个接口
2. 需要反射获得代理类的有关参数，必须要通过某个类，
   反射获取有关方法，
3. 成功返回的是object类型，要获取原类，
   只能继承/实现，或者就是那个代理类
4. 对具体实现的方法内部并不关心，
   这个交给InvocationHandler.invoke那个方法里去处理就好了，
   我只想根据你给我的接口反射出对我有用的东西。
5. 考虑到设计模式，以及proxy编者编写代码的逻辑

### 17-3-2：cglib动态代理实现步骤

1. 创建一个实现MethodInterceptor接口的类
2. 在类中定义一个被代理对象的成员属性，
   为了扩展方便可以直接使用Object类，也可以根据需求定义相应的接口
3. 在invoke方法中实现对委托对象的调用，根据需求对方法进行增强
4. 使用Enhancer创建生成代理对象，并提供要给获取代理对象的方法

### 17-3-3：jdk动态代理 VS cglib

1. JDK Proxy 的优势：
    * 最小化依赖关系，减少依赖意味着简化开发和维护，
      JDK 本身的支持，可能比 cglib 更加可靠。
    * 平滑进行 JDK 版本升级，
      而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
    * 代码实现简单。
2. cglib 优势：
    * 有的时候调用目标可能不便实现额外接口，
      从某种角度看，限定调用者实现接口是有些侵入性的实践，
      类似cglib 动态代理就没有这种限制。
    * 只操作我们关心的类，而不必为其他相关类增加工作量。

### 17-3-4：jdk动态代理性能远比cglib要差，如果是，依据是什么？

JDK有一个限制，就是它只能为接口创建代理实例，
而对于没有通过接口定义业务方法的类,需要通过CGLib创建动态代理实例  

## 17-4：Spring AOP and AspectJ AOP 有什么区别

1. 代理方式不同
      Spring AOP 基于动态代理方式实现。
      AspectJ AOP 基于静态代理方式实现。
2. PointCut 支持力度不同
      Spring AOP 仅支持方法级别的 PointCut 。
      AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。

# 18.AOP-----如何使用切面

在 Spring AOP 中，有两种方式配置 AOP 切面：

基于 XML 方式的切面实现。
基于 注解 方式的切面实现。
目前，主流喜欢使用 注解 方式。

# 19.过滤器与拦截器

## 19-1：过滤器

## 19-2：拦截器

## 19-3：拦截器（Interceptor）和过滤器（Filter）的区别

           Filter	                                                   Interceptor	                          
Filter 接口定义在 javax.servlet 包中	                           接口 HandlerInterceptor
                                                         定义在org.springframework.web.servlet 包中	 
Filter 定义在 web.xml 中	 	 
Filter在只在 Servlet 前后起作用。                         拦截器能够深入到方法前后、异常抛出前后等，
Filters 通常将 请求和响应（request/response）        因此拦截器的使用具有更大的弹性。允许用户介入（hook into）请求的生命周期，
当做黑盒子，Filter 通常不考虑servlet 的实现。           在请求过程中获取信息，Interceptor 通常和请求更加耦合。
 
Filter 是 Servlet 规范规定的。	                     拦截器既可以用于Web程序，也可以用于Application、Swing程序中。	使用范围不同

Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。	而拦截器是在 Spring容器内的，是Spring框架支持的。	规范不同

Filter 不能够使用 Spring 容器资源	                     拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，
                                                       因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，
                                                       通过IoC注入到拦截器即可	Spring 中使用 interceptor 更容易

Filter 是被 Server(like Tomcat) 调用	                           Interceptor 是被 Spring 调用

## 19-4：拦截器（Interceptor）和过滤器（Filter）的执行顺序

过滤前-拦截前-Action处理-拦截后-过滤后


## 19-5:所用的设计模式

责任链设计模式



# 20.AOP-----应用场景

1、日志记录
2、权限验证
3、效率检查
4、事务管理

# 21.Bean-----概念

Spring beans是那些形成Spring应用的java对象。
它们被Spring IOC容器初始化，装配，和管理。
这些beans通过容器中配置的元数据创建。
比如，以XML文件中 的形式定义

## 21-1:bean的定义包含了什么

1. 所有配置元数据，包括如何创建一个bean，
2. 它的生命周期详情及它的依赖

### 21-1-1:如何给bean提供元数据

有三种方式：
   1. XML配置文件。
   2. 基于注解的配置。
   3. 基于java的配置。

同第5部分

# 22.Bean----作用域

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
global-session： 全局session作用域，
                 仅仅在基于portlet的web应用中才有意义，

## 22-1:如何定义类的作用域

1. 可以通过bean 定义中的scope属性来定义。
   如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。

2. 一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。


# 23.bean-----线程安全

## 23-1：Spring中的单例bean的线程安全问题了解吗？

单例 bean 存在线程问题，
主要是因为当多个线程操作同一个对象的时候，
对这个对象的非静态成员变量的写操作会存在线程安全问题。

### 23-2：常见的有两种解决办法

1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2. 在类中定义一个ThreadLocal成员变量，
   将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

# 24.bean-----线程并发

在一般情况下，只有无状态的Bean才可以在多线程环境下共享，
在Spring中，绝大部分Bean都可以声明为singleton作用域，
因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，
解决线程安全问题。

ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。
同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，
没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。

ThreadLocal会为每一个线程提供一个独立的变量副本，
从而隔离了多个线程对数据的访问冲突。
因为每一个线程都拥有自己的变量副本，
从而也就没有必要对该变量进行同步了。
ThreadLocal提供了线程安全的共享对象，
在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。


# 19.Bean-----生命周期

1. 实例化 Instantiation
   AbstractAutowireCapableBeanFactory.doCreateBean
   中会调用createBeanInstance()方法,
   该阶段主要是从beanDefinitionMap循环读取bean,
   获取它的属性，然后利用反射读取对象的构造方法
   spring会自动判断是否是有参数还是无参数，
   以及构造方法中的参数是否可用,
   然后再去创建实例（newInstance）

2. 初始化
   初始化主要包括两个步骤,
   一个是属性填充，另一个就是具体的初始化过程

   首先是属性赋值
     PopulateBean()会对bean的依赖属性进行填充，
     @AutoWired注解注入的属性就发生这个阶段，
     假如我们的bean有很多依赖的对象，
     那么spring会依次调用这些依赖的对象进行实例化，

   其次是初始化 Initialization
     初始化的过程包括将初始化好的bean放入到spring的缓存中、
     填充我们预设的属性进一步做后置处理等

3. 使用和销毁 Destruction
    在Spring将所有的bean都初始化好之后，我们的业务系统就可以调用了。
    而销毁主要的操作是销毁bean，主要是伴随着spring容器的关闭，
    此时会将spring的bean移除容器之中。此后spring的生命周期到这一步彻底结束，
    不再接受spring的管理和约束。

## -1:实例化和初始化的区别

实例化是在jvm的堆中创建了这个对象实例，
此时它只是一个空的对象，所有的属性为null。

初始化的过程就是讲对象依赖的一些属性进行赋值之后，
调用某些方法来开启一些默认加载。比如spring中配置的数据库属性Bean，
在初始化的时候就会将这些属性填充，比如driver、jdbcurl等,然后初始化连接

## -2:自定义扩展bean的初始化过程

主要是通过通过BeanPostProcessor来实现的,

首先是实例化阶段，在这个阶段会调用对象的空构造方法进行对象的实例化，
在进行实例化之后，
会调用InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法

这个阶段允许在Bean进行实例化之前，允许开发者自定义逻辑，
如返回一个代理对象。假如在这个阶段返回了一个不为null的实例，spring就会中断后续的过程。

Bean实例化完毕后执行的后处理操作，所有在初始化逻辑、装配逻辑之前执行

## -1:重要的生命周期方法

第一个是setup，它是在容器加载bean的时候被调用。
第二个方法是teardown，它是在容器卸载类的时候被调用。

# 20.Bean-----注入方式

1. set方法注入
2. 构造器注入
3. 静态工厂注入
4. 实例工厂注入
 
1. `set注入`
   如果我们需要使用set注入，那么必须要为属性提供set方法，
   Spring容器就是通过调用bean的set方法为属性注入值的。
   而在xml文件中，使用set注入的方式就是通过property标签，
2. `构造器注入`
   就是通过调用bean所属类的带参构造器为bean的属性注入值。
   我们如果需要使用构造器注入，就得为类提供包含参数的构造方法。
   构造器注入，实际上有多种匹配属性值的方式，比如说
（一）匹配构造器的参数名称
  我们需要通过constructor-arg标签为构造器传入参数值，
  每个constructor-arg标签对应直接匹配参数名
（二）匹配构造器的参数下标
  通过参数在参数列表中的下标进行匹配的方式。
  通过参数的下标为构造器的参数赋值，
  参实的下标从0开始。使用第一种方式配置，若赋值的类型与参数的类型不一致，
  将会在容器初始化bean的时候抛出异常。
  如果bean存在多个参数数量一样的构造器，
  Spring容器会自动找到类型匹配的那个进行调用。
  比如说，Car有如下两个构造器，Spring容器将会调用第二个，
  因为上面的配置中，index = 1对应的value是double类型，
  与第二个构造器匹配，而第一个不匹配：
（三）匹配构造器的参数类型
  直接通过匹配构造器的参数类型，
从而选择一个能够完全匹配的构造器，调用这个构造器完成bean的创建和属性注入。
类型并不需要按构造器中声明的顺序编写，Spring也能进行匹配。
3. `静态工厂注入`
  静态工厂注入就是我们编写一个静态的工厂方法，
这个工厂方法会返回一个我们需要的值，然后在配置文件中，
我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，
4. `实例工厂`
   与静态工厂类似，不同的是，
   静态工厂调用工厂方法不需要先创建工厂类的对象，
   因为静态方法可以直接通过类调用，
   所以在上面的配置文件中，并没有声明工厂类的bean。
   但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。

## -1:spring中如何注入一个java集合

类型用于注入一列值，允许有相同的值。
类型用于注入一组值，不允许有相同的值。
类型用于注入一组键值对，键和值都可以为任意类型。
类型用于注入一组键值对，键和值都只能为String类型。

# 21.bean-----接口

## 21-1：没有注入接口，使用时怎么能获取的接口

@Autowired是Spring的注解，Autowired默认先按byType，
如果发现找到多个bean，则，又按照byName方式比对，
如果还有多个，则报出异常；@Resource
默认按照名称(Byname)进行装配, 如果没有指定name属性，
当注解写在字段上时，默认取字段名，按照名称查找，
如果注解写在setter方法上默认取属性名进行装配。
当找不到与名称匹配的bean时才按照类型进行装配。
如果name属性一旦指定，就只会按照名称进行装配。
对于Controller获取实例的过程，使用@Autowired，
程序在spring的容器中查找类型是TestService的bean，
刚好找到有且只有一个此类型的bean，即testServiceImpl，
所以就把testServiceImpl自动装配到了controller
的实例testService中，testService其实就是TestServiceImpl实现类；
如果使用的是@Resource，
则是先在容器中查找名字为testService的bean，
但并没有找到，因为容器中的bean名字是TestServiceImpl
如果@Service没指定bean的value属性，
则注入bean的名字就是类名，如果指定了则是指定的名字，
然后再通过类型查找TestService类型的bean，
找到唯一的了个TestService类型bean（即TestServiceImpl），
所以就自动装配实例成功了。

## 21-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？

1、 通过指定bean的名字来明确到底要实例哪一个类
2、 通过在实现类上添加@Primary注解来指定默认加载类

## 21-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？

1、 直接获取实现类serviceImpl的bean也是可以的；
2、 至于加一层接口的原因：一是AOP程序设置思想指导，
    给别人调用的接口，调用者只想知道方法和功能，
    而对于这个方法内部逻辑怎么实现的并不关心；
    二是可以降低各个模块间的关联，
    实现松耦合、程序分层、高扩展性，使程序更加灵活，
    他除了在规范上有卓越贡献外，最精髓的是在多态上的运用；
    继承只能单一继承，接口却可以多实现
3、 当业务逻辑简单，变更较少，项目自用时，
    省略掉接口直接使用实现类更简单明了；反之则推荐使用接口;

# 22.Bean-----内部bean

只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。

为了定义Bean，Spring 提供基于 XML 的配置元数据在 
<property>或 <constructor-arg> 中提供了 <bean>元素的使用。
内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。
例如，假设我们有一个 Student 类，其中引用了 Person 类。
这里我们将只创建一个 Person 类实例并在 Student 中使用它。

```java
<!-- bean.xml -->

<bean id=“StudentBean" class="com.edureka.Student">
    <property name="person">
        <!--This is inner bean -->
        <bean class="com.edureka.Person">
            <property name="name" value=“Scott"></property>
            <property name="address" value=“Bangalore"></property>
        </bean>
    </property>
</bean>
```

# 23.bean---配置方式

1. 基于 xml 配置
   bean 所需的依赖项和服务在 XML 格式的配置文件中指定。
   这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。
   它们通常以 bean 标签开头。

2. 基于注解配置
   可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本
   身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开
   注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。

3. 基于 Java API 配置
   Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。
   1、 @Bean 注解扮演与 <bean/> 元素相同的角色。
   2、 @Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法
                     来定义 bean 间依赖关系


# 23.事务-----概念


# 24.事物-----管理类型

spring支持`编程式事务管理`和`声明式事务管理`两种方式
1. 编程式事务管理使用TransactionTemplate.

2. 声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，
   将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完
   目标方法之后根据执行情况提交或者回滚事务。

## -1:事务管理的优点

为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。
为编程式事务管理提供了一套简单的API而不是一些复杂的事务API
支持声明式事务管理。
和Spring各种数据访问抽象层很好得集成

## -2:你更倾向用那种事务管理类型？

选择声明式事务管理，因为它对应用代码的影响最小，
因此更符合一个无侵入的轻量级容器的思想。
声明式事务管理要优于编程式事务管理，
虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。
唯一不足地方是，最细粒度只能作用到方法级别，
无法做到像编程式事务那样可以作用到代码块级别。

## 24-1：Spring两种事务区别

1）声明式事务最大的优点就是不需要
   在业务逻辑代码中掺杂事务管理的代码，
   只需在配置文件中做相关的事务 
   规则声明或通过@Transactional注解的方式，
   便可以将事务规则应用到业务逻辑中。
2）声明式事务管理要优于编程式事务管理，
   这正是 spring倡导的非侵入式的开发方式，
   使业务代码不受污染，
   只要加上注解就可以获得完全的事务支持。
   唯一不足地方是，最细粒度只能作用到方法级别，
   无法做到像编程式事务那样可以作用到代码块级别。

# 25.事物----原理

真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的

# 26.事务-----传播机制

事务在多个方法的调用中是如何传递的，
是重新创建事务还是使用父方法的事务？
父方法的回滚对子方法的事务是否有影响？这些都是可以通过事务传播机制来决定的。

# 27.事物-----管理接口

主要分为了三类
1. PlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心。
2. TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。
3. TransactionStatus： 事务运行状态。

我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，
而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。
PlatformTransactionManager 会根据 TransactionDefinition 
的定义比如事务超时时间、隔离界别、传播行为等来进行事务管理 ，
而 TransactionStatus 接口则提供了
一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。

# 28.事物-----隔离级别

ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，
                   使用数据库默认的事务隔离级别。
ISOLATION_READ_UNCOMMITTED:读未提交，
                           允许另外一个事务可以看到这个事务未提交的数据。
ISOLATION_READ_COMMITTED:读已提交，
                         保证一个事务修改的数据提交后
                         才能被另一事务读取，
                         而且能看到该事务对已有记录的更新。
ISOLATION_REPEATABLE_READ:可重复读，
                          保证一个事务修改的数据提交后
                          才能另一事务读取，
                          但是不能看到该事务对已有记录的更新。
ISOLATION_SERIALIZABLE:一个事务在执行的过程中
                       完全看不到其他事务对数据库所

## 28-1:Spring的事务和数据库的事务隔离是一个概念么

Spring 并不直接管理事务，而是提供了多种事务管理器 。
Spring 事务管理器的接口是： PlatformTransactionManager 。
通过这个接口，Spring 为各个平台如 
JDBC(DataSourceTransactionManager)、
Hibernate(HibernateTransactionManager)、
JPA(JpaTransactionManager)等都提供了
对应的事务管理器，但是具体的实现就是各个平台自己的事情了。

# 29.事务-----传播行为

事务传播行为是为了解决业务层方法之间互相调用的事务问题。
当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如
我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。
这个时候就涉及到业务层方法之间互相调用的事务问题。
如果我们的 bMethod()如果发生异常需要回滚，
如何配置事务传播行为才能让 aMethod()也跟着回滚呢
这个时候就需要事务传播行为的知识了，

## 29-1：传播行为

`PROPAGATION_REQUIRED`:如果当前没有事务，
                     就创建一个新事务，
                     如果当前存在事务，
                     就加入该事务，
                     该设置是最常用的设置。
`PROPAGATION_SUPPORTS`:支持当前事务，
                     如果当前存在事务，
                     就加入该事务，
                     如果当前不存在事务，
                     就以非事务执行。
`PROPAGATION_MANDATORY`:支持当前事务，
                      如果当前仔在事分，
                      影果当前不存在事务，
                      就抛出异常。
`PROPAGATION_REOUIRES NEW`:创建新事务，
                         无论当前存不存在事务，
                         都创建新事务。
`PROPAGATION_NOT_SUPPORTED`:以非事务方式执行操作，
                          如果当前存在事务，
                          就把当前事务挂起。
`PROPAGATION_NEVER`:以非事务方式执行，
                  如果当前存在事务，
                  则抛出异常。
`PROPAGATION_NESTED`:如果当前存在事务，
                   则在嵌套事务内执行。
                   如果当前没有事务，
                   则按 REQUIRED属性执行。

# 30.事务-----回滚规则

回滚规则，定义了哪些异常会导致事务回滚而哪些不会。

默认情况下，事务只有遇到运行期异常时才会回滚，
而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。
但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。
同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。

# 31.事务-----只读属性

事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。

## 31-1：什么是事务性资源

事务性资源就是指那些被事务管理的资源，
比如数据源、JMS 资源，以及自定义的事务性资源等等。
如果确定只对事务性资源进行只读操作，
那么我们可以将事务标志为只读的，
以提高事务处理的性能。

# 32.事务-----超时属性

就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。
在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。
当然，这个属性，貌似我们基本也没用过。

# 33.事务----底层原理

1. 划分处理单元 IOC
    之前在看源码，发现Spring 解决的问题是对单个数据库进行局部事务处理的，
    具体的实现首先使用 Spring 中的 IOC 划分了事务处理单元。
    并且将对事务的各种配置放到了 IOC 容器中
    （设置事务管理器，设置事务的传播特性及隔离机制）。
2. AOP 拦截需要进行事务处理的类
    Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，
    具体操作（比如事务实行的配置和读取，事务对象的抽象），
    用 TransactionProxyFactoryBean 接口来使用 AOP 功能，
    生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，
    将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，
    转化为 Spring 事务处理需要的内部数据结构
    （TransactionAttributeSourceAdvisor），
    转化为 TransactionAttribute 表示的数据对象。
3. 对事物处理实现（事务的生成、提交、回滚、挂起）
    Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。
    适配的具体事务处理器：DataSource 数据源支持、
    Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，
    JPA、JTA 数据源事务处理支持。
    这些支持都是通过设计 PlatformTransactionManager、
    AbstractPlatforTransaction 一系列事务处理的支持。 
    为常用数据源支持提供了一系列的 TransactionManager。

## 34-1：为什么在 Spring 事务中不能切换数据源？(位置不确定)

因为，在 Spring 的事务管理中，
所使用的数据库连接会和当前线程所绑定，
即使我们设置了另外一个数据源，使用的还是当前的数据源连接。
另外，多个数据源且需要事务的场景，
本身会带来多事务一致性的问题，暂时的话，可能没有太好的解决方案
所以一般一个应用，推荐除非了读写分离所带来的多数据源，
其它情况下，建议只有一个数据源。

# 34.装配----定义

当我们知道容器bean的依赖关系的时候，就可以吧bean组装到一起
当 Bean 在 Spring 容器中组合在一起时，它被称为装配或 Bean 装配

# 35.自动装配----定义

spring框架中，在配置文件中设定bean的依赖关系，
Spring容器能够自动装配相互合作的bean，
这样容器不需要配置，就能通过Bean工厂自动处理bean之间的协作。
Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。
自动装配可以设置在每个bean上，也可以设定在特定的bean上。

## 35-1:自动装配的模式

一共五种模式

自动装配的不同模式：

no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。
byName - 它根据 Bean 的名称注入对象依赖项。
         它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。
byType（最常用） - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。
构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。
autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。

## 35-2:使用@Autowired注解自动装配的过程

使用@Autowired注解来自动装配指定的bean。
在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。

在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，
当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，
并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：

   1. 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；
   2. 如果查询的结果不止一个，那么@Autowired会根据名称来查找；
   3. 如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。

## 35-3:自动装配的局限性

1. 还是要和配置来定义依赖，意味着总要重写自动装配。
2. 不能自动装配简单的属性，如基本数据类型，String字符串，和类。
3. 自动装配不如显式装配精确，如果有可能，建议使用显式装配

# 36.注解

基于Java的配置，允许在少量的Java注解的帮助下，
进行大部分Spring配置而非通过XML文件。

比如说@Configuration 注解，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。

还有就是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文

## 36-1:开启注解装配

注解装配在默认情况下是不开启的，
为了使用注解装配，我们必须在Spring配置文件中配置
<context:annotation-config/> 元素。

## 36-2:@Component, @Controller, @Repository, @Service 有何区别

1. @Component：将java类标记为bean。它是任何 Spring 管理组件的通用构造型。
               spring的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。

2. @Controller：这将一个类标记为Spring Web MVC控制器。
                标有它的 Bean 会自动导入到 IoC 容器中

3. @Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。
             可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。

4. @Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。
                它将DAO导入IoC容器，并使未经检查的异常有资格转换为 Spring DataAccessException。

## 36-3:@Required

这个注解表明bean的属性必须在配置的时候设置，
通过一个bean定义的显式的属性值或通过自动装配，
若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException

## 36-4:@Autowired

@Autowired可用于：构造函数、成员变量、Setter方法
@Autowired默认是按照类型装配注入的，
默认情况下它要求依赖对象必须存在。
@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。
它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。

### 36-4-1:@Autowired和@Resource之间的区别

1. @Autowired默认是按照类型装配注入的，
   默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。

2. @Resource默认是按照名称来装配注入的，
             只有当找不到与名称匹配的bean才会按照类型来装配注入。

## 36-5:@Qualifier

当您创建多个相同类型的bean并希望仅使用属性装配其中一个bean时，
可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。

## 36-6:@RequestMapping

@RequestMapping注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。

此注释可应用于：
     类级别：映射请求的 URL
     方法级别：映射 URL 以及 HTTP 请求方法

## 36-7：@Transaction原理

@Transactional 的工作机制是基于 AOP 实现的，
AOP 又是使用动态代理实现的。如果目标对象实现了接口，
默认情况下会采用 JDK 的动态代理，
如果目标对象没有实现了接口,会使用 CGLIB 动态代理。
通过createAopProxy() 方法决定了是使用 JDK 还是 Cglib 来做动态代理
如果一个类或者一个类中的 public 方法上
被标注@Transactional 注解的话，
Spring 容器就会在启动的时候为其创建一个代理类，
在调用被@Transactional 注解的 public 方法的时候，
实际调用的是，TransactionInterceptor 类中的 invoke()方法。
这个方法的作用就是在目标方法之前开启事务方法
执行过程中如果遇到异常的时候回滚事务，
方法调用完成之后提交事务。

## 36-7-1：注解可以用于什么地方

@Transactional 可以作用在接口、类、类方法。

1. 作用于类：当把@Transactional 注解放在类上时，
            表示所有该类的public方法都配置相同的事务属性信息。

2. 作用于方法：当类配置了@Transactional，
              方法也配置了@Transactional，
              方法的事务会覆盖类的事务配置信息。

3. 作用于接口：不推荐这种使用方法，
              因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，
              将会导致@Transactional注解失效

### 36-7-1:事务@Transactional注解属性失效

1. 检查方法是不是public。由于@Transactional注解只能应用到public的方法上，
   如果应用在protected、private或者package的方法上，也不会报错，不过事务设置不会起作用。

愿意：
因为在Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，
DynamicAdvisedInterceptor（CglibAopProxy 的内部类）
的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会
间接调用 AbstractFallbackTransactionAttributeSource
的 computeTransactionAttribute 方法，获取Transactional 注解的事务配置信息。
此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。

2. @Transactional 注解属性 propagation 设置错误
   主要是由于配置错误造成的，若是错误配置propagation，事务不会回滚

   1. TransactionDefinition.PROPAGATION_SUPPORTS：
      如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
   2. TransactionDefinition.PROPAGATION_NOT_SUPPORTED：
       以非事务方式运行，如果当前存在事务，则把当前事务挂起。
   3. TransactionDefinition.PROPAGATION_NEVER：
      以非事务方式运行，如果当前存在事务，则抛出异常。

3. @Transactional  注解属性 rollbackFor 设置错误
   由于rollbackFor 可以指定能够触发事务回滚的异常类型。
   Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）
   或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，
   但却期望 Spring 能够回滚事务，就需要指定 rollbackFor属性。
   
4. 同一个类中方法调用，导致@Transactional失效
   比如有一个类Test，它的一个方法A，A再调用本类的方法B
   （不论方法B是用public还是private修饰），但方法A没有声明注解事务，
   而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。

   原因：由于使用Spring AOP代理造成的，
        因为只有当事务方法被当前类以外的代码调用时，
        才会由Spring生成的代理对象来管理。

5. 异常被catch误导，导致@Transactional失效
   比如说，当ServiceB中抛出了一个异常以后，
   ServiceB标识当前事务需要rollback。
   但是ServiceA中由于你手动的捕获这个异常并进行处理，
   ServiceA认为当前事务应该正常commit。
   此时就出现了前后不一致，也就是因为这样，
   抛出了前面的UnexpectedRollbackException异常。

   spring的事务是在调用业务方法之前开始的，
   业务方法执行完毕之后才执行commit or rollback，
   事务是否执行取决于是否抛出runtime异常。
   如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。

   一般不需要catch异常，
   如果非要catch一定要抛出throw new RuntimeException()，
   或者注解中指定抛异常类型@Transactional(rollbackFor=Exception.class)，
   否则会导致事务失效，数据commit造成数据不一致，所以有些时候 try catch反倒会画蛇添足。

6. 数据库引擎不支持事务  
   如果是mysql，注意表要使用支持事务的引擎，比如innodb，如果是myisam，事务是不起作用的。
## 36-8：注解常用属性

1. propagation	事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过
2. isolation	事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过
3. timeout	    事务的超时时间，默认值为-1（不会超时）。
                如果超过该时间限制但事务还没有完成，则自动回滚事务。
4. readOnly	    指定事务是否为只读事务，默认值为 false。
5. rollbackFor	用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。



# 37.spring task---定时任务


# 38.数据访问----概念

## 38-1：解释对象/关系映射集成模块

Spring通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，
Spring支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。
Spring的事务管理同样支持所有ORM框架及JDBC。

# 39.数据访问----JDBC

使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。
所以开发者只需写statements 和queries从数据存取数据，
JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate

## 39-1:spring JDBC API中有哪些类

1. JdbcTemplate
2. SimpleJdbcTemplate
3. NamedParameterJdbcTemplate
4. SimpleJdbcInsert
5. SimpleJdbcCall

### 39-1-1:JdbcTemplate是什么

JdbcTemplate 类提供了很多便利的方法解决
诸如把数据库数据转变成基本数据类型或对象，
执行写好的或可调用的数据库操作语句，
提供自定义的数据错误处理。

# 40.数据访问----DAO

Spring DAO（数据访问对象）使得 JDBC，Hibernate 或 JDO 这样的数据访问技术
更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。
它还允许您在编写代码时，无需考虑捕获每种技术不同的异常

## 40-1:JDBC抽象和DAO模块

通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，
并能避免数据库资源错误关闭导致的问题，
它在各种不同的数据库的错误信息之上，
提供了一个统一的异常访问层。
它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。

# -----------------------------------------------------------------------------------------------------

# 1.spring与springMVC关系

1. Spring和SpringMVC是父子容器关系。

2. Spring整体框架的核心思想是容器，用来管理bean的生命周期，
   而一个项目中会包含很多容器，并且它们分上下层关系，
   目前最常用的一个场景是在一个项目中导入Spring和SpringMVC框架，
   而Spring和SpringMVC其实就是两个容器，Spring是父容器，SpringMVC是子容器，
   Spring父容器中注册的Bean对SpringMVC子容器是可见的，反之则不行。

3. 按照官方文档推荐，根据不同的业务模块来划分不同的容器中注册不同的Bean，
   SpringMVC主要就是为我们构建web应用程序，那么SpringMVC子容器用来注册web组件的Bean，
   如控制器、处理器映射、视图解析器等。而Spring用来注册其他Bean，
   这些Bean通常是驱动应用后端的中间层和数据层组件。

## 1-1：Spring和SpringMVC容器冲突的原因？

当SpringMVC初始化时，会寻找SpringMVC容器中的所有使用了@Controller注解的Bean，来确定其是否是一个handler。

由于在在applicationContext.xml中配置了负责所有需要注册的Bean的扫描和注册工作
和在applicationContext-MVC.xml中配置了负责SpringMVC相关注解的工作
使得当前springMVC容器中并没有注册带有@Controller注解的Bean，
而是把所有带有@Controller注解的Bean都注册在Spring这个父容器中了，
所以springMVC找不到处理器，不能进行跳转。

## 1-2：如何解决冲突？

把不同类型的Bean分配到不同的容器中进行管理
Spring父容器负责所有其他非@Controller注解的Bean的注册，
而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。

# 2.Spring MVC与Struts2异同点

`相同点`
   都是基于mvc的表现层框架，都用于web项目的开发。

`不同点`

1. 前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。
   struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。

2. 请求参数的接收方式不一样。
   1. Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，
            可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。
   2. struts2是通过类的成员变量接收请求的参数
             是基于类的开发，线程不安全，只能设计为多例的开发。
3. Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，
   Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，
   将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据
   通过reques域传输到页面。Jsp视图解析器默认使用jstl。
4. 与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。
   在企业项目中，Spring MVC使用更多一些


# 3. SpringMVC----概念

Spring MVC是一个基于Java的实现了
MVC设计模式的请求驱动类型的轻量级Web框架，
通过把模型-视图-控制器分离，将web层进行职责解耦，
把复杂的web应用分成逻辑清晰的几部分，
简化开发，减少出错，方便组内开发人员之间的配合。

## 3-1：Spring MVC 有什么优点？

1. 使用非常方便，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。
2. 提供拦截器机制，可以方便的对请求进行拦截处理。
3. 提供异常机制，可以方便的对异常做统一处理。
4. 可以任意使用各种视图技术，而不仅仅局限于 JSP ，
   例如 Freemarker、Thymeleaf 等等。
5. 不依赖于 Servlet API 
   目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，
   当然仅仅依赖 Servlet ，而不依赖 Filter、Listener。


# 4.MVC---概念

MVC应该是一个设计模式，
把一个应用程序的输入，处理和输出分开。
将一个应用程序分为三个部分：Model，View，Controller。
1. Model 模型
   完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。
   例如它可能用象EJBs和javabean这样的构件对象来处理数据库。
   由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。
2. View 视图
   就是负责跟用户交互的界面。一般就是由HTML，css元素组成的界面，
   当然现在还有一些像js，ajax，flex一些也都属于视图层。 
   在视图层里没有真正的处理发生，之负责数据输出，并允许用户操纵的方式。
   MVC能为应用程序处理很多不同的视图。 
3. Controller 控制器
   接收请求—>调用模型—>根据结果派发页面并经过模型处理返回相应数据

## 4-1：MVC优缺点（为什么使用MVC）

`优点`
1. 分工明确,开发人员可以只关注整个结构中的其中某一层
   使用MVC可以把数据库开发，程序业务逻辑开发，
   页面开发分开，每一层都具有相同的特征，方便以后的代码维护。
2. 可以降低层与层之间的依赖：
   视图层和业务层分离，这样就允许更改视图层代码
   而不用重新编译模型和控制器代码，
   同样，一个应用的业务流程或者业务规则的改变
   只需要改动MVC的模型层即可。
3. 方便各层逻辑的复用：  
`缺点:`
1、如果在表示层中需要增加一个功能，
   为保证其设计符合分层式结构，
   可能需要在相应的业务逻辑层
   和数据访问层中都增加相应的代码。
2、降低了系统的性能。
   如果不采用分层式结构，
   很多业务可以直接造访数据库，
   以此获取相应的数据，如今却必须通过中间层来完成。
3、由于它没有明确的定义，
   所以完全理解MVC并不是很容易。
   使用MVC需要精心的计划，
4、MVC并不适合小型甚至中等规模的应用程序，
   花费大量时间将MVC应用到规模
   并不是很大的应用程序通常会得不偿失。 

## 4-2：如何改善

第一个缺点，可以采用一些设计模式来到改善。
第二个缺点，可以通过系统的缓存机制来减小对性能的影响；

# 5.springmvc----组件

（1）前端控制器 DispatcherServlet（不需要程序员开发）
    作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。
（2）处理器映射器HandlerMapping（不需要程序员开发）
    作用：根据请求的URL来查找Handler
（3）处理器适配器HandlerAdapter
    在编写Handler的时候要按照HandlerAdapter要求的规则去编写，
    这样适配器HandlerAdapter才可以正确的去执行Handler。
（4）处理器Handler（需要程序员开发）
    真正执行业务逻辑的类
（5）视图解析器 ViewResolver（不需要程序员开发）
    作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）
（6）视图View（需要程序员开发jsp）
     View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）

## 5-1:什么是DispatcherServlet

它用来处理所有的HTTP请求和响应。

## -52:HandlerMapping映射策略

1. SimpleUrlHandlerMapping
   通过配置请求路径和Controller映射建立关系，找到相应的Controller

2. ControllerClassNameHandlerMapping
   通过 Controller 的类名找到请求的Controller。

3. BeanNameUrlHandlerMapping
   通过定义的 beanName 进行查找要请求的Controller

4. DefaultAnnotationHandlerMapping
   通过注解 @RequestMapping(“/userlist”) 来查找对应的Controller。

## 5-3：HandlerInterceptor

Filter拦截的对象是Serlvet，而HandlerInterceptor拦截的则是Handler(Controller)
HandlerInteceptor可以配置多个，其中任何一个返回false的话，请求都将被拦截，直接返回。

## 5-4:handler

真正执行业务逻辑的类

## 5-5:HandlerExecutionChain

主要使用了责任链设计模式，
HandlerExecutionChain将HandlerInterceptor与Handler串成一个执行链的形式，
首先请求会被第一个HandlerInterceptor拦截，
如果返回false,那么直接短路请求，如果返回true,
那么再交给第二个HandlerInterceptor处理，
直到所有的HandlerInterceptor都检查通过，
请求才到达Handler(Controller)，交由Handler正式的处理请求。
执行完成之后再逐层的返回。

DispatcherServlet拿到的就是这样一个
串联好的HandlerExecutionChain，然后顺序的执行请求。

## 5-6:ModelAndView

DispatcherServlet就使用了ModelAndView保存我们的数据和想要跳转的路径，
handler只负责业务逻辑就行了，一些url就不用handler负责

调用业务逻辑层获取数据，并将数据封装到ModelAndView中，
同时设置ModelAndView的view逻辑视图名称。
它保存了Handler执行完成之后所需要发送到前端的数据，以及需要跳转的路径。

## 5-7:ViewResolver

将数据的获取与数据的显示渲染相分离的关键，
前端可能采用各种各样的方式显示数据，可能是Jsp,可能是Html,也可能是其他的方式。
DispatcherServlet已经拿到了ModelAndView，
这里面有执行完成请求后返回的响应结果数据，还有逻辑视图的路径，
这个时候DispatcherServlet就需要根据这个逻辑视图的路径去查找谁能把数据进行解析与渲染。

### 5-7-1:寻找策略

1. BeanNameViewResolver
   将逻辑视图名解析为一个Bean,Bean的id等于逻辑视图名。

2. XmlViewResolver:和BeanNameViewResolver类似，
   只不过目标视图Bean对象定义在一个独立的XML文件中，
   而非定义在DispatcherServlet上下文的主配置文件中

3. InternalResourceViewResovlver:将视图名解析为一个URL文件，
   一般使用该解析器将视图名映射为保存在WEB-INF目录中的程序文件（如JSP）

4. XsltViewResolver:将视图名解析为一个指定XSLT样式表的URL文件

5. JasperReportsViewResolver:JasperReports是一个基于java的开源报表工具，
   这个解析器将视图名解析为报表文件对应的URL

6. FreeMarkerViewResolver:解析为基于FreeMarker模板技术的模板文件

7. VelocityViewResolver和VelocityLayoutViewResolver:解析为基于Velocity模板技术的模板文件

## 5-8:view

借助ViewResolver查找到对应的View实现类之后，
DispatcherServlet就会将ModelAndView中的数据交给View实现类来进行渲染，
待该View渲染完成之后，会将渲染完成的数据交给DispatcherServlet，
这时候DispatcherServlet将其封装到Response返回给前端显示。

# 7.SpringMVC----工作流程

1. 发送请求
   用户向服务器发送 HTTP 请求，请求被SpringMVC的调度控制器 DispatcherServlet 捕获。

2. DispatcherServlet（前端控制器） 根据请求 URL ，
   调用HandlerMapping获得该Handler配置的所有相关的对象
   包括Handler对象以及Handler对象对应的拦截器，
   最后以HandlerExecutionChain对象的形式返回。

3. DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。
   如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 #preHandler(...) 方法
   提取请求 Request 中的模型数据，填充 Handler 入参，
   开始执行Handler（Controller)。 在填充Handler的入参过程中，根据配置
   会进行比如说利用HttpMessageConverter将请求消息（如 JSON、XML 等数据）转换成一个对象。
   数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。
   数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。
   数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。
   等等，执行完成后，向 DispatcherServlet 返回一个ModelAndView对象

4. 根据返回的 ModelAndView ，选择一个已经在spring容器中注册过的适合ViewResolver，
   解析出 View 对象，然后返回给 DispatcherServlet。

5. ViewResolver 结合 Model 和 View，来渲染视图，并写回给用户或者说是浏览器

6. 
1）用户发送请求至前端控制器DispatcherServlet:
2）DispatcherServlet收到请求后，
   用HandlerMapping处理器映射器,请求获取Handle;
3）处理器映射器根据请求url找到具体的处理器，
   生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet;
4） DispatcherServlet调用HandlerAdapter处理器适配器;
5）HandlerAdapter 经过适配调用具体处理器(Handler，也叫后端控制器):
6）Handler执行完成返回 ModelAndView;
7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet:
8） DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析;
9）ViewResolver解析后返回具体View:
10）DispatcherServlet对 View进行渲染视图（即将模型数据填充至视图中）
11） DispatcherServlet 响应用户。

# 6.SpringMVC----控制器

控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。
控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。
Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。

## 6-1:Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？

是单例模式,
所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,
解决方案是在控制器里面不能写字段。

## 6-2:SpingMvc中的控制器的注解一般用哪个

一般用@Controller注解,也可以使用@RestController,
@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层

# 8.SpringMVC 拦截器

一共有三个方法，分别为：
#preHandle(...) 方法，调用 Controller 方法之前执行。
#postHandle(...) 方法，调用 Controller 方法之后执行。
#afterCompletion(...) 方法，处理完 Controller 方法返回结果之后执行。
无论调用 Controller 方法是否成功，都会执行。

比如说：
当俩个拦截器都实现放行操作时，
执行顺序为 preHandle[1] => preHandle[2] => 
postHandle[2] => postHandle[1] => afterCompletion[2] => afterCompletion[1] 。
当第一个拦截器 #preHandle(...) 方法返回 false ，
也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行 #preHandle(...) 部分。
当第一个拦截器 #preHandle(...) 方法返回 true ，
第二个拦截器 #preHandle(...) 返回 false ，
执行顺序为 preHandle[1] => preHandle[2] => afterCompletion[1] 。

## 8-1：Spring MVC 的拦截器应用场景

比如说记录访问日志。
记录异常日志。
需要登陆的请求操作，拦截未登陆的用户。

## 8-2：Spring MVC的拦截器和Filter过滤器有什么差别？

1. 功能相同：拦截器和 Filter都能实现相应的功能，我认为应该差不多
2. 容器不同：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。
3. 使用便利性不同：拦截器提供了三个方法，
                 分别在不同的时机执行；过滤器仅提供一个方法，
                 当然也能实现拦截器的执行时机的效果，就是麻烦一些。

## 8-3:拦截器怎么写？

1. 一种是实现HandlerInterceptor接口，
2. 一种是继承适配器类，接着在接口方法当中，实现处理逻辑；
                   然后在Spring MVC的配置文件中配置拦截器即可：


# 9.注解---概念

注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通
过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，
会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引
出对应的值。而memberValues的来源是Java常量池。

# 10.常用注解

1. @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有
                    响应请求的方法都是以该地址作为父路径。
2. @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
3. @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
4. @PathVariable 是 Spring MVC 中有用的注解之一，
                  它允许您从 URI 读取值，比如查询参数。
                  它在使用 Spring 创建 RESTful Web 服务时特别有用，
                  因为在 REST 中，资源标识符是 URI 的一部分。

## 10-1:@Controller注解的作用

1. 在Spring MVC 中提供了一个非常简便的定义Controller 的方法，
   无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，
   然后使用@RequestMapping 和@RequestParam 等
   一些注解用以定义URL 请求和Controller 方法之间的映射，
   这样的Controller 就能被外界访问到。
   此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet对象，
  它们可以通过Controller的方法参数灵活的获取到。

2. @Controller用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller对象。
   分发处理器将会扫描使用了该注解的类的方法，
   并检测该方法是否使用了@RequestMapping 注解

3. @Controller定义了一个控制器类，而使用@RequestMapping注解的方法才是真正处理请求的处理器。
   因为单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，
   这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：
      在Spring MVC 的配置文件中定义MyController 的bean 对象。
      在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。

## 10-2:@RequestMapping注解的作用

RequestMapping是一个用来处理请求地址映射的注解，
可用于类或方法上。
1. 用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

### 10-2-1:@RequestMapping注解属性

1. value， method
   value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
   method： 指定请求的method类型， GET、POST、PUT、DELETE等；
2. consumes，produces
   consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
   produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；
3. params，headers
   params： 指定request中必须包含某些参数值是，才让该方法处理。
   headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。

## 10-3:@ResponseBody注解的作用

用于将Controller的方法返回的对象，
通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。

使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；

## 10-4:@PathVariable和@RequestParam的区别

请求路径上有个id的变量值，
可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”,
method = RequestMethod.GET)

@RequestParam用来获得静态的URL请求入参 spring注解时action里用到

# 11.SprigMVC----数据

## 11-1:Spring MVC怎么样设定重定向和转发的？

（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"
（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"

## 11-2：Spring MVC怎么和AJAX相互调用的？

通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：
（1）加入Jackson.jar
（2）在配置文件中配置json的映射
（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。


## 11-3:如何解决POST请求中文乱码问题，GET的又如何处理呢？

（1）解决post请求乱码问题：
   在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；
（2）get请求中文参数出现乱码解决方法有两个：
   ①修改tomcat配置文件添加编码与工程编码一致，
   ②另外一种方法对参数进行重新编码：

# 14.SpringMVC的参数绑定概念

参数绑定，我认为就是客户端发送请求，而请求中包含一些数据，
在 SpringMVC 中，提交请求的数据是通过方法形参来接收的。
从客户端请求的 key/value 数据，经过参数绑定，
将 key/value 数据绑定到 Controller 的形参上，
然后在 Controller 就可以直接使用该形参。
在是一个参数绑定组件，将请求的数据转换
为我们需要的数据称为参数绑定组件，
也就是参数绑定转换器。
SpringMVC 内置了很多参数转换器，
只有在极少数情况下需要我们自定义参数转换器。

## 14-1：SpringMVC的参数绑定支持类型

1. 默认支持类型
      1. HttpServletRequest 对象
      2. HttpServletResponse 对象
      3. HttpSession 对象
      4. Model/ModelMap 对象

2. 基本数据类型的绑定
3. 包装数据类型的绑定
4. POJO（实体类）类型的绑定
5. 复合POJO（实体类）类型的绑定
6. 数组类型的绑定
7. List类型的绑定
8. Map类型的绑定

# 15.SpringMVC---异常处理

Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，
将处理器( handler )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。
如果异常被解析成功，则会返回 ModelAndView 对象。

还有一种方法是通过注解的方式，使用 @ExceptionHandler 注解来实现过异常的处理

# 16.REST---概念

REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，
例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。

## 16-1：REST与RESTful

基于REST构建的API就是Restful风格

## 16-2：资源是什么?
资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，
它允许客户端通过 HTTP 方法如：GET, POST,PUT, DELETE 等读，写，修改和创建资源。

## 16-3：REST 是可扩展的或说是协同的吗

是的，REST 是可扩展的和可协作的。
它既不托管一种特定的技术选择，也不定在客户端或者服务端。
你可以用 Java, C++, Python, 或 JavaScript 来创建 RESTful Web 服务，
也可以在客户端使用它们。

# 17.REST----网络问题

## 17-1：REST用哪种HTTP方法

REST 能用任何的 HTTP 方法，比如说

用 GET 来检索服务端资源
用 POST 来创建服务端资源
用 PUT 来更新服务端资源
用 DELETE 来删除服务端资源。

## 17-2：什么是幂等操作

有一些HTTP方法，

如：GET，不管你使用多少次它都能产生相同的结果，
在没有任何一边影响的情况下，发送多个 GET 请求到相同的URI 将会产生相同的响应结果。因此，这就是所谓幂等操作。

POST方法不是幂等操作 ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。
但是，假如你用PUT更新资源，它将是幂等操作。
甚至多个 PUT 请求被用来更新服务端资源，将得到相同的结果。

## 17-3：删除的 HTTP 状态返回码是什么 ?

在删除成功之后，它可以返回 200 或 204 没有内容。

一般来说，如果删除操作成功，响应主体为空，返回 204 。
如果删除请求成功且响应体不是空的，则返回 200 。

# 18.REST----状态

REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。
REST API 中的请求应该包含处理它所需的所有细节。
它不应该依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。

# 19.REST----安全

REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。
至少，可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。
类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。

# 20.REST---模板

在 Spring Framework 中，RestTemplate 类是 模板方法模式 的实现。
跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，
它将在客户端简化跟 RESTful Web 服务的集成。
也可以使用OKHTTP，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。

# 21.REST---接口

HttpMessageConverter是一种策略接口 ，
它指定了一个转换器，它可以转换 HTTP 请求和响应。
Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。
每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。
Spring 使用 "Accept" 的标头来确定客户端所期待的内容类型。
然后，它将尝试找到一个注册的 HTTPMessageConverter ，
它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。

## 21-1：如何创建HttpMessageConverter的自定义实现来支持一种新的请求/响应？

仅需要创建自定义的 AbstractHttpMessageConverter 的实现，
并使用 WebMvcConfigurerAdapter 的 
#extendMessageConverters(List<HttpMessageConverter<?>> converters) 
方法注中册它，该方法可以生成一种新的请求 / 响应类型。

# ----MyBatis----------------------------------------------------------------------------------------------

# 1.MyBatis---概念

1. Mybatis是一个半ORM框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，
   就不用花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。

2. MyBatis可以使用XML或注解来配置和映射信息，
   将POJO映射成数据库中的记录，这样就可以避免了JDBC代码和手动设置参数。

## 1-1：MyBatis优点

1. 简单易学，容易上手（相比于Hibernate） ---- 基于SQL编程
2. 消除了JDBC大量冗余的代码，不需要手动开关连接
3. 很好的与各种数据库兼容
      因为MyBatis使用JDBC来连接数据库，
     所以只要JDBC支持的数据库MyBatis都支持，
     而JDB提供了可扩展性，所以只要这个数据库有针对Java的
     jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。
4. 提供了很多第三方插件（分页插件 / 逆向工程）
5. 能够与Spring很好的集成

## 1-2:myBatis缺点

1. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。
2. SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。

## 1-2：Mybatis是半自动ORM映射工具

Hibernate 属于全自动 ORM 映射工具，
使用 Hibernate 查询关联对象或者关联集合对象时，
可以根据对象关系模型直接获取，所以它是全自动的。
而 Mybatis 在查询关联对象或关联集合对象时，
需要手动编写 sql 来完成，
所以，称之为半自动 ORM 映射工具。

## 1-3：传统JDBC开发存在的问题，如何解决的

1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，
   如果使用数据库链接池可解决此问题。
   `解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。`
2. Sql语句写在代码中造成代码不易维护，
   实际应用sql变化的可能较大，sql变动需要改变java代码。
   `解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。`
3. 向sql语句传参数麻烦，因为sql语句的where条件不一定，
   可能多也可能少，占位符需要和参数一一对应。
   `解决： Mybatis自动将java对象映射至sql语句。`
4. 对结果集解析麻烦，sql变化导致解析代码变化，
   且解析前需要遍历，如果能将数据库记录
   封装成pojo对象解析比较方便。
    `解决：Mybatis自动将sql执行结果映射至java对象。`

## 1-4：Hibernate 和 MyBatis 的区别

1） Mybatis 它不完全是一个 ORM 框架，
    因为 MyBatis 需要程序员自己编写 Sql 语句，
2） Mybatis 学习门槛低，简单易学，
    程序员直接编写原生态 sql，可严格控制 sql 执行性
    能，灵活度高，非常适合对关系数据模型要求不高的软件开发，
3） Hibernate 对象/关系映射能力强，
    数据库无关性好，对于关系模型要求高的软件
    （例如需求固定的定制化软件）
    如果用 hibernate 开发可以节省很多代码，提高效率。
    但是Hibernate 的缺点是学习门槛高，要精通门槛更高，

## 1-5:mybatis使用场景




# 2.MyBatis----组成

1. Configuration：用于描述 MyBatis 主配置文件信息，
                MyBatis 框架在启动时会加载主配置文件，
                将配置信息转换为 Configuration 对象。
2. SqlSession：面向用户的 API，是 MyBatis 与数据库交互的接口。
3. Executor：SQL 执行器，用于和数据库交互。
             SqlSession 可以理解为 Executor 组件的外观（外观模式），
             真正执行 SQL 的是 Executor 组件。
4. MappedStatement：用于描述 SQL 配置信息，
                    MyBatis 框架启动时，XML 文件或者注解配置
                    的 SQL 信息会被转换为 MappedStatement 
                    对象注册到 Configuration 组件中。
5. StatementHandler：封装了对 JDBC 中 Statement 对象的操作，
                    包括为 Statement 参数占位符设置值，
                    通过 Statement 对象执行 SQL 语句。
6. TypeHandler：类型处理器，用于 Java 类型与 JDBC 类型之间的转换。
7. ParameterHandler：用于处理 SQL 中的参数占位符，为参数占位符设置值。
8. ResultSetHandler：封装了对 ResultSet 对象的处理逻辑，
                    将结果集转换为 Java 实体对象。

# 3.MyBatis----编程步骤

1. 创建 SqlSessionFactory 对象。
2. 通过 SqlSessionFactory 获取 SqlSession 对象。
3. 通过 SqlSession 获得 Mapper 代理对象。
4. 通过 Mapper 代理对象，执行数据库操作。
5. 执行成功，则使用 SqlSession 提交事务。
6. 执行失败，则使用 SqlSession 回滚事务。
7. 最终，关闭会话。


# 4.MyBatis------原理

## 4-1：MyBatis的解析和运行原理

MyBatis的运行过程分为两大步：

1. 读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory；
   - 第一步：通过org.apache.ibatis.builder.xml.XMLConfigBuilder解析配置的XML文件，
             对出所配置的参数，并将读取的能容存入org.apache.ibatis.session.
             Configuration类对象中。而Configuration采用的是单例模式，
             几乎所有的MyBatis配置内容都会存放在这个单例对象中，以便后续将这些内容读出。
   - 第二步：使用Configuration对象去创建SqlSessionFactory。
             MyBatis中的SqlSessionFactory是个接口，
             而不是一个实现类，为此MyBatis提供了一个默认的实现类
             org.apache.ibatis.session.default.DefaultSqlSessionFactory。
             在大部分情况下都没有必要自己创建新的SqlSessionFactory实现类。

2. SqlSession的执行过程。
    主要使用JDK动态代理

## 4-2：MyBatis的工作原理(启动)

1、 加载mybatis全局配置文件（数据源、mapper映射文件等），
    解析配置文件，MyBatis基于XML配置文件生成Configuration，
    和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），
    其对应着<select | update | delete | insert>标签项。
2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，
   用来开启SqlSession。
3、SqlSession对象完成和数据库的交互：
a、用户程序调用mybatis接口层api（即Mapper接口中的方法）
b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象
c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，
   sql参数转化、动态sql拼接，生成jdbc Statement对象
d、JDBC执行sql。
e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。

## 4-3：MyBatis底层原理

SqlSession为主要的调配者，持有Configuration与Executor，
先是创建Mapper委托Configuration去以MapperProxy给Mapper接口做动态代理，
底层查询方法根据mapper.xml的查询类型执行SqlSession的查询方法，
而SqlSession在查询时又委托Executor去做实际的查询，
Executor会使用Statement查询结果集，然后使用ResultSetmapping做结果集的映射POJO，
然后返回给SqlSession，因为动态代理，所以mapper的方法实际是SqlSession执行的查询方法，
所以这时候SqlSession返回给方法查询结果，
表面看起来像是Mapper的方法返回的结果，实际上却是SqlSession在做事情。

# 5.MyBatis----设计模式

1. Builder模式
   例如SqlSessionFactoryBuilder、XMLConfigBuilder、
       XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；

   如何使用的：
   在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder
   会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，
   构建Mybatis运行的核心对象Configuration对象，
   然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。
   而XMLConfigBuilder在构建Configuration对象时，
   也会调用XMLMapperBuilder用于读取*Mapper文件，
   而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。
   Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、
   反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，
   因此大量采用了Builder模式来解决。

2. 工厂模式
   例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；
   
   如何使用的：
   比如说，DefaultSqlSessionFactory的openSession方法，
   该方法先从configuration读取对应的环境配置，
   然后初始化TransactionFactory获得一个Transaction对象，
   然后通过Transaction获取一个Executor对象，
   最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。
   这样子，SqlSession的执行，其实是委托给对应的Executor来进行的。

3. 单例模式，
   例如ErrorContext和LogFactory；

   如何使用的：
   ErrorContext是用在每个线程范围内的单例，
               用于记录该线程的执行环境错误信息，
   LogFactory则是提供给整个Mybatis使用的日志工厂，
             用于获得针对项目配置好的日志对象。

4. 代理模式，
   Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；
   executor.loader包使用了cglib或者javassist达到延迟加载的效果；

   如何使用的：
   比如说，在MapperProxy中，实现了InvocationHandler接口，并且实现了该接口的invoke方法。
   通过这种方式，我们只需要编写Mapper.java接口类，
   当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，
   而该方法则会调用后续的sqlSession.cud>executor.execute>prepareStatement等一系列方法，
   完成SQL的执行和返回。

5. 组合模式，例如SqlNode和各个子类ChooseSqlNode等；

6. 模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；

7. 适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；

8.  装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；

9.  迭代器模式，例如迭代器模式PropertyTokenizer；


# 6.DAO----数据库问题

## 6-1:当实体类中的属性名和表中的字段名不一样

第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

```java
<select id="selectOrder" parameterType="Integer" resultType="Order"> 
    SELECT order_id AS id, order_no AS orderno, order_price AS price 
    FROM orders 
    WHERE order_id = #{id}
</select>
```
第二种，通过 <resultMap> 来映射字段名和实体类属性名的一一对应的关系。

```java
<resultMap type="me.gacl.domain.Order" id=”OrderResultMap”> 
    <id property="id" column="order_id"> 
    <result property="orderNo" column ="order_no" /> 
    <result property="price" column="order_price" /> 
</resultMap>
```

## 6-2:模糊查询like语句该怎么写?

1. 在Java代码中添加sql通配符
2. 在sql语句中拼接通配符，但是缺点就是会引起sql注入

## 6-3：Mybatis 执行批量插入，能返回数据库主键列表吗？

能，JDBC 都能做，Mybatis 当然也能做。

## 6-4：MyBatis 如何执行批量插入?

1. 设置SqlSession为批量操作类型

```java
sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);
    try {
     namemapper mapper = sqlsession.getmapper(namemapper.class);
     for (string name : names) {
         mapper.insertname(name);
     }
     sqlsession.commit();
    }catch(Exception e){
     e.printStackTrace();
     sqlSession.rollback(); 
     throw e; 
    }
     finally {
         sqlsession.close();
    }
```
然后执行insert方法即可

2. 通过foreach 遍历需要操作的值

```java
<insert id="insertByBatch" parameterType="java.util.List">
        insert into user(name)
        values
        <foreach collection="list" item="item" index="index" separator=",">
            (#{item.name,jdbcType=VARCHAR}
        </foreach>
    </insert>
```

## 6-5：在 Mapper 中如何传递多个参数

第一种，使用 Map 集合，装载多个参数进行传递。
```java
// 调用方法
Map<String, Object> map = new HashMap();
map.put("start", start);
map.put("end", end);
return studentMapper.selectStudents(map);

// Mapper 接口
List<Student> selectStudents(Map<String, Object> map);

// Mapper XML 代码
<select id="selectStudents" parameterType="Map" resultType="Student">
    SELECT * 
    FROM students 
    LIMIT #{start}, #{end}
</select>
```
第二种，保持传递多个参数，使用 @Param 注解。代码如下：
```java
// 调用方法
return studentMapper.selectStudents(0, 10);
// Mapper 接口
List<Student> selectStudents(@Param("start") Integer start, @Param("end") Integer end);
// Mapper XML 代码
<select id="selectStudents" resultType="Student">
    SELECT * 
    FROM students 
    LIMIT #{start}, #{end}
</select>
```
第三种，保持传递多个参数，不使用 @Param 注解。代码如下：
```java
// 调用方法
return studentMapper.selectStudents(0, 10);

// Mapper 接口
List<Student> selectStudents(Integer start, Integer end);

// Mapper XML 代码
<select id="selectStudents" resultType="Student">
    SELECT * 
    FROM students 
    LIMIT #{param1}, #{param2}
</select>
```
其中，按照参数在方法方法中的位置，从 1 开始，逐个为 #{param1}、#{param2}、#{param3} 不断向下。

## 6-6：MyBatis实现一对一，一对多有几种方式，怎么操作的？

能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，
多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，
其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，
赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，
一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，
就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？
其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，
Mybatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，
Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

# 7.DAO----接口工作原理

Dao接口即Mapper接口。

接口的全限名，就是映射文件中的 "namespace" 的值。
接口的方法名，就是映射文件中 MappedStatement 的 "id" 值。
接口方法内的参数，就是传递给 SQL 的参数。

Mapper 接口是没有实现类的，当调用接口方法时，
接口全限名 + 方法名拼接字符串作为 key 值，
可唯一定位一个对应的 MappedStatement 。
举例：com.mybatis3.mappers.StudentDao.findStudentById ，
可以唯一找到 "namespace" 为 com.mybatis3.mappers.StudentDao 
下面 "id" 为 findStudentById 的 MappedStatement 。

在 Mybatis 中，比如说 
<select/>、<insert />、<update />、<delete /> 这些标签，
都会被解析为一个 MappedStatement 对象。
另外，Mapper 接口的实现类，通过 MyBatis 
使用 JDK Proxy 自动生成其代理对象 Proxy ，
而代理对象 Proxy 会拦截接口方法，
从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，
返回执行结果。

## 7-1:Mapper接口绑定几种实现方式

第一种，通过 XML Mapper 里面写 SQL 来绑定。
       在这种情况下，要指定 XML 映射文件里面
       的 "namespace" 必须为接口的全路径名。
第二种，通过注解绑定，就是在接口的方法上面加上
        @Select、@Update、@Insert、@Delete 注解，里面包含 SQL 语句来绑定。
第三种，是第二种的特例，也是通过注解绑定，
        在接口的方法上面加上 @SelectProvider、
        @UpdateProvider、@InsertProvider、@DeleteProvider
        注解，通过 Java 代码，生成对应的动态 SQL 。

## 7-2:接口调用时有哪些要求？

1) Mapper接口方法名和Mapper.xml中定义的每个SQL的id相同； 
2) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sqlparameterType类型相同 
3) Mapper接口方法的输入输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 
4) Mapper.xml文件中的namespace，就是接口的类路径。

## 7-3：Dao接口里的方法，参数不同时，方法能重载吗

Dao 接口里的方法，是不能重载的，
因为是全限名+方法名的保存和寻找策略。
Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时
会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，
代理对象 proxy 会拦截接口方法，
转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。


# 8.DAO----加载mapper

用户可利用 SqlSession 获取想要的
Mapper 对象（MapperProxy 代理对象）；当执行 Mapper 的方法，
MapperProxy 会创建对应的 MapperMetohd，
然后 MapperMethod 底层其实是利用 SqlSession 来执行 SQL。
但是真正执行 SQL 操作的应该是 Executor组 件，
Executor 可以理解为 SQL 执行器，
它会使用 StatementHandler 组件对 JDBC 的 Statement 对象进行操作。
当 Statement 类型为 CallableStatement 和 PreparedStatement 时，
会通过 ParameterHandler 组件为参数占位符赋值。
ParameterHandler 组件中会根据 Java 类型找到对应的 TypeHandler 对象，
TypeHandler 中会通过 Statement 对象提供的 
setXXX() 方法（例如setString()方法）为 Statement 
对象中的参数占位符设置值。
StatementHandler 组件使用 JDBC 
中的 Statement 对象与数据库完成交互后，
当 SQL 语句类型为 SELECT 时，MyBatis 
通过 ResultSetHandler 组件从 
Statement 对象中获取 ResultSet 对象，
然后将 ResultSet 对象转换为 Java 对象。

# 9.DAO----Mapper编写

`第一种：接口实现类继承 SqlSessionDaoSupport：`
       使用此种方法需要编写mapper 接口，
       mapper 接口实现类、mapper.xml 文件。
         1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置

            ```java
            <mappers>
               <mapper resource="mapper.xml 文件的地址" />
               <mapper resource="mapper.xml 文件的地址" />
            </mappers>
            ```
         2、定义 mapper 接口
         3、实现类集成 SqlSessionDaoSupportmapper 
            方法中可以this.getSqlSession()进行数据增删改查。
         4、spring 配置
            ```java
            <bean id=" " class="mapper 接口的实现">
            <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
            </bean>
            ```
`第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：`
         1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和
         mappre 接口的名称相同且在同一个目录，这里可以不用配置

            ```java
            <mappers>
               <mapper resource="mapper.xml 文件的地址" />
               <mapper resource="mapper.xml 文件的地址" />
            </mappers>
            ```
         2、定义 mapper 接口：
            1、mapper.xml 中的 namespace 为 mapper 接口的地址
            2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致
            3、Spring 中定义

            ```java
            <bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
               <property name="mapperInterface" value="mapper 接口地址" />
               <property name="sqlSessionFactory" ref="sqlSessionFactory" />
            </bean>
            ```

`第三种：使用 mapper 扫描器：`
         1、mapper.xml 文件编写：mapper.xml 中的 namespace 为 mapper 接口的地址；
            mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；
            如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。
         2、定义 mapper 接口：注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录
         3、配置 mapper 扫描器：

            ```java
            <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
               <property name="basePackage" value="mapper 接口包地址"></property>
               <property name="sqlSessionFactoryBeanName"value="sqlSessionFactory"/>
            </bean>
            ```
# 10.DAO---传递多个参数

1、第一种：
```java
DAO 层的函数
public UserselectUser(String name,String area);
对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，
          #{1}代表 dao 层中第二参数，更多参数一致往后加即可。
<select id="selectUser"resultMap="BaseResultMap">
select * fromuser_user_t
whereuser_name = #{0}
anduser_area=#{1}
</select>
```

2、第二种：

```java
使用 @param 注解:
public interface usermapper {
user selectuser(@param(“username”) string
username,@param(“hashedpassword”) string hashedpassword);
}
然后,就可以在 xml 像下面这样使用
(推荐封装为一个 map,作为单个参数传递给mapper):
<select id=”selectuser” resulttype=”user”>
select id, username, hashedpassword
from some_table
where username = #{username}
and hashedpassword = #{hashedpassword}
</select>
```

3、第三种：

```java
多个参数封装成 maptry {
我们使用 Map 集合来装载我们的参数
Map < String, Object > map = new HashMap();
map.put("start", start);
map.put("end", end);
return sqlSession.selectList("StudentID.pagination", map);
} catch (Exception e) {
e.printStackTrace();
sqlSession.rollback();
throw e;
} finally {
MybatisUtil.closeSqlSession();}
```

# 11.DAO--- sql符号问题

## 11-1：#{}和${}的区别是什么

1. ${}是 Properties 文件中的变量占位符，
   它可以用于标签属性值和 sql 内部，
   属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
2. #{}是 sql 的参数占位符，Mybatis 会将 sql 中的#{}替换为?号，
   在 sql 执行前会使用 PreparedStatement 的参数设置方法，
   按序给 sql 的?号占位符设置参数值，
   比如 ps.setInt(0, parameterValue)，#{item.name} 
   的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，
   相当于 param.getItem().getName()。

## 11-2: mybatis的$存在安全问题，为什么又不得不用？

1. 比如说某个参数的值是ID，那么${参数}会变成ID，#{参数}会被替换成'ID',变成了字符串，注意引号。
2. 比如说我想对id列进行排序，但是没有列名'ID'，为了防止sql注入问题，
   我们只能限制传入的参数内容或者形式，不能让任意的参数内容传入进来

# 12.XML映射文件---概念

MyBatis 的真正强大在于它的映射语句，
与JDBC相比，省下了很大一批的代码

## 12-1：Xml映射文件中有哪些标签

select|insert|updae|delete 
<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，
加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，
其中为 sql 片段标签，通过<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。

# 13.XML映射文件----id问题

## 13-1：不同的Xml映射文件，id是否可以重复？

不同的 Xml 映射文件，如果配置了namespace，那么 id 可以重复；
如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，

## 13-2：为什么id不能重复

原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，
如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。
有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。

# 14.XML映射文件----mybatis数据结构的关系

Mybatis 将所有 Xml 配置信息都封装到 All-In-One 
重量级对象 Configuration 内部。
在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，
其每个子元素会被解析为 ParameterMapping 对象。
<resultMap>标签会被解析为 ResultMap 对象，
其每个子元素会被解析为 ResultMapping 对象。
每一个<select>、<insert>、<update>、<delete>标签均会
被解析为 MappedStatement 对象，
标签内的 sql 会被解析为 BoundSql 对象。

## 14-1：Mybatis是否可以映射Enum枚举类

Mybatis 可以映射枚举类，
不单可以映射枚举类，
Mybatis 可以映射任何对象到表的一列上。
映射方式为自定义一个 TypeHandler，
实现 TypeHandler 的 setParameter()和 getResult()接口方法。
TypeHandler 有两个作用，
一是完成从 javaType 至 jdbcType 的转换，
二是完成 jdbcType 至 javaType 的转换，
主要是通过setParameter()和 getResult()两个方法实现
分别代表设置 sql 问号占位符参数和获取列查询结果。

### 14-4-1：TypeHandler 有两个作用

一是，完成从 javaType至jdbcType 的转换。
二是，完成 jdbcType至javaType 的转换。

# 15.动态sql---概念

Mybatis 动态 sql 可以让我们在 Xml 映射文件内，
以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能

## 15-1：动态sql种类

Mybatis 提供了 9 种动态 sql 标签 
trim|where|set|foreach|if|choose|when|otherwise|bind。

# 16.动态sql---原理

使用 OGNL 从 sql 参数对象中计算表达式的值，
根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

## 16-1：如何将sql执行结果封装为目标对象并返回的

第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。
第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，
       比如 T_NAME AS NAME，对象属性名一般是 name，小写，
       但是列名不区分大小写，Mybatis 会忽略列名大小写，
       智能花的就可以找到与之对应对象属性名，
       你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，
同时使用反射给对象的属性逐一赋值并返回，
那些找不到映射关系的属性，是无法完成赋值的。

# 17.sql---注入问题

它不是利用操作系统的BUG来实现攻击，
而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。

## 17-1:Mybatis如何防止SQL注入

攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），
有可能入侵参数检验不足的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。

在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。
若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。

# 18.执行器----概念

执行器负责整个SQL执行过程的总体控制，

所有我们在应用层通过sqlSession执行
各类增删改操作在做了动态sql和参数相关的封装处理后，
都被委托给具体的执行器去执行，

# 19.执行器----种类

Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
1. SimpleExecutor：每执行一次 update 或 select，
   就开启一个 Statement 对象，用完立刻关闭 Statement 对象。
2. ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，
   存在就使用，不存在就创建，用完后，不关闭 Statement 对象，
   而是放置于 Map<String, Statement>内，供下一次使用。
   简言之，就是重复使用 Statement 对象。
3. BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），
   将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
   它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，
   等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。
   作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

## 19-1：Mybatis中如何指定使用哪一种Executor执行器？

在 Mybatis 配置文件中，可以指定默认的ExecutorType执行器类型，
也可以手动给 DefaultSqlSessionFactory 的
创建 SqlSession 的方法传递 ExecutorType 类型参数。

## 20-2:三种执行器的区别

# 21.MyBatis的预编译

预编译（#{}）会将SQL提前编译好，#{}位置为占位符，
执行时候一个占位符就对应一个变量，不会影响到SQL结构，
所以不会存在SQL注入问题；
非预编译（${}）不会提前编译SQL，
${}位置会直接将变量拼接进来会影响到SQL的本身机构

## 21-1：MyBatis是如何做到SQL预编译的呢

在框架底层，是JDBC中的PreparedStatement类在起作用，
PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。
这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。
原因是SQL已编译好，再次执行时无需再编译。

# 22.延迟加载

容器启动之后会将所有作用域为单例的 Bean 都创建好，
但是有的业务场景我们并不需要它提前都创建好。
此时，我们可以在Bean 中设置 lzay-init = "true" 。
这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。
而是在获得该 Bean 时，才真正在创建加载。

## 22-1：Mybatis是否支持延迟加载

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，
association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，
可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。
它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，
进入拦截器方法，比如调用 a.getB().getName()，
拦截器 invoke()方法发现 a.getB()是 null 值，
那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，
然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，
接着完成 a.getB().getName()方法的调用。
这就是延迟加载的基本原理。

# 23.接口----绑定

接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 

## 23-1：接口绑定有哪些实现方式？

1. 一种是通过注解绑定，就是在接口的方法上面加上
   @Select、@Update等注解，里面包含Sql语句来绑定；
   这种方式不用写mapper.xml
2. 一种就是通过xml里面写SQL来绑定, 
   在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。
  
## 23-2:两种接口绑定的选择

当Sql语句比较简单时候,用注解绑定, 
当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。

# 24.分页---原理

分页插件的基本原理是使用 Mybatis 提供的插件接口，
实现自定义插件，在插件的拦截方法内拦截待执行的 sql，
然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：select * from student，
拦截 sql 后重写为：select t._ from （select \* from student）t limit 0，10

# 25.Mybatis是如何进行分页的？

Mybatis 使用 RowBounds 对象进行分页，
它是针对 ResultSet 结果集执行的内存分页，
而非物理分页，
可以在 sql 内直接书写带有物理分页的参数
来完成物理分页功能，
也可以使用分页插件来完成物理分页。

# 26.插件---原理

Mybatis 仅可以编写针对 ParameterHandler、
ResultSetHandler、StatementHandler、Executor
这 4 种接口的插件，
Mybatis 使用 JDK 的动态代理，
为需要拦截的接口生成代理对象以实现接口方法拦截功能，
每当执行这 4 种接口对象的方法时，
就会进入拦截方法，
具体就是 InvocationHandler 的 invoke()方法，
当然，只会拦截那些你指定需要拦截的方法。

## 26-1：如何编写一个插件

实现 Mybatis 的 Interceptor 接口
并复写 intercept()方法，
然后在给插件编写注解，
指定要拦截哪一个接口的哪些方法即可，
在配置文件中配置你编写的插件。

# 27.一级二级缓存

一级缓存是mybatis默认就帮我们开启的，一级缓存是SqlSession级别的缓存。
在操作数据库时需要构造sqlSession对象，
在对象中有一个数据结构（HashMap）用于存储缓存数据。
不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

二级缓存是mapper级别的缓存，
多个SqlSession去操作同一个Mapper的sql语句，
多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

# ---Servlet--------------------------------------------------------------------------------

# 1.生命周期

1. 加载 Servlet；当 Tomcat 第一次访问 Servlet 的时候，Tomcat 负责创建 Servlet 的实例；
   只有第一次访问 Servlet 时会创建 Servlet 实例，第一次之后就会检查已经装载了的该 Servlet 实例对象；

2. 初始化：当 Servlet 实例化时，Tomcat 调用 init() 方法初始化对象；

3. 执行服务：接收浏览器传来的请求，调用 service() 方法处理请求并返回响应；
   service() 方法通常是开发者需要重新实现的方法；
4. 销毁 Servlet：当 Tomcat 关闭，或者检测到 Servlet 要从 Tomcat 中删除时，
                调用 Servlet 的 destroy() 接口，释放该 Servlet 实例占的资源；
5. 卸载：Servlet 调用 destroy() 方法后等待垃圾回收。

   只要访问 Servlet，service() 方法就会被调用；init() 方法只有第一次访问 Servlet 的时候才会被调用；
   destroy() 方法只有在 Tomcat 关闭销毁时才会被调用。

## 1-1：forward和redirect的区别

1. 实际发生位置不同，地址栏不同
    `转发`是发生在服务器的
    转发是由服务器进行跳转的，在转发的时候，
    浏览器的地址栏是没有发生变化的，在
    我访问Servlet111的时候，
    即使跳转到了Servlet222的页面，
    浏览器的地址还是Servlet111的。
    也就是说浏览器是不知道该跳转的动作，
    转发是对浏览器透明的。
    通过上面的转发时序图我们也可以发现，
    实现转发只是一次的http请求，
    一次转发中request和response对象都是同一个。
    `重定向`是发生在浏览器的
    重定向是由浏览器进行跳转的，进行重定向跳转的时候，
    浏览器的地址会发生变化的。
    实现重定向的原理是由response的状态码
    和Location头组合而实现的。
    这是由浏览器进行的页面跳转
    实现重定向会发出两个http请求，
    request域对象是无效的，
    因为它不是同一个request对象
2. 用法不同:
    request.getRequestDispatcher("/资源名 URI").forward(request,response)
    转发时"/"代表的是本应用程序的根目录【zhongfucheng】
    response.send("/web应用/资源名 URI");
    重定向时"/"代表的是webapps目录
3. 能够去往的URL的范围不一样:
    转发是服务器跳转只能去往当前web应用的资源
    重定向是服务器跳转，可以去往任何的资源
4. 传递数据的类型不同
    转发的request对象可以传递各种类型的数据，包括对象
    重定向只能传递字符串
5. 跳转的时间不同
    转发时：执行到跳转语句时就会立刻跳转
    重定向：整个页面执行完之后才执行跳转

## 1-3：典型的应用场景

转发: 访问 Servlet 处理业务逻辑，
      然后 forward 到 jsp 显示处理结果，
      浏览器里 URL 不变
重定向: 提交表单，
        处理成功后 redirect 
        到另一个 jsp，防止表单重复提交，
        浏览器里 URL 变了


# 2.servlet---如何使用

1. 首先我们通常要编写一个自己的Servlet然后继承自HttpServlet,
   然后重写其doGet()与doPost()方法。
   这两个方法都会将HttpServletRequest与HttpServletResponse作为参数传递进去，
   然后我们从Request中提取前端传来的参数，
   在相应的doXXX方法内调用事先编写好的Service接口，
   Dao接口即可将数据准备好放置到Response中并跳转到指定的页面即可，
   跳转的方式可以选择转发或者重定向。

2. Servlet使用的是模板方法的设计模式，在Servlet顶层将会调用service方法，
   该方法会构造HttpServletRequest与HttpServletResponse对象作为参数调用子类重写的doXXX()方法。
   然后返回请求。

3. 最后我们需要将我们编写的自定义Servlet注册到web.xml中，
   在web.xml中配置servlet-mapping来为该servlet指定处理哪些请求。

# 3.Servlet----缺点

1. 每个Servlet只能处理一个请求，这样当系统比较大，
   业务比较复杂的时候可能会存在成百上千的Servlet，找起来都眼花。

2. 每次我们都需要手动的从Request中获取请求参数，
   然后封装成我们想要的对象，这其中可能还要对参数进行校验，
   在调用业务逻辑层获取到数据之后，我们还要手动的设置到响应中，
   同时手动的选择转发或者重定向进行跳转。

3. 我们的请求的url是硬配置到web.xml中的，
   缺乏灵活性，如果可以动态的配置这种请求url与处理的对应关系就好了。

4. 我们的Servlet与前端的渲染框架紧耦合在一块，
   这样当前端换一种显示技术的时候就需要改动较大的代码，
   如果能把数据的处理与数据的显示分离，让其松散耦合就更好了。

# 4.Servlet-----安全性

Servlet不是线程安全的

比如说，当Tomcat接收到Client的HTTP请求时，
Tomcat从线程池中取出一个线程，
之后找到该请求对应的Servlet对象并进行初始化，
之后调用service()方法。
要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，
即是单例模式。
如果多个HTTP请求请求的是同一个Servlet，
那么着两个HTTP请求对应的线程
将并发调用Servlet的service()方法。
Thread1和Thread2调用了同一个Servlet1，
所以此时如果Servlet1中定义了
实例变量或静态变量，
那么可能会发生线程安全问题（因为所有的线程都可能使用这些变量）

# 5.servlet、jsp与SpringMVC区别

## 5-1：servlet和springmvc区别

1. 比如说在数据库进行了添加删除更改功能，
   在web.xml中注册新sevlet，
   并映射对应的/insert /delete /update /XXX，
   在这些新的servlet中调用View和Model层完成功能。
   这样新定义servlet的方法比较麻烦，
   要去继承HttpServlet接口，
   实现接口方法，手写调用jsp的重定向或者请求转发，
   还要再web.xml中注册。

2. Spring主要也是通过DispatcherServlet实现了Servlet这个接口，
   又叫前端控制器，
   来自前端的请求会先到达这里，
   它负责到后台去匹配合适的handler。
   DispatcherServlet的主要工作流程如下：
   前端请求到达DispatcherServlet。
   前端控制器请求HandlerMappering 查找Handler。
   如果查找到存在的处理器，进一步去调用service和dao层
   返回结果再到controller层，渲染具体的视图，返回结果给页面。

## 5-2：jsp和servlet区别

通过 http 请求一个 JSP 页面是，
首先 Tomcat 会调用 service（）方法将JSP编译成为 Servlet，然后执行 Servlet。

# 6.servlet加载顺序

web.xml 的加载顺序是：
context- param -> listener -> filter -> servlet

# 7.tomcat与servlet

## 7-1：tomcat容器是如何创建servlet类实例

当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，
然后对 xml文件进行解析，并读取servlet注册信息。
然后，将每个应用中注册的servlet类都进行加载，
并通过反射的方式实例化。
（有时候也是在第一次请求时实例化）
在servlet注册时加上
<load-on-startup>1</load-on-startup>
如果为正数，则在一开始就实例化，
如果不写或为负数，则第一次请求实例化。