<!--
 * @Author: 孙浩然
 * @Date: 2021-08-12 10:06:25
 * @LastEditors: 孙浩然
 * @LastEditTime: 2021-08-13 14:06:26
 * @FilePath: /4.interview/12.android.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
-->

# 1.Activity-----简介。

## 1-1:Activity是什么？

Activity实际上只是一个与用户交互的接口而已。

## 1-2:四大组件以及应用场景

1. 一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。
2. 一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。
  比如说一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，
  应该会有多个activity，让使用者可以选择歌曲并播放歌曲。
  音乐重放这个功能并没有对应的activity，因为使用者当然会认为在导航到其它屏幕时音乐应该还在播放的。
  媒体播放器这个activity 会使用Context.startService()来启动一个service，
  从而可以在后台保持音乐的播放。同时，系统也将保持这个service 一直执行，直到这个service 运行结束。
3. Content Provider主要用于多个应用间数据共享。这些数据可以存储在文件系统中或SQLite数据库
4. BroadcastReceiver，应用可以使用它对外部事件进行过滤只对感兴趣的外部事件
   如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。
   然而，它们可以启动一个activity或serice 来响应它们收到的信息。

## 1-3:如何统计Activity的工作时间？

Activity开始工作的起点是onResume()而工作的停止点为onPause(),
因此当每次Activity调用onResume()的时候记录一个时间a，
每次调用onPause()的时候再记录一个时间b,那么由b-a可得当次Activity工作的时间。

## 1-4:了解哪些Activity常用的标记位Flags

1.Intent.FLAG_ACTIVITY_NEW_TASK，是为Activity指定“singleTask”启动模式
2.Intent.FLAG_ACTIVITY_SINGLE_TOP，是为Activity指定“singleTop”启动模式
3.FLAG_ACTIVITY_CLEAR_TOP，如果跟singleTask启动模式一起出现，
                           如果被启动的Activity已经存在实例，则onNewIntent方法会被回调，
                           如果被启动的Activity采用standard模式启动，
                           那么连同它跟它之上的Activity都要出栈，并且创建新的实例放入栈顶。
4.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，新的Activity不会在最近启动的Activity的列表中保存。
                                      等同于指定属性android:excludeFromRecents="true"

# 2.Activity-----生命周期。

## 2-1：Activity每个生命周期函数

1. onCreate():
 表示Activity正在被创建，这是Activity生命周期的第一个方法。
 通常我们程序员要在此函数中做初始化的工作，比如：绑定布局，控件，初始化数据等。

2. onStart():
 表示Activity正在被启动，这时候的Activity已经被创建好了，
 完全过了准备阶段，但是没有出现在前台，需要执行onResume()函数才可以进入到前台与用户进行交互。

3. onResume():
 表示Activitiy已经可见了，并且Activity处于运行状态，
 也就是Activity不止出现在了前台，而且还可以让用户点击，滑动等等操作与它进行交互。

4. onPause():
 表示Activity正在暂停，大多数情况下，Activity执行完onPause()函数后会继续执行onStop()函数，造成这种函数调用的原因是当前的Activity启动了另外一个Activity或者回切到上一个Activity。还有一种情况就是onPause()函数被单独执行了，并没有附带执行onStop()方法，造成这种函数调用的原因很简单，就是当前Activity里启动了类似于对话框的东东。

5. onStop():
 表示Activity即将停止，我们程序员应该在此函数中做一些不那么耗时的轻量级回收操作。

6. onRestart():
 表示Activity正在重新启动。一般情况下，一个存在于后台不可见的Activity变为可见状态，
 都会去执行onRestart()函数，然后会继续执行onStart()函数，onResume()函数出现在前台并且处于运行状态。

7. onDestory():
 表示Activity要被销毁了。这是Activity生命中的最后一个阶段，
 我们可以在onDestory()函数中做一些回收工作和资源释放等，比如：广播接收器的注销等。

### 2-1-1:什么时候Activity单独走onPause()不走onStop()？

活动B是透明的或者说，activity的主题是dialog的时候

### 2-1-2:什么时候Activity不执行onDestory()

栈里面的第一个没有销毁的activity会执行ondestroy方法，其他的不会执行。

比如说：从mainactivity跳转到activity-A
（或者继续从activity-A再跳转到activity-B），
这时候，从后台强杀，只会执行mainactivity的onDestroy方法，
activity-A（以及activity-B）的onDestroy方法都不会执行,对了，只有说当前应用为焦点应用时才是这样的，
但是呢，如果切换到后台去了，当前此应用不再是焦点应用，如果再强杀该应用，
那么栈中所有的Activity都会执行onDestory

### 2-1-3:onRestart的调用场景

（ 1） 按下 home 键之后， 然后切换回来， 会调用 onRestart()。
（ 2） 从本 Activity 跳转到另一个 Activity 之后， 按 back 键返回原来 Activity， 会
       调用 onRestart()；
（ 3） 从本 Activity 切换到其他的应用， 然后再从其他应用切换回来， 会调用
       onRestart()；

## 2-2：正常生命周期

1. 启动了一个Activity,通常是Intent来完成。启动一个Activity首先要执行的回调函数是onCreate(),
   通常需要在这里完成绑定布局，绑定控件，初始化数据等做一些初始化的工作。

2. 执行Activity的onStart()函数，执行之后Activity已经可见，但是还没有出现在前台，无法与用户进行交互。
   这个时候通常Activity已经在后台准备好了

3. 即将执行Activity的onResume()函数，执行之后Activity不止可见而且还会出现在前台，可以与用户进行交互
   由于Activity执行了onResume()函数，所以Activity出现在了前台。也就是Activity处于运行状态。

4. 如果说一旦启动一个新的activity或者说返回其他的activity,处于运行状态的Activity即将执行onPause()函数，

5. Activity即将执行onStop()函数，当Activity要从前台切换至后台的时候会执行，比如：用户点击了返回键，或者用户切换至其他  
   Activity等。

6. 当前的Activity执行onDestory()函数，表示着这个Activity即将终结，
   这也是生命周期中的最后一次回调生命周期，
   我们可以在onDestory()函数中，进行一些回收工作和资源的释放工作，比如：广播接收器的注销工作等。

7. 执行完onDestory()方法的Activity接下来面对的是被GC回收，宣告生命结束。

8. 当用户在其他的Activity或者桌面回切到这个Activity时，这个Activity就会先去执行onRestart()函数，
   然后接下来执行onStart()函数，接着执行onResume()函数进入到运行状态。

![avatar](https://blog.csdn.net/clandellen/article/details/79257489)

## 2-3：异常生命周期

比如说：情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建。
或者说，情况2：资源内存不足导致低优先级的Activity被杀死。

第一种情况下，系统配置发生改变，Activity会被销毁，其onPause,OnStop,onDestory函数均会被调用，
            同时由于Actiivty是在异常情况下终止的，系统会调用onSaveInstanceState来保存当前Activity状态。
            调用onSaveInstanceState的时机总会发生在onStop之前，
            至于会不会调用时机发生在onPause方法之前，这个就不好说了，
            我认为在正常情况下一般onSaveInstanceState不会被调用。
            当Activity被重新创建后，系统会调用onRestoreInstanceState,
            并且把Actiivty销毁时onSaveInstanceState方法所保存的Bundle对象作为参数
            传递给onRestoreInstanceState和onCreate方法。
            所以我们可以通过onRestoreInstanceState和onCreate方法来判断Actiivty是否被重建了，
            如果被重建了，那么我们就可以取出之前保存的数据并恢复，
            从时序上来看，onRestoreInstanceState的调用时机发生在onStart之后。
            同时，在onSaveInstanceState和onRestoreInstanceState方法中，
            系统自动为我们做了一定的恢复工作。当Activity在异常情况下需要重新创建时，
            系统会默认为我们保存当前Activity的视图结构。
            当Activity在异常情况下需要重新创建时，
            系统会默认为我们保存当前Activity的视图结构，
            并且在Activity重启后为我们恢复这些数据，
            比如：文本框中用户输入的数据,ListView滚动的位置等，
            这些View相关的状态系统都能够默认为我们恢复。
            具体针对某一个特定的View系统 能为我们恢复哪些数据。

第二种情况下，当内存严重不足时，系统就会按照规定好的优先级去kill掉目前Activity所在的进程，
            并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数据。
            如果一个进程中没有四大组件的执行，那么这个进程将很快被系统杀死，
            因此，一些后台工作不适合脱离四大组件独立运行在后台中，
            这样进程更容易被杀死。
            比较好的方法就是将后台工作放入Service中从而保证进程有一定的优先级，
            这样就不会轻易地被系统杀死。

### 2-3-1：数据如何保存和恢复

首先Activity被意外终止时，Activity会调用onSaveInstanceState去保存数据，
然后Activity会委托Window去保存数据，接着Window在委托它上面的顶级容器去保存数据。
顶级容器是一个ViewGroup，一般来说它很可能是DecorView。
最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。

### 2-3-2：系统配置改变后，有没有办法不重新创建

可以给Activity指定configChanges属性。

比如我们不想让Actiivty在屏幕旋转的时候重新创建，就可以给configChanges属性添加一些值，

### 2-3-3：Activity优先级问题

优先级最高： 与用户正在进行交互的Activity，即前台Activity。
优先级中等：可见但非前台的Activity,比如：一个弹出对话框的Activity,可见但是非前台运行。
优先级最低：完全存在与后台的Activity,比如：执行了onStop。

## 2-4：特殊生命周期

Activity的横竖屏切换

如果说不设置属性configChanges的时候

刚刚启动Activity的时候：onCreate---》onStart---》onResume

由竖屏切换到横屏：onPause---》onSaveInstanceState //这里可以用来横竖屏切换的保存数据
               ---》onStop---》onDestroy---》onCreateonStart
               ---》onRestoreInstanceState//这里可以用来横竖屏切换的恢复数据---》onResume

横屏切换到竖屏：onPause---》onSaveInstanceState---》onStoponDestroy---》
             onCreate---》onStart---》onRestoreInstanceState---》onResume

如果说设置了属性

刚刚启动Activity的时候：onCreate---》onStart---》onResume

由竖屏切换到横屏：什么也没有调用
由横屏切换到竖屏：什么也没有调用

## 2-5：生命周期案例分析

### 2-5-1:从ActivityA--》B之后再点击back之后

从Activity A跳转到Activity B
Activity A --> onPause()
Activity B --> onCreate()
Activity B --> onStart()
Activity B --> onResume()
Activity A --> onStop()
然后在Activity B点击back键
Activity B --> onPause()
Activity A --> onRestart()
Activity A --> onStart()
Activity A --> onResume()
Activity B --> onStop()
Activity B --> onDestory()

### 2-5-2:Activity弹出一个Dialog

并不影响 Activity 的生命周期，
所以这时和正常启动时 Activity 的生命回调方法一致:
onCreate() -> onStart() -> onResume()

### 2-5-3:前台切换到后台，然后在回到前台

如果从a--b的话，
A调用 onCreate() 方法 -> onStart() 方法 -> onResume() 方法，此时 A 前台可见。
当 A 跳转到 B 时，A 调用 onPause() 方法，
然后调用新的 Activity B 中的 onCreate() 方法 -> onStart() 方法 -> onResume() 方法。
最后 A 再调用onStop()方法。当 A 再次回到时前台，B 调用 onPause() 方法，
A 调用 onRestart() -> onStart() -> onResume() 方法，然后 B 再调用 onStop() -> onDestroy()方法。

### 2-5-4:下拉状态栏

是不走任何生命周期的。

#### 2-5-4-1:为什么不走生命周期

想要引起activity生命周期的变化，必须要有一个activity的参与才可以，
系统的通知栏不是一个activity

#### 2-5-4-2:既然不走生命周期方法，开发中怎么监听到用户下拉通知栏呢？

可以通过重写onWindowFocusChanged这个方法来监听通知栏的下拉，false为下拉。

### 2-5-5:活动B透明

1.当Activity B 覆盖A导致A完全不可见时：
两个活动的生命周期变化为：

//【1】部署程序
D/MainActivity: onCreate------A
D/MainActivity: onStart-------A
D/MainActivity: onResume------A

//【2】点击A中的按钮开始跳转到B
D/MainActivity: onPause-------A
D/SecondActivity: onCreate----B
D/SecondActivity: onStart-----B
D/SecondActivity: onResume----B
D/MainActivity: onStop--------A

//【3】然后点击返回键从B返回A
D/SecondActivity: onPause-----B
D/MainActivity: onRestart-----A
                onStart-------A
D/MainActivity: onResume------A
D/SecondActivity: onStop------B
D/SecondActivity: onDestroy---B

2.当Activity B背景被设置为透明（相当于发生跳转后，A部分可见）
它们的生命周期的变化为：

//【1】部署程序
D/MainActivity: onCreate------A
D/MainActivity: onStart-------A
D/MainActivity: onResume------A

//【2】点击A中的按钮开始跳转到B
D/MainActivity: onPause-------A
D/SecondActivity: onCreate----B
D/SecondActivity: onStart-----B
D/SecondActivity: onResume----B

//【3】然后点击返回键从B返回A
D/SecondActivity: onPause-----B
D/MainActivity: onResume------A
D/SecondActivity: onStop------B
D/SecondActivity: onDestroy---B

### 2-5-6:内存不足

onPaused、onstoped回因为内存不足强行结束

### 2-5-7:如果没有办法跳转到另一个activity，会怎么启动

如果是非activity跳转到activity，
比如在recyclerview控件的每个view的点击事件中，
因为是自定义的Adapter，则需要定义一个运行上下文来启动页面跳转

### 2-5-8:两个Activity之间跳转时必然会执行的是哪几个方法？

前一个 Activity 的 onPause， 后一个 Activity 的 onResume

## 2-6:Activity与Fragment的生命周期比较

1. 与 Activity 生命周期协调一致
   片段所在的 Activity 的生命周期会直接影响片段的生命周期，
   Activity 的每次生命周期回调都会引发每个片段的类似回调。
   例如，当 Activity 收到 onPause() 时，Activity 中的每个片段也会收到 onPause()。

2. 当Activity包含一个Fragment的时候，Activity和Fragment生命周期的变化：
   Activity（onCreate）---> Fragment（onAttach onCreate onCreateView onActivityCreate）--->
   Activity（onStart）---> Fragment（onStart）--->
   Activity（onResume）---> Fragment（onResume）--->
   Fragment（onPause）---> Activity（onPause）--->
   Fragment（onStop）---> Activity（onStop）--->
   Fragment（onDestroyView onDestroy onDetach）---> Activity（onDestroy）
   由于Fragment依附于Activity，所以启动的时候Activity的方法肯定在前面，
   Fragment的方法在后面，但是在要销毁的时候，Fragment的方法先执行，再执行Activity的方法。

   在宿主Activity中使用hide、show方式切换Fragment的时候，Fragment的生命周期是：
   a 初始化
   Fragment1（onAttach onCreate onCreateView onActivityCreate） --->  Fragment1（onStart）---> Fragment1（onResume）
   Fragment2（onAttach onCreate onCreateView onActivityCreate） --->  Fragment2（onStart）---> Fragment2（onResume）
   b Fragment1和Fragment2来回切换都没有回调生命周期
   c 当某一个Fragment调用了跳转到另一个Activity的时候(或者按HOME键的时候)
   Fragment1（onPause）---> Fragment1（onStop）
   Fragment2（onPause）---> Fragment2（onStop）
   d 当在一个透明的Activity中弹出一个Dialog时（与Activity的情况相同）
   Fragment1（onPause）
   Fragment2（onPause）
   e 当宿主Activity被销毁的时候
   Fragment1（onPause）---> Fragment1（onStop）---> Fragment1（onDestroyView onDestroy onDetach）
   Fragment2（onPause）---> Fragment2（onStop）---> Fragment2（onDestroyView onDestroy onDetach）

# 3.Activity-----activity与进程。

## 3-1:进程等级与activity关系
  
前台>可见>服务>后台>空

  前台：与当前用户正在交互的Activity所在的进程。

  可见：Activity可见但是没有在前台所在的进程。

  服务：Activity在后台开启了Service服务所在的进程。

  后台：Activity完全处于后台所在的进程。

  空：没有任何Activity存在的进程，优先级也是最低的。

# 5.Activity-----启动模式。

## 5-1:给我说说Activity的启动模式

一共四种模式

1. 系统默认的启动模式:Standard
  不管这个实例是否存在，每次启动一个Activity都会重新创建一个新的实例。
  在这种模式下，谁启动了这个Activity,那么这个Activity就运行在启动它的那个Activity的任务栈中。
  比如Activity A启动了Activity B(B是标准模式)，那么B就会进入到A所在的任务栈中。
  
2. 栈顶复用模式：SingleTop
  如果说新的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，
  同时它的onNewIntent方法被回调，通过此方法的参数我们可以取出当前请求的信息。
  但是这个Activity的onCreate,onStart不会被系统调用，因为它并没有发生改变。
  如果新的Activity已经存在但不是位于栈顶，那么新的Activity仍然会重新重建。

3. 栈内复用模式：SingTask
  只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，
  比如Activity A，系统首先寻找任务栈中是否已存在Activity A的实例，
  如果已经存在，那么系统就会把A调到栈顶并调用它的onNewIntent方法，
  如果Activity A实例不存在，就创建A的实例并把A压入栈中。举几个栗子： 

4. 单实例模式：SingleInstance
  Activity只能单独位于一个任务栈中，
  比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，
  然后A独自在这个新的任务栈中，由于栈内复用的特性，
  后续的请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了。

### 5-1-1:Activity为什么需要启动模式？
  
因为每次启动一个Activity就会把对应的要启动的Activity的实例放入任务栈中，
假如这个Activity会被频繁启动，会生成很多这个Activity的实例吗
对内存而言这可不是什么好事，现在我想要可以一个Activity实例就可以应付所有的启动需求，
杜绝这种内存的浪费行为，所以Activity的启动模式就被创造出来去解决上面所描述的问题。

### 5-1-2:如何选择合适的启动模式？


### 5-1-3:a->b->c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？

此种模式的Activity只能单独位于一个任务栈中，
换句话说，比如Activity A是singleInstance模式，
当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，
由于栈内复用的特性，后续的请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了。

### 5-1-4:启动模式使用场景？

1. standard
   邮件、mainfest中没有配置就是默认的标准模式

2. singleTop
   登陆页面，推送通知栏

3. singleTask适合作为程序入口点。例如浏览器的主界面。
   不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
   还有webview页面、扫一扫页面

4. singleInstance适合需要与程序分离开的页面。
   例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，
   如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。

### 5-1-5:Activity任务栈是什么？

它是用来存储Activity实例的一种数据结构

## 5-2:隐式启动和显示启动Activity的方式？

显示启动：直接告诉Android的kernel，要启动哪个activity！在启动同一应用程序时占优！效率会高很多！

隐式启动：不直接告诉Android的kernel启动哪个activity，要让Android的kernel自己选择最适合的activity！

## 5-3:activity初始化/加载过程

1.CI.startActivity()：将调用交给 Instrumentation 
(负责监控 Activity 和 AMS 的交互，所有 Activity 的本地进程到远端进程的调用转换都是其来执行)，

2.Instrumentation.execStartActivity()：传入一个 APT 然后通过 Binder 
机制将调用过程转移到(后称AMS)所AMS 在的系统服务进程，
本地主线程则继续运行，不过本地主线程后续也没别的操作了。
接下来就是本地的MessageQueue 等待 AMS 服务运行完毕，发送消息将 Activity 
的启动重新交给本地主线程。

3.AMS.startActivity()：从这里开始会调用会按顺序在 ActivityStarter、
ActivityStackSupervisor、ActivityStack 这三个类之间进行调用，主要会进行下面这些操作，不按顺序：

      1.对 Intent 的内容进行解析，获取目标 Activity 的信息。
      2.根据传入的 APT 获取被调用 App 的信息封装成 PR。
      3.将1、2和其他信息结合，将源 Activity 和目标 Activity 封装成两个 AR
      4.解析 Activity 的启动模式 和当前的 Activity 栈状态，判断是否需要创建栈和 Activity 。

      5.获取到 Activity 和 Activity 栈之后，接下来要判断是否要将当前 Activity 
      执行 onPause() 以及让使用Binder 执行目标 Activity 的 onCreate() 
      和 onResume
      这里 AMS 进程会使用 APT 调用 App 进程的 Activity 执行相应的生命周期。
      6.在 AMS 中前置准备一切就绪之后，会通过 APT 使用 Handler 的形式调用到 App 进程的 AT 中。
      7.最终到了ActivityStackSupervisor.realStartActivityLocked()中会
      使用 APT 将调用交给 App 进程——>AT.scheduleLaunchActivity()——>AT.handleLaunchActivity()
4.AT.handleLaunchActivity()：将有以下操作

   1.AT.performLaunchActivity：这个方法有以下操作
         1.创建对象LA(一个 App 只加载一次)
         2.创建对象 Activity
         3.创建对象 App lication(一个 App ，只创建一次)
         4.**创建对象 CI **：CI.createActivityContext()
         5.Application、CI都 attach 到 Activity 对象：Activity.attach()
         6.执行 onCreate()：Instrumentation.callActivityOnCreate()——>Activity.performCreate()——>Activity.onCreate()
         7.执行onStart()：AT.performLaunchActivity——>Activity.performStart()——>Instrumentation.callActivityOnStart()——>Activity.onStart()
   2.AT.handleResumeActivity()
         1.AT.performResumeActivity()——>Activity.performResume()——>Instrumentation.callActivityOnResume()——>Activity.onResume()
         2.Activity.makeVisible()——>WindowManager.addView()：开始进行View的绘制流程。
         3.从上面我们可以总结一下：在 AMS 将调用交给 App 进程之后，三个生命周期都是在 App 进程被回调的，并且在 onResume() 之后View才进行绘制

# 6.Activity-----启动流程。

## 6-1:Activity的启动流程(从源码角度解析)？

app 启动的过程有两种情况， 第一种是从桌面 launcher 上点击相应的应用图标， 第二种是在
activity 中通过调用 startActivity 来启动一个新的 activity。
我们创建一个新的项目， 默认的根 activity 都是 MainActivity， 而所有的 activity 都是保存在
堆栈中的， 我们启动一个新的 activity 就会放在上一个 activity 上面， 而我们从桌面点击应用
图标的时候， 由于 launcher 本身也是一个应用， 当我们点击图标的时候， 系统就会调用
startActivitySately(),一般情况下， 我们所启动的 activity 的相关信息都会保存在 intent 中， 比
如 action ， category 等 等 。 我 们 在 安 装 这 个 应 用 的 时 候 ， 系 统 也 会 启 动 一 个
PackaManagerService 的管理服务， 这个管理服务会对 AndroidManifest.xml 文件进行解析，
从而得到应用程序中的相关信息， 比如 service， activity， Broadcast 等等， 然后获得相关组
件的信息。 当我们点击应用图标的时候， 就会调用 startActivitySately()方法， 而这个方法内
部则是调用 startActivty(),而 startActivity()方法最终还是会调用 startActivityForResult()这个方
法。 而在 startActivityForResult()这个方法。 因为 startActivityForResult()方法是有返回结果的，
所以系统就直接给一个-1， 就表示不需要结果返回了。 而 startActivityForResult()这个方法实
际是通过 Instrumentation 类中的 execStartActivity()方法来启动 activity， 
Instrumentation 这个类主要作用就是监控程序和系统之间的交互。 而在这个 execStartActivity()方法中会获取
ActivityManagerService 的代理对象， 通过这个代理对象进行启动 activity。 启动会就会调用一
个 checkStartActivityResult()方法， 如果说没有在配置清单中配置有这个组件， 就会在这个方
法中抛出异常了。 当然最后是调用的是 Application.scheduleLaunchActivity()进行启动 activity，
而这个方法中通过获取得到一个 ActivityClientRecord 对象， 而这个 ActivityClientRecord 通过
handler 来进行消息的发送， 系统内部会将每一个 activity 组件使用 ActivityClientRecord 对象
来进行描述， 而 ActivityClientRecord 对象中保存有一个 LoaderApk 对象， 通过这个对象调用
handleLaunchActivity 来启动 activity 组件， 而页面的生命周期方法也就是在这个方法中进行
调用。

## 6-2：如何在任意位置关掉应用所有Activity & 如何在任意位置关掉指定的Activity？

封装一个类,成员变量有一个List集合，当Activity执行onCreate()方法时将当前的Activity实例加入，
当Activity执行onDestory()方法时，移除当前Activity实例即可，
如何关闭应用所有的Activity,答案就是遍历这个List且逐一调用finish()方法即可，
至于如何在任意位置关闭当前的Activity,这里需要考虑给每个启动的Activity一个tag,
根据这个tag和集合可达到在任意位置关闭指定Activity的效果。

# 7.Activity-----通信。

## 7-1：Activity之间如何通信

1. Intent/Bundle
2. 类静态变量，只能适用于少量数据通信
3. 全局变量

### 7-1-1:Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？

使用bundle的话，假定说，我现在要从A界面跳转到B界面或者C界面

这样的话 我就需要写2个Intent如果你还要涉及的传值的话
你的Intent就要写两遍添加值的方法 那么 如果我用1个Bundle直接把值先存里边
然后再存到Intent中，这样更加简洁

使用intent的话， Android中提供了Intent机制来协助应用间的交互与通讯，
或者是说，Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的交互。

因为之前看过，bundle内部有一个ArrayMap，

首先ArrayMap适合于小数据量操作，如果在数据量比较大的情况下，它的性能将退化。
HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。
而在Activity中我们使用Bundle的场景大多数为小数据量。所以使用ArrayMap实现更合适。
其次Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，
Bundle使用Parcelable进行序列化，
而HashMap则是使用Serializable进行序列化。
在Android中Parcelable比Serializable性能要高。

## 7-2：Activity和Service之间通信

1. Intent，我们在启动和停止Service时所调用的方法都需要传入一个Intent实例对象，
   通过这个传入的Intent对象，我们就可以与Service进行通信。
2. CallBack + Handler,监听服务的进程变化
3. 绑定服务的方式，利用ServiceConnection这个接口

## 7-3:Activity和Fragment之间通信

1. 直接进行方法调用
   在Activity里通过Fragment的引用，可以直接调用Framgent中的定义的任何方法
2. Bundle
   在创建Fragment实例的时候，调用方法setArguments将一个Bundle对象传递给Fragment，
   然后在Fragment中先去判断是否和当前Activity绑定上了，
   如果绑定上了，就可以拿出这个Bundle中的数据


# 8.Activity-----四种状态。

Active/Paused/Stopped/Killed

Activie:当前 Activity 正处于运行状态，指的是当前 Activity 获取了焦点。

Paused： 当前 Activity 正处于暂停状态，指的是当前 Activity 失去焦点，此时的 Activity
并没有被销毁，内存里面的成员变量，状态信息等仍然存在，当然这个 Activity 也仍然可
见，但是焦点却不在它身上，比如被一个对话框形式的 Activity 获取了焦点，或者被一个
透明的 Activity 获取了焦点，这都能导致当前的 Activity 处于 paused 状态。

Stopped:与 paused 状态相似， stopped 状态的 Activity 是完全不可见的，但是内存里
面的成员变量，状态信息等仍然存在，但是也没有被销毁。

Killed:已经被销毁的 Activity 才处于 killed 状态，它的内存里面的成员变量，状态信息等
都会被一并回收。

# 9.Activity-----scheme 跳转协议。

Android 中的 scheme 是一种页面内跳转协议，通过自定义 scheme 协议，可以非常方便
的跳转到 app 中的各个页面，通过 scheme 协议，服务器可以定制化告诉 app 跳转到哪
个页面，可以通过通知栏消息定制化跳转页面，可以通过 H5 页面跳转到相应页面等等

# 10.Activity-----恢复/保存以前的状态。

如果系统由于系统约束（而不是正常的应用程序行为） 而破坏了 Activity， 那么
尽管实际 Activity 实例已经消失， 但是系统还是会记住它已经存在， 这样如果用
户导航回到它， 系统会创建一个新的实例的 Activity 使用一组保存的数据来描述
Activity 在被销毁时的状态。 系统用于恢复以前状态的已保存数据称为“实例状
态”， 是存储在 Bundle 对象中的键值对的集合。

此时就需要onSaveInstanceState()和 onRestoreInstanceState()就是这样的背景下产生的

## 10-1:恢复/保存流程

默认情况下， 系统使用 Bundle 实例状态来保存有关 View 中 Activity 布局每个对
象的信息（例如输入到 EditText 对象中的文本值） 。
因此， 如果您的 Activity 实例被销毁并重新创建，
则布局状态会自动恢复到之前的状态。 但是， 您的 Activity
可能包含更多要恢复的状态信息， 例如跟踪 Activity 中用户进度的成员变量。
为了让您为 Activity 添加额外的数据到已保存的实例状态， Activity 生命周期中还
有一个额外的回调方法， 这些回调方法在前面的课程中没有显示。 该方法是
onSaveInstanceState()， 系统在用户离开 Activity 时调用它。 当系统调用此方法时，
它将传递 Bundle 将在您的 Activity 意外销毁的事件中保存的对象， 以便您可以向
其中添加其他信息。 然后， 如果系统在被销毁之后必须重新创建 Activity 实例，
它会将相同的 Bundle 对象传递给您的 Activity 的 onRestoreInstanceState()方法以
及您的 onCreate() 方法

## 10-2:保存Activity状态

当 Activity 开始停止时， 系统会调用， onSaveInstanceState()以便您的 Activity
可以使用一组键值对来保存状态信息。 此方法的默认实现保存有关 Activity 视图
层次结构状态的信息， 例如 EditText 小部件中的文本或 ListView 的滚动位置。
为了保存 Activity 的附加状态信息， 您必须实现 onSaveInstanceState()并向对象添
加键值对 Bundle。

## 10-3:恢复activity状态

当您的 Activity 在之前被破坏后重新创建时， 您可以从 Bundle 系统通过您的
Activity 中恢复您的保存状态。 这两个方法 onCreate()和 onRestoreInstanceState()
回调方法都会收到 Bundle 包含实例状态信息的相同方法。
因为 onCreate()调用该方法是否系统正在创建一个新的 Activity 实例或重新创建
一个以前的实例， 所以您必须 Bundle 在尝试读取之前检查该状态是否为空。 如
果它为空， 那么系统正在创建一个 Activity 的新实例， 而不是恢复之前被销毁的
实例。

# -----------------------------------------------------------------------

# 11.Fragment---简介。

Fragment是显示在Activity中的Activity。 它可以显示在
Activity中， 然后它也可以显示出一些内容。 因为它拥有自己的生命周期， 可以接受
处理用户的事件， 并且你可以在一个Activity中动态的添加， 替换， 移除不同的
Fragment， 因此对于信息的展示具有很大的便利性。

# 12.Fragment---生命周期。

**Fragment**

界面打开

onCreate() 方法执行！----》onCreateView() 方法执行！
----》onActivityCreated() 方法执行！----》onStart() 方法执行！
----》onResume() 方法执行！

按下主屏幕键/锁屏

onPause() 方法执行！----》onStop() 方法执行！

重新打开

onStart() 方法执行！----》onResume() 方法执行！

按下后退键

onPause() 方法执行！----》onStop() 方法执行！
----》onDestroyView() 方法执行！----》onDestroy() 方法执行！
----》onDetach() 方法执行！

**在Activity中加入Fragment**

打开

Fragment onAttach()方法执行----》Fragment onCreate() 方法执行！
----》Fragment onCreateView() 方法执行！----》Fragment onViewCreated()方法执行
----》Activity onCreate() 方法执行！----》Fragment onActivityCreated() 方法执行！
----》Activity onStart() 方法执行！----》Fragment onStart() 方法执行！
----》Activity onResume() 方法执行！----》Fragment onResume() 方法执行！

按下主屏幕键/锁屏

Fragment onPause() 方法执行！
----》Activity onPause() 方法执行！
----》Fragment onStop() 方法执行！
----》Activity onStop() 方法执行！

再次打开

Activity onRestart() 方法执行！----》Activity onStart() 方法执行！
----》Fragment onStart() 方法执行！----》Activity onResume() 方法执行！
----》Fragment onResume() 方法执行！

按下后退键

Fragment onPause() 方法执行！----》Activity onPause() 方法执行！
----》Fragment onStop() 方法执行！----》Activity onStop() 方法执行！
----》Fragment onDestroyView() 方法执行！----》Fragment onDestroy() 方法执行！
----》Fragment onDetach() 方法执行！----》Activity onDestroy() 方法执行！

# 13.Fragment---懒加载。

当需要的时候才会进行加载

## 13-1:为什么需要懒加载

一般我们都会在 onCreate ( ）或者 onCreateView (）里去启动一些数据加载操作，
比如从本地加载或者从服务器加载，这样并不会出现什么问题，
但是当你使用 Viewpager + Fragment 的时候，就需要考虑了

### 13-1-1:viewpager+fragment的坑

viewpager为了让滑动的时候可以有很好的用户体验，也是为了卡顿现象的发生，它本身设计了一个缓存机制
viewpager回提前创建好当前当前fragmnet以及他周围的两个fragment，比如说1，2，3这三个fragment，都会执行
完onattach--》onresume这个过程，由于viewpager的缓存机制，这个数据已经生成了，但是呢，
万一数据很大，就需要考虑懒加载，需要哪个fragmnet，才打开哪一个。

### 13-1-x：ViewPager + Fragment结合使用会出现内存泄漏吗 & 如何解决？

会出现，
**主要原因是**一般ViewPager + Fragment结合使用出现内存泄漏的原因可能
用某个集合存储了Fragment的实例,导致当用户滑动ViewPager的时候，
某一个Fragment即将面临销毁的时候，由于这个集合持有的它的引用，
因此不能被回收掉,如果Fragment里面有大量的数据占据内存，有可能会导致OOM。

**解决方法：**尽量不要使用集合来存储Fragment实例对象，除非有完善的二次封装。
再就是要做好每一页Fragment的数据缓存问题。

# 14.Fragment---回退栈。

Fragment的回退栈是用来保存每一次Fragment事务发生的变化 如果你将
Fragment任务添加到回退栈， 当用户点击后退按钮时， 将看到上一次的保存的
Fragment。 一旦Fragment完全从后退栈中弹出， 用户再次点击后退键， 则退
出当前Activity


# 15.Fragment---通信。

## 15-1：Fragment如何和Activity进行通信 & Fragment之间如何进行通信？

1. fragmnet调用activity？
   
Fragment有个getActivity()的方法

MainActivity mainActivity = (MainActivity) getActivity();
mainActivity.methodA();

2. 在Activity中调用Fragment的方法
  
法一：直接接口回调即可调用Fragment的任何可访问的方法。

法二：在创建Fragment实例的时候，调用方法setArguments将一个Bundle对象传递给Fragment，
     然后在Fragment中先去判断是否和当前Activity绑定上了，如果绑定上了，就可以拿出这个Bundle中的数据啦。示例代码如下：

在Activity中代码是这样的：

    //首先创建一个Bundle对象
    Bundle bundle = new Bundle();
    bundle.putString("data_string","数据");
    bundle.putInt("data_int",10);
    bundle.putChar("da_char",'a');
    
    Fragment fragment = new MyFragment1();
    fragment.setArguments(bundle);

在MyFragment1中代码是这样的：

if(isAdded()){//这里判断是否Fragment和Activity进行了绑定

   Bundle bundle = getArguments();
   String data_string = bundle.getString("data_string");
   String data_int = bundle.getInt("data_int");
   String data_char = bundle.getChar("data_char");

3. 在Fragment中调用另外一个Fragment的方法
  
   1)在相应的 fragment 中编写方法， 在需要回调的 fragment 里获取对应的 Fragment 实例， 调
      用相应的方法；
    2） 采用接口回调的方式进行数据传递；
        a) 在 Fragment1中创建一个接口及接口对应的set 方法; b) 在Fragment1 中调用接口的方法；c)在 Fragment2 中实现该接口；
    3） 利用第三方开源框架 EventBus

# 16.Fragmnet---3种切换的方式。

1. add()&remove()
2. hide()&show()
3. detach()&attach()

## 16-1:三种方式有什么区别呢

1. add()&remove():就是添加和移除，因此replace()这个方法只是在上一个Fragment不再需要时采用的简便方法。
2. hide()&show():则是指隐藏和显示，这种方式防止Fragment多次创建实例对象，
                 所以正确的切换方式是add()，切换时hide()，add()
                 另一个Fragment；再次切换时，
                 只需hide()当前，show()另一个，
                 这样就能做到多个Fragment切换不重新实例化。
3. detach()&attach():使用detach()会将view从ViewTree中删除,和remove()不同,
                     此时Fragment的状态依然保持着,在使用attach()时
                     会再次调用onCreateView()来重绘视图,注意使用detach()后Fragment.
                     isAdded()方法将返回false,在使用attach()还原Fragment后isAdded()
                     会依然返回false(需要再次确认)执行detach()和replace()后要还原视图的话,
                     可以在相应的Fragment中保持相应的view,
                     并在onCreateView()方法中通过view的parent
                     的removeView()方法将view和parent的关联删除后返回,
                     这种方式极少使用

### 16-1-1：如何切换 fragement,不重新实例化

add()，切换时 hide()，add()另一个 Fragment；再次切换时，
只需 hide()当前，show()另一个。

## 16-2:使用场景

1. 通过add、hide、show方式来切换fragment
   FragmFent1的生命周期变化为：onCreate()、onCreateView()、onStart()、onResume()，然后切换时回调onHiddenChanged()方法
   Fragment2生命周期变化为：onCreate()、onCreateView()、onStart()、onResume()
   Fragment2再次返回到Fragment1：不走任何生命周期方法，但是回调onHiddenChanged()方法
   当以这种方式进行Fragment1和Fragment2切换时，Fragment隐藏的时候并不走onDestroyView()，
   所有的现实也不会走onCreateView()，所有的view都会保存在内存。

2. 使用replace()方法进行切换Fragment，Fragment都是进行了销毁、重建新Fragment的过程，相当于走了一整套的生命周期

3. 使用ViewPager方式切换Fragment
   当使用ViewPager进行Fragment切换时，所有的Fragment都会进行预加载。

# 17.Fragment---Manager。

## 17-1:getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？

getFragmentManager()所得到的是所在fragment 的父容器的管理器，
getChildFragmentManager()所得到的是在fragment   里面子容器的管理器。
getSupportFragmentManager()主要用于支持 3.0以下android系统API版本，
                           3.0以上系统可以直接调用getFragmentManager() ，
                           因为fragment是3.0以后才出现的组件，
                           为了这之前的系统版本也能使用fragment,
                           借助V4包里面的getSupportFragmentManager()方法
                           来间接获取FragmentManager()对象，
                           3.0版本之后，有了Fragment的api，
                           就可以直接使用getFragmentManager()这个方法来获取对象。


# 18.结合ViewPager使用。

## 18-1:FragmentPagerAdapter和FragmentStatePagerAdapter区别？

FragmentPagerAdapter适用于页面较少的情况，而FragmentStatePagerAdapter适用于页面较多的情况。

FragmentPagerAdapter类内的每一个生成的 Fragment 都将保存在内存之中，
                    因此适用于那些相对静态的页，数量也比较少的那种；
                    如果需要处理有很多页，并且数据动态性较大、占用内存较多的情况，
                    应该使用FragmentStatePagerAdapter
fragmentStatePagerAdapter 和前面的 FragmentPagerAdapter 一样，是继承子 PagerAdapter。
但是，和 FragmentPagerAdapter 不一样的是，该 PagerAdapter 的实现将只保留当前页面，
当页面离开视线后，就会被消除，释放其资源；而在页面需要显示时，
生成新的页面(就像 ListView 的实现一样)。
这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存

# 19.Fragmnet---app与v4包。

## 19-1:Android中v4包下Fragment和app包下Fragment的区别是什么？

1. 如果你Fragment用了app包的,FragmentManager和FragmentTransaction
   都需要是app包的
   要么用全部用app,要么全部用v4,不然可是会报错
2. v4包最低可以兼容到1.6版本


# ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～-

# 20.广播--概念。

## 20-1：广播是什么？

BroadcastReceiver 是一种全局监听器， 用来实现系统中不同组件之间的通信。 有时候也会用
来作为传输少量而且发送频率低的数据， 但是如果数据的发送频率比较高或者数量比较大就
不建议用广播接收者来接收了， 因为这样的效率很不好， 因为 BroadcastReceiver 接收数据的
开销还是比较大的。

## 20-2：广播使用场景

1. App全局监听，这种主要用于在AndroidManifest中静态注册的广播接收器，
              一般我们在收到该消息后，需要做一些相应的动作，而这些动作与当前App的组件，
              比如Activity或者Service的是否运行无关，比如我们在集成第三方Push SDK时，
              一般都会添加一个静态注册的BroadcastReceiver来监听Push消息，当有Push消息过来时，
              会在后台做一些网络请求或者发送通知等等。

2. 组件局部监听，这种主要是在Activity或者Service中使用registerReceiver()动态注册的广播接收器，
               因为当我们收到一些特定的消息，比如网络连接发生变化时，
               我们可能需要在当前Activity页面给用户一些UI上的提示，
               或者将Service中的网络请求任务暂停。
               所以这种动态注册的广播接收器适合特定组件的特定消息处理。

## 20-3：为什么引入广播机制

a. android 的四大组件本质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，
它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便
几大组件的信息和数据交互。
b. 程序间互通消息(例如在自己的应用程序内监听系统来电)
c. 效率上(参考 UDP 的广播协议在局域网的方便性)
d. 设计模式上(反转控制的一种应用，类似监听者模式)

## 20-4：广播 BroadcastReceiver 的理解

BroadcastReceiver 是一种全局监听器， 用来实现系统中不同组件之间的通信。 有时候也会用
来作为传输少量而且发送频率低的数据， 但是如果数据的发送频率比较高或者数量比较大就
不建议用广播接收者来接收了， 因为这样的效率很不好， 因为 BroadcastReceiver 接收数据的
开销还是比较大的。


# 21.广播----广播接收器的生命周期。

a. 广播接收者的生命周期非常短暂的，在接收到广播的时候创建，
onReceive()方法结束之后销毁；
b. 广播接收者中不要做一些耗时的工作，否则会弹出 Application No
Response 错误对话框；
c. 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被
销毁后进程就成为了空进程，很容易被系统杀掉；
d. 耗时的较长的工作最好放在服务中完成；

# 22.初始化

1.当收到广播时会调用AT.handleReceiver()

2.创建对象LA(一个 App 只加载一次)

3.创建对象BroadcastReceiver

4.创建对象 Application

5.从创建的 Application中获取 CI

6.执行 onReceive() 回调

5.Application初始化：
当 App 还没启动的时候唤醒任意组件都会创建一个 Application，

# 22.广播---分类。

1. 标准广播：通过context. sendBroadcast或者context. sendBroadcastAsUser
           发送给当前系统中所有注册的接受者，也就是只要注册了就会接收到。
           应用在需要通知各个广播接收者的情况下使用，如开机启动。

2. 有序广播：接收者按照优先级处理广播，
           并且前面处理广播的接受者可以中止广播的传递，
           一般通过context. sendOrderedBroadcast或者context.sendOrderedBroadcastAsUser，
           在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。

3. 本地广播：发出的广播只能在应用程序内部进行传递，广播接收器也只能接受来自本应用程序的广播。

4. 全局广播：系统和广播，发出的广播可以被其他任何应用程序接收到，并且也可以接受到其他任何应用程序的广播。

5. 粘性广播：可以发送给以后注册的接受者，意思是系统会将前面的粘性广播保存在AMS中，
           一旦注册了与以保存的粘性广播符合的广播，在注册结束后会立即收到广播，
           一般通过context. sendStickyBroadcast或context.sendStickyOrderedBroadcast来发送，

## 22-1:本地广播和全局广播有什么差别？

引入本地广播的机制是为了解决安全性的问题：

1） 正在发送的广播不会脱离应用程序，比用担心 app 的数据泄露；
2） 其他的程序无法发送到我的应用程序内部，不担心安全漏洞。（比如：如何做一个杀
不死的服务---监听火的 app 比如微信、友盟、极光的广播，来启动自己。）
3） 发送本地广播比发送全局的广播高效。（全局广播要维护的广播集合表 效率更低。
全局广播，意味着可以跨进程，就需要底层的支持。）
本地广播不能用静态注册。----静态注册：可以做到程序停止后还能监听。


## 22-2:系统广播和本地广播的原理

a.自定义广播接收者BroadcastReceiver,并且重写onReceiver()方法。
b.通过Binder机制向AMS(Activity Manager Service)进行注册。
c.广播发送者通过Binder机制向AMS发送广播。
d.AMS查找符合条件(IntentFilter/Permission等)的BroadcastReceiver，
  将广播发送到相应的BroadcastReceiver(一般情况下是Activity)的消息队列中。
e.消息循环执行拿到此广播，回调BroadcastReceiver中的onReceiver()方法。

本地广播
  a.使用它发送的广播将只在自身app内传播，因此你不必担心泄漏隐私的数据。
  b.其他app无法对你的app发送该广播，因此你的app根本不可能收到非自身app发送的该广播，因此你不必担心有安全漏洞可以利用。
  c.比系统广播更加高效。

### 22-2-1:本地广播的特点

a.LocalBroadcast高效的原因：因为它内部是通过Handler实现的，
                          它的sendBroadcast()方法含义并非和系统的sendBroadcast()一样，
                          它的sendBroadcast()方法其实就是通过Handler发送了一个Message而已。
b.LocalBroadcast安全的原因：既然它是通过Handler实现广播发送的，
                           那么相比系统广播通过Binder机制实现那肯定更加高效，
                           同时使用Handler来实现，别的app无法向我们应用发送该广播，
                           而我们app内部发送的广播也不会离开我们的app。
LocalBroadcast内部协作主要是靠两个Map集合：mReceivers和mActions,
             还有一个List集合mPendingBroadcasts,这个主要存储待接收的广播对象。

# 23.广播的注册方式有哪些。

1. 静态注册
   静态注册的广播接收者就是一个常驻在系统中的全局监听器， 也就是说
   如果你应用中配置了一个静态的 BroadcastReceiver， 而且你安装了应用而无论应用是否处于
   运行状态， 广播接收者都是已经常驻在系统中了

2. 动态注册
   动态注册的广播接收者只有执行了 registerReceiver(receiver, filter)才会开始监听
   广播消息， 并对广播消息作为相应的处理。

## 23-1:什么时候使用动态注册/静态注册

第一种是静态注册， 也可成为常驻型广播， 这种广播需要在 Androidmanifest.xml 中进行注册，
这中方式注册的广播， 不受页面生命周期的影响， 即使退出了页面， 也可以收到广播这种广
播一般用于想**开机自启动**啊等等， 由于这种注册的方式的广播是常驻型广播， 所以会占用
CPU 的资源。
第二种是动态注册， 而动态注册的话， 是在代码中注册的， 这种注册方式也叫非常驻型广播，
收到生命周期的影响， 退出页面后， 就不会收到广播， 我们通常运用在**更新 UI 方面**。 这种
注册方式优先级较高。 最后需要解绑， 否会会内存泄露

# 24.广播的应用场景。

## 24-1:有两个应用注册了一样的广播，一个是静态，一个是动态，连优先级也一样，那么当广播从系统发出来后，哪个应用先接收到广播？

动态注册的接收者会先执行

# ----------------------------------------------------------------------------------------

# 25.ContentProvider-概念。

## 25-1.什么是内容提供者？

主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，
允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。
使用内容提供者是Android实现跨程序共享数据的标准方式。

## 25-2.如何创建自己应用的内容提供者 & 使用场景

1. 可以新建一个类去继承ContentProvider类的方式来创建一个自己的内容提供器。
   ContentProvider类有6个抽象方法，我们在使用子类继承它的时候，
   需要将这6个方法全部重写。新建MyProvider继承字ContentProvider类，

## 25-3.ContentProvider,ContentResolver,ContentObserver之间的关系

1. ContentProvider 实现各个应用程序间数据共享， 用来提供内容给别的应用操作。 如联系人应
用中就使用了 ContentProvider， 可以在自己应用中读取和修改联系人信息， 不过需要获取相
应的权限。 它也只是一个中间件， 真正的数据源是文件或 SQLite 等。
2. ContentResolver 内 容 解 析 者 ， 用 于 获 取 内 容 提 供 者 提 供 的 数 据 ， 通 过
ContentResolver.notifyChange(uri)发出消息
3. ContentObserver 内容监听者， 可以监听数据的改变状态， 观察特定 Uri 引起的数据库变化，
继而做一些相应的处理， 类似于数据库中的触发器， 当 ContentObserver 所观察的 Uri 发生
变化时， 便会触发它。

## 25-4.说说ContentProvider的权限管理

对于ContentProvider暴露出来的数据，应该是存储在自己应用内存中的数据，

对于一些存储在外部存储器上的数据，并不能限制访问权限，使用ContentProvider就没有意义了。

对于ContentProvider而言，有很多权限控制，

可以在AndroidManifest.xml文件中对节点的属性进行配置，一般使用如下一些属性设置：

android:grantUriPermssions:临时许可标志。

android:permission:Provider读写权限。

android:readPermission:Provider的读权限。

android:writePermission:Provider的写权限。

android:enabled:标记允许系统启动Provider。

android:exported:标记允许其他应用程序使用这个Provider。

android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。

# 26.ContentProvider---原理。

## 26-1:原理

这可以认为是一种进程间通信的方式，其实它原理核心就是Binder。

## 26-2:启动过程

1. 当一个应用启动时，入口方法是ActivityThread的main方法，
   其中创建ActivityThread的实例并创建主线程的消息队列；
2. ActivityThread的attach方法中会远程
   调用ActivityManagerService的attachApplication，
   并将ApplicationThread提供给AMS，
   ApplicationThread主要用于ActivityThread和AMS之间的通信；
3. ActivityManagerService的attachApplication
   会调用ApplicationThread的bindApplication方法，
   这个方法会通过H切换到ActivityThread中去执行，
   即调用handleBindApplication方法；
4. handleBindApplication方法会
   创建Application对象并加载ContentProvider，
   先加载ContentProvider，然后调用Application的onCreate方法。

# 27.ContentProvider-通信。

ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义
一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等
方法。因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册。
把自己的数据通过 uri 的形式共享出去，android 系统下 不同程序 数据默认
是不能共享访问，需要去实现一个类去继承 ContentProvider

## 27-1:为什么要用 ContentProvider？它和 sql 的实现上有什么差别

ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只
需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间
共享。
Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而
ContentProvider 还可以去增删改查本地文件. xml 文件的读取等

# 28.初始化

1.AT.main()——>AT.attach()——>AMS.attach App lication()：传入一个 APT，调用转到了 AMS 进程
2.AMS.attachApplicationLocked()：获取到 ApplicationInfo 和 ProviderInfo 列表之后通过 APT 将调用转回 App 进程。
3.APT.bindApplication()——>AT.handleBindApplication()——>AT.installContentProviders()：到这里之后将会循环初始化 ContentProvider。
4.AT.installProvider()：这个方法里面有以下操作
   1.创建对象LA：CI.createPackageContext()中
   2.创建对象CI：CI.createPackageContext()中
   3.创建对象ContentProvider：ClassLoader创建
   4.CI attach到ContentProvider对象：ContentProvider.attachInfo()中
   5.执行onCreate回调：ContentProvider.attachInfo()中


# ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～

# 28.Service--概念。

## 28-1:什么是Service?

Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的组件。
它运行于UI线程，因此不能进行耗时的操作。

### 28-1-1:Service和Thread的区别

1. Thread 是程序执行的最小单元，可以用 Thread 来执行一些异步的操作。
   Service 是android的一种机制，当它运行的时候如果是Local Service，
   那么对应的 Service 是运行在主进程的 main 线程上的。
   如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。
2. Thread 的运行是独立的，也就是说当一个 Activity 被 finish 之后，
   如果没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，
   Thread 也会一直执行。当 Activity 被 finish 之后，不再持有该 Thread 的引用，也就是不能再控制该Thread。
   另一方面，没有办法在不同的 Activity 中对同一 Thread 进行控制。
   Service 可以在任何有 Context 的地方调用 Context.startService、
   Context.stopService、Context.bindService、
   Context.unbindService来控制它，
   也可以在 Service 里注册 BroadcastReceiver，
   通过发送 broadcast 来达到控制的目的，
   这些都是 Thread 做不到的。

#### 28-1-1-1:Service和Thread到底有什么关系呢

Service和Thread之间没有任何关系,

## 28-2:Service是否在mainthread中执行service里面是否能执行耗时的操作

默认情况,如果没有显示的指 servic 所运行的进程, Service 和 activity 是运
行在当前 app 所在进程的 main thread(UI 主线程)里面。
service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )
特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让 service 在另
外的进程中执行

## 28-3:Service使用场景

## 28-4:Service与线程池优缺点

1. Service的优点是系统原生支持，使用方便；创建进程方便；
   可以提供给系统内其他App使用；优先级高，当App退到后台后不宜被杀死。
   缺点是由于启动Service涉及到多次IPC，运行效率不高，而且受限于系统接口，使用不够灵活。

2. 线程池的优点是运行效率高，配置和使用灵活。缺点是多进程实现不方便，
   由于Android实现了一套进程托管机制，
   我们不能直接创建一个新的进程，而只能通过四大组件的形式创建新的进程。

## 28-5:Service 和 Activity 在同一个线程吗

对于同一 app 来说默认情况下是在同一个线程中的

## 28-6:Service 里面可以弹toast

可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就
是 Context 的子类，因此在 Service 里面弹吐司是完全可以的。比如我们在
Service 中完成下载任务后可以弹一个吐司通知用户。


# 29.Service---生命周期。

服务的生命周期有两种，因为服务可以跟Activity绑定起来，也可以不绑定，
Activity和服务进行通信的话，是需要把服务和Activity进行绑定的。
因此服务的生命周期分为未绑定Activity的和绑定Activity的。

通 过 startService() 这 种 方 式 启 动 的 service ， 生 命 周 期 是： 调 用 startService() -->
onCreate()--> onStartConmon()--> onDestroy()。 这种方式启动的话， 需要注意一下几个问题，
第一： 当我们通过 startService 被调用以后， 多次在调用 startService(),onCreate()方法也只会
被调用一次， 而 onStartConmon()会被多次调用当我们调用 stopService()的时候， onDestroy()
就会被调用， 从而销毁服务。 第二： 当我们通过 startService 启动时候， 通过 intent 传值，
在 onStartConmon()方法中获取值的时候， 一定要先判断 intent 是否为 null。
通 过 bindService() 方 式 进 行 绑 定 ， 这 种 方 式 绑 定 service ， 生 命 周 期 走 法 ：
bindService-->onCreate()-->onBind()-->unBind()-->onDestroy() bingservice 这种方式进行启动
service 好处是更加便利 activity 中操作 service， 比如加入 service 中有几个方法， a,b ， 如果
要在 activity 中调用， 在需要在 activity 获取 ServiceConnection 对象， 通过 ServiceConnection
来获取 service 中内部类的类对象， 然后通过这个类对象就可以调用类中的方法， 当然这个
类需要继承 Binder 对象

## 29-1:onstartConmand()可不可以执行网络操作

可以直接在 Service 中执行网络操作,在 onStartCommand()方法中可以执行网
络操作

## 29-2:如何保证 Service 不被杀死 ？

o onStartCommand 方式中，返回 START_STICKY 或则START_REDELIVER_INTENT
 START_STICKY：如果返回 START_STICKY，表示
Service 运行的进程被 Android 系统强制杀掉之
后， Android 系统会将该 Service 依然设置为
started 状态（即运行状态），但是不再保存
onStartCommand 方法传入的 intent 对象
 START_NOT_STICKY：如果返回 START_NOT_STICKY，
表示当 Service 运行的进程被 Android 系统强制杀
掉之后，不会重新创建该 Service
 START_REDELIVER_INTENT：如果返回
START_REDELIVER_INTENT，其返回情况与
START_STICKY 类似，但不同的是系统会保留最后一
次传入 onStartCommand 方法中的 Intent 再次保留下来并再次传入到重新创建后的 Service 的
onStartCommand 方法中

o 提高 Service 的优先级 在 AndroidManifest.xml 文件中对
于 intent-filter 可以通过 android:priority = "1000"这
个属性设置最高优先级， 1000 是最高值，如果数字越小则
优先级越低，同时适用于广播；

o 在 onDestroy 方法里重启 Service 当 service 走到
onDestroy()时，发送一个自定义广播，当收到广播时，重
新启动 service；

o 提升 Service 进程的优先级 进程优先级由高到低：前台进
程 一 可视进程 一 服务进程 一 后台进程 一 空进程 可以使
用 startForeground 将 service 放到前台状态，这样低内
存时，被杀死的概率会低一些；

o 系统广播监听 Service 状态

o 将 APK 安装到/system/app，变身为系统级应用

## 29-3:能否在 Service 开启耗时操作 ？ 怎么做 ？

Service 默认并不会运行在子线程中，也不运行在一个独
立的进程中，它同样执行在主线程中（ UI 线程）。换句话
说，不要在 Service 里执行耗时操作，除非手动打开一个
子线程，否则有可能出现主线程被阻塞（ ANR）的情况；

# 30.service---IntentService。

IntentService 是 Service 的子类，比普通的 Service 增加了额外的功能。
由于service存在问题，主要是
Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进
程中；
Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的
任务

所以，intentservice会创建独立的 worker 线程来处理所有的 Intent 请求；
会创建独立的 worker 线程来处理 onHandleIntent()方法实现的代码，无需
处理多线程问题；
所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法
停止 Service；
为 Service 的 onBind()提供默认实现，返回 null；
为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列中；

## 30-1：Activity、Intent、Service 是什么关系

他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是
Android 四大组件之一。他俩都是 Context 类的子类 ContextWrapper 的子类，
因此他俩可以算是兄弟关系吧。不过兄弟俩各有各自的本领，Activity 负责用户
界面的显示和交互，Service 负责后台任务的处理。Activity 和 Service 之间可
以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者

## 30-2:IntentService与Service的区别

从属性 & 作用上来说 Service： 依赖于应用程序的主线程（ 不是独立的进程 or
线程）

IntentService： 创建一个工作线程来处理多线程任务

Service需要主动调用stopSelft()来结束服务， 而IntentService不需要（ 在所有
intent被处理完后， 系统会自动关闭服务）

## 30-3:IntentService与其他线程的区别

IntentService内部采用了HandlerThread实现， 作用类似于后台线程；
与后台线程相比， IntentService是一种后台服务， 优势是： 优先级高（ 不容易
被系统杀死） ， 从而保证任务的执行。


# 31.Service---通信.

1） 通过 bindService 启动服务， 可以在 ServiceConnection 的 onServiceConnected 中获取到
Service 的实例， 这样就可以调用 service 的方法， 如果 service 想调用 activity 的方法， 可以
在 service 中定义接口类及相应的 set 方法， 在 activity 中实现相应的接口， 这样 service 就可
以回调接口言法；
2） 通过广播方式

## 31-1:Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service

Activity 通过 bindService(Intent service, ServiceConnection conn, int
flags)跟 Service 进行绑定，当绑定成功的时候 Service 会将代理对象通过回调
的形式传给 conn，这样我们就拿到了 Service 提供的服务代理对象。
在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一
般情况下如果想获取 Service 的服务对象那么肯定需要通过 bindService（）方
法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么
可以使用 startService（）方法。

## 31-2:service 和 activity 怎么进行数据交互？

1） 通过 bindService 启动服务， 可以在 ServiceConnection 的 onServiceConnected 中获取到
Service 的实例， 这样就可以调用 service 的方法， 如果 service 想调用 activity 的方法， 可以
在 service 中定义接口类及相应的 set 方法， 在 activity 中实现相应的接口， 这样 service 就可
以回调接口言法；
2） 通过广播方式

# 32.service---初始化

1.CI.startService()——>CI.startServiceCommon()：
在这里传入一个 APT，类似 Activity 启动时的第二步，
将调用过程转移到 AMS 中，本地主线程继续运行，等待 APT 从 AMS 进程将调用转移到本地主线程中。
2.AMS.startService()：到了 AMS 进程之后，Service 的启动就会全权交给 AS(这是 AMS 用来管理 Service 的成员变量)
3.AS.startServiceLocked()：这里做了以下操作
   1.根据传入的 APT 获取被调用 App 的信息封装成 PR
   2.解析 Intent 等参数获取到 Service 的信息，封装成 SR(这个类可以看做是 Service 在系统服务的化身，记录了 Service 的一切信息)
   3.再进过一系列调用：AS.startServiceInnerLocked()——>
      AS.bringUpServiceLocked()——>AS.realStartServiceLocked() 到这里才是真正在 App 进程启动 Service 的流程。
   4.AS.realStartServiceLocked()：这里会有以下操作：
1.SR.APT.scheduleCreateService()：这里会将调用转到 App 进程，但是当前的进程还会继续执行，这里就到了 App 线程的APT，这个方法里有以下操作
      1.通过 Handler 转到 AT.handleCreateService()
      2.创建对象 LA(一个 App 只加载一次)
      3.创建对象 Service
      4.创建对象 CI
      5.创建对象 Application(一个 App 只创建一次)
      6.Application、CI分别 attach 到 Service 对象
      7.执行 Service.onCreate() 回调
      8.此时 Service 已经启动了
2.AS.sendServiceArgsLocked()——>SR. App.APT.scheduleServiceArgs()：这里就转到了 App 进程的 APT 中，这里会有以下操作：
      1.APT.scheduleServiceArgs()
      2.AT.handleServiceArgs()
      3.Service.onStartCommand()
      4.此时我们需要在 Service 中进行的操作将会执行。

# -------------------------------------------------------------------------------

# 32.Handler---子线程UI

## 32-1.子线程一定不能更新UI吗？

不一定，

1.在Activity的onResume()生命周期函数之前是可以在子线程中更新UI的。
2.SurfaceView：多媒体视频播放，也可以在子线程中更新UI
3.Progress：进度相关控件，也可以在子线程中更新UI

## 24-2:为什么系统不建议在子线程访问UI？

Android的UI访问是没有加锁的，多个线程可以同时访问更新操作同一个UI控件。
也就是说访问UI的时候，android系统当中的控件都不是线程安全的，
这将导致在多线程模式下，当多个线程共同访问更新操作同一个UI控件时容易发生不可控的错误，
而这是致命的。所以Android中规定只能在UI线程中访问UI，
这相当于从另一个角度给Android的UI访问加上锁，一个伪锁。

## 24-3:为什么要设计只能通过Handler机制更新UI呢？

最根本的目的就是解决多线程并发问题。
假如在一个Activity当中，有多个线程去更新UI，并且都没有加锁机制，回出现更新界面错乱。
如果对更新UI的操作都进行加锁处理的话又会产生也会产生性能下降。
出于对以上问题的考虑，android给我们提供了一套更新UI的机制，我们只需要遵循这样的机制就行了，
而根本不用去关心多线程问题，所有的更新UI的操作，都是在主线程的消息队列当中去轮询处理的。


## 24-4：为什么使用异步消息处理的方式就可以对 UI进行操作了呢？

这是由于 Handler 总是依附于创建时所在的线程，比如我们的
Handler 是在主线程中创建的，而在子线程中又无法直接对 UI 进行操作，于是
我们就通过一系列的发送消息、入队、出队等环节，最后调用到了 Handler 的
handleMessage()方法中，这时的 handleMessage()方法已经是在主线程中运
行的，因而我们当然可以在这里进行 UI 操作了。

## 24-5:Android中更新UI的几种方式：

runOnUIThread
handler post 
handler sendMessage
view post

## 24-6： 子线程中能不能 new handler？为什么？

不 能 , 如 果 在 子 线 程 中 直 接 new Handler() 会 抛 出 异 常

在没有调用 Looper.prepare()的时候不能创建 Handler,因为在创建
Handler 的源码中做了抛出异常的判断


# 25.Handler---原理

## 25-1:什么是handler

Handler通常被我们用来做主线程与子线程之间的通信工具，
可以说只要有异步线程与主线程通信的地方就一定会有 Handler。

## 25-2:Handler的工作机制

首先在UI线程我们创建了一个Handler实例对象，
无论是匿名内部类还是自定义类生成的Handler实例对象，
我们都需要对handleMessage方法进行重写，
在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，
接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，
并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，
然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，
之后这个消息会被存放于MessageQueue中等待被处理，
此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，
通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，
最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。

比如说想刷新主界面的TextView，无奈不在主线程，
此时你就会包装好Message，然后声明一个Handler，
让Handler将你的Message送往主线程（Looper），
Handler将你的Message送到主线程后，还需要排队等待，
等轮到你的时候，主线程就会告诉Handler，这个Message可以处理了，
你负责分发一下，于是，Handler将该Message分发到相应的回调或者handleMessage( ) 方法中，
于是，你就在该方法中更新了UI。


## 25-3：消息机制的模型

消息机制主要包含：MessageQueue，Handler和Looper这三大部分，以及Message，
下面我们一一介绍。
Message ：需要传递的消息，可以传递数据；
MessageQueue ：消息队列，但是它的内部实现并不是用的队列，实际上是通过
一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优
势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池
的消息(MessageQueue.next)；
Handler ：消息辅助类，主要功能向消息池发送各种消息事件
(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)；
Looper ：不断循环执行(Looper.loop)，从 MessageQueue 中读取消息，按分发机
制将消息分发给目标处理者。

### 25-3-1：MessageQueue，Handler和Looper三者之间的关系

每个线程中只能存在一个Looper，Looper 是保存在 ThreadLocal 中的。主线程（UI 线程）已经创建了一
个 Looper，所以在主线程中不需要再创建 Looper，但是在其他线程中需要创建
Looper。每个线程中可以有多个 Handler，即一个 Looper 可以处理来自多个
Handler 的消息。 Looper 中维护一个 MessageQueue，来维护消息队列，消息队
列中的 Message 可以来自不同的 Handler。

## 25-4:handler有什么作用？

更新UI
发送消息
处理消息

## 25-5:为什么使用handler，MessageQueue，Looper？

主线程无法进行时间比较繁长的任务，所以需要子线程进行处理，
然而子线程无法进行UI的界面更新，所以我们需要使用handler来传递消息给主线程，
让其完成UI的更新。由于主线程和子线程进行不同的时间工作，
所要需要用MessageQueue来存放子线程的消息，Looper取出消息交给主线程响应。

### 25-5-1：创建Message实例的最佳方式

1. 通过 Message 的静态方法 Message.obtain(); 获取；
2. 通过 Handler 的公有方法 handler.obtainMessage(); 。

### 25-5-2：Looper机制的作用

1. 将 Runnable post 到主线程执行；
2. 利用 Looper 判断当前线程是否是主线程。

# 26.handler---内存泄漏

## 26-1:Handler导致的内存泄露你是如何解决的？


Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该
Activity 会泄露。
这个泄露是因为 Message 会持有 Handler，而又因为 Java  的特性，内部类会
持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。
解决该问题的最有效的方法是：将 将 Handler  定义成静态的内部类，在内部持有
Activity 

解决方法：将Handler类声明为静态，如果Handler需要
        访问外部类Activity的成员变量或者成员方法， Activity.onDestroy() 前移除消息，加一层保障：
        可以用弱引用的方式解决。

## 26-2：为什么我们能在主线程直接使用Handler，而不需要创建Looper 

因为在 ActivityThread 里 里 了 调用了 Looper.prepareMainLooper()  方法创建
了 了 的 主线程的 Looper ,了 并且调用了 loop()  方法，所以我们就可以直接使用
Handler 了。

## 26-3：Handler里藏着的Callback能干什么

有利 优先处理消息的权利 ，当一条消息被 Callback 处
理回 并拦截（返回 true ），那么 Handler 的 handleMessage(msg) 方法就不会被
调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着 一个消息
被 可以同时被 Callback 及 以及 Handler  处理

我们可以利用 Callback 截 这个拦截机制来拦截 Handler  的消息！
场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是
个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。

# 27.handler---通信

## 27-1:如何使用Handler让子线程和子线程通信？

假定说两个线程a、b
让ThreadB往ThreadA中发送消息，首先你得在ThreadA中准备一个Looper，
也就是消息轮询大管家，然后准备发送消息的Handler，准备发送消息的Handler很容易理解，
那就是在ThreadA中生成一个Handler对象即可，
那么准备Looper怎么做呢？在ThreadA中调用Looper.prepare()，
然后再调用Looper.loop()即可

# 28.handler---HandlerThread

## 28-1:HandlerThread是什么

开启子线程进行耗时操作，多次创建和销毁子线程是很耗费资源的，
谷歌考虑了这点为我们专门开发出了HandlerThread机制

## 28-2:handlerThread特点？

a.HandlerThread本质上是一个线程类，它继承了Thread。

  b.HandlerThread有自己内部的Looper对象，可以进行Looper循环。

  c.通过获取HandlerThread的Looper对象传递给Handler对象，可以在handlerMessage方法中执行异步任务。

  d.优点是不会有堵塞，减少对性能的消耗，缺点是不能进行多任务的处理，需要等待进行处理，处理效率较低。

  e.与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。

# 29.handler---IdleHandler

## 29-1:IdleHandler是什么 

IdleHandler 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（
譬如 UI 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容的情况下

# 31.IPC---概念

## 31-1:Android多进程开发的认识？

如果一个进程占用内存超过了这个内存限制，就会报OOM的问题，
很多涉及到大图片的频繁操作或者需要读取一大段数据在内存中使用时，
很容易报OOM的问题。为了彻底地解决应用内存的问题，
Android引入了多进程的概念，它允许在同一个应用内，
为了分担主进程的压力，将占用内存的某些页面单独开一个进程，
比如Flash、视频播放页面，频繁绘制的页面等。

## 31-2.Android中进程间通信的方式有哪些？

在AndroidManifest.xml中声明组件时，用android:process属性来指定。

不知定process属性，则默认运行在主进程中，主进程名字为包名。

android:process = package:remote，将运行在package:remote进程中，属于全局进程，其他具有相同shareUID与签名的APP可以跑在这个进程中。

android:process = :remote ，将运行在默认包名:remote进程中，而且是APP的私有进程，不允许其他APP的组件来访问。

## 31-3:多进程引发的问题（为什么引入多进程通信）

静态成员和单例失效：每个进程保持各自的静态成员和单例，相互独立。

线程同步机制失效：每个进程有自己的线程锁。

SharedPreferences可靠性下降：不支持并发写，会出现脏数据。

Application多次创建：不同进程跑在不同虚拟机，每个虚拟机启动会创建自己的Application，自定义Application时生命周期会混乱。

不同进程拥有各自独立的虚拟机，Application，内存空间，由此引发一系列问题。

### 31-3-1；如何解决？

1)针对Application的多次重建：

在Application的onCreate中获取进程Id来判断不同进程，然后做不同的事情。

```java
@Override
public void onCreate() {
super.onCreate();
//获取进程Id
int pid = android.os.Process.myPid();
Log.e("m_tag", "MyApplication onCreate pid is " + pid); //根据进程id获取进程名称
String pName = getProcessName(this,pid);
if("com.xyy.processtest".equals(pName)){
//处理该进程的业务
```
2)针对静态成员的失效：
   使用Intent或者aidl等进程通讯方式传递内容，不能用静态或单例模式。
3)针对文件共享问题：
   多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。
   这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。
   在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，
   虽然有文件锁、排队等机制，但是在Android里很难实现。
   解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，
   就可以考虑调用主进程进行数据库的操作。
4）针对断点调试问题：
   调试就是跟踪程序运行过程中的堆栈信息，由于每个进程都有自己独立的内存空间和各自的堆栈，
   无法实现在不同的进程间调试。因此要改为同一进程：调试时去掉AndroidManifest.xml中android:process标签，
   这样保证调试状态下是在同一进程中，堆栈信息是连贯的。待调试完成后，再将标签复原。

## 31-4:多进程的好处

（1）分担主进程的内存压力。
    当应用越做越大，内存越来越多，将一些独立的组件放到不同的进程，
    它就不占用主进程的内存空间了。当然还有其他好处，有心人会发现

（2）使应用常驻后台，防止主进程被杀守护进程，守护进程和主进程之间相互监视，有一方被杀就重新启动它。
     Android后台进程里有很多应用是多个进程的，因为它们要常驻后台，特别是即时通讯或者社交应用，不过现在多进程已经被用烂了。
     典型用法是在启动一个不可见的轻量级私有进程，在后台收发消息，或者做一些耗时的事情，或者开机启动这个进程，然后做监听等。

#坏处：消耗用户的电量。
            多占用了系统的空间，若所有应用都这样占用，系统内存很容易占满而导致卡顿。
            应用程序架构会变得复杂，因为要处理多进程之间的通信。这里又是另外一个问题了。

# 32.IPC---进程间通信

1. 系统实现。
2. AIDL（Android接口定义语言）：
   大部分应用程序不应该使用AIDL去创建一个绑定服务，
   因为它需要多线程能力，并可能导致一个更复杂的实现。
3. Messenger：利用Handler实现。（适用于多进程、单线程，不需要考虑线程安全），其底层基于AIDL。

# 33.IPC----AIDL

## 33-1:什么是AIDL

什么是AIDL: AIDL允许定义一个编程的接口来作为客户端和服务端通信的桥梁，
AIDL定义了客户端和服务端的编程标准，
在Android里边一个进程无法直接访问另一个进程的内存信息，但是要访问的话，
我们就需要把他们的设备分解成操作系统能认识的基本数据类型。
使用AIDL必须要跨进程，所以通讯起来非常耗内存和系统资源，
因此，没有必要处处用AIDL，那么什么时候用AIDL呢，通过IPC机制不同的程序访问你的服务，
并且服务要处理多线程的时候才有必要使用AIDL，
如果你只是想通过IPC机制要不同的程序访问你的服务的时候，
实现Binder就可以了；如果只想通过IPC机制，
但是不想控制多线程，实现Messanger就可以了，
Binder和Messanger都是在单线程中完成的。

## 33-2:如何创建AIDL

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# 34.View绘制机制---绘制流程

## 34-1.View绘制流程

当 Activity 接收到焦点的时候， 它会被请求绘制布局,该请求由 Android
framework 处理.绘制是从根节点开始， 对布局树进行 measure 和 draw。 整个
View 树的绘图流程在 ViewRoot.java 类的 performTraversals()函数展开， 该函数
所做 的工作可简单概况为是否需要重新计算视图大小(measure)、 是否需要重新
安置视图的位置(layout)、 以及是否需要重绘(draw)

## 34-2:view概念

1.Measure：测量View的大小

对整个View树进行递归，通过View中measure()方法，来计算View的大小；
如果有ViewGroup，需要重写 onMeasure()来遍历计算其中每个子View的大小；

2.Layout：确定View在父容器中的位置

调用View的layout()方法来设置其坐标，
其中起作用的是：setFrame()设置子View在父视图的坐标轴和 onLayout()设置布局；

3.Draw：将View绘制出来

调用draw()绘制View树,并不是每次绘制都会重新绘制每个View树的视图，
而只绘制需要重新绘制的视图，可根据View类内部变量的标志位DRAWN来决定是否重新绘制；
当有包含该标志位时就需要重新绘制。

# 35.View绘制机制---view树结构

## 35-1:说说Activity View树结构

一个Activity里最外层包含PhoneWindow,而PhoneWindow里包含DecorView,
然后DecorView里包含有TitleView和ContentView,

## 35-2:几个类的解释

1. PhoneWindows:它继承于Window类，是Window类的具体实现，
   即我们可以通过该类具体去绘制窗口。
   并且，该类内部包含了一个DecorView对象，
   该DectorView对象是所有应用窗口(Activity界面)的根View。 
   简而言之，PhoneWindow类是把一个FrameLayout类即DecorView对象进行一定的包装，
   将它作为应用窗口的根View，并提供一组通用的窗口操作接口。

2. DecorView:是PhoneWindow类的内部类（后面版本将DecorView拿出来了）。
   该类是一个FrameLayout的子类，并且是PhoneWindow的子类，
   该类就是对普通的FrameLayout进行功能的扩展，
   可以说是修饰(Decor的英文全称是Decoration，即“修饰”的意思)，
   比如说添加TitleBar(标题栏)，以及TitleBar上的滚动条等 。
   它是所有应用窗口的根View 。

## 35-3:DecorView主要功能

1. 作为PhoneWindow与ViewRoot之间的桥梁，ViewRoot通过DecorView设置窗口属性。
   可以这样获取 View：view = getWindow().getDecorView();

2. DecorView只有一个子元素为LinearLayout。代表整个Window界面，
   包含通知栏，标题栏，内容显示栏三块区域。DecorView里面TitleView：标题，
   可以设置requestWindowFeature(Window.FEATURE_NO_TITLE)取消掉,ContentView：
   是一个id为content的FrameLayout。
   我们平常在Activity使用的setContentView就是设置在这里，也就是在FrameLayout上；

# 36.view绘制---自定义view

## 36-1:自定义View的方式有哪些?给我说说你之前项目中的案例

自绘控件、组合控件、以及继承控件

1. 自定义控件：

这个View上所展现的内容全部都是我们自己绘制出来的。绘制的代码是写在onDraw()方法中的

2. 组合控件

并不需要自己去绘制视图上显示的内容，而只是用系统原生的控件就好了，
但我们可以将几个系统原生的控件组合到一起，这样创建出的控件就被称为组合控件。
比如说，标题栏就是个很常见的组合控件，很多界面的头部都会放置一个标题栏，
标题栏上会有个返回按钮和标题，点击按钮后就可以返回到上一个界面。

3. 继承控件

并不需要自己重头去实现一个控件，只需要去继承一个现有的控件，
然后在这个控件上增加一些新的功能，就可以形成一个自定义的控件了。
这种自定义控件的特点就是不仅能够按照我们的需求加入相应的功能，
还可以保留原生控件的所有功能

目前在做的学习中心筛选栏的重构

## 36-2:自定义View时重写的方法

1. onMeasure
   测量本质就是测量本身有多大，
   也就是给mMeasuredWidth和mMeasuredHeight这两个属性赋值，
   也就是调用setMeasuredDimension这个方法。
   另外父view测量子view的时候调用的measure方法，
   还有一些衍生方法如measureChildWithMargins。
2. onLayout
   作用是子view应该怎样放置，
   也就是设置子view的mLeft、mTop、mRight、mBottom属性。
   该方法在View中是空实现，很显然主要用于ViewGroup。
   父view放置子view的时候调用layout方法。
3. onDraw
   具体长什么样。

## 36-3:自定义View中如何自定义属性？

1.分析需要的自定义属性
2.在项目下res/values/attrs.xml定义声明
3.在layout xml中进行使用
4.在自定义View的构造方法中进行获取

## 36-4:自定义View如何考虑机型适配？

1. 合理使用warp_content，match_parent.
2. 尽可能的是使用RelativeLayout
3. 针对不同的机型，使用不同的布局文件放在对应的目录下，android会自动匹配。
4. 尽量使用点9图片。
5. 使用与密度无关的像素单位dp，sp
6. 引入android的百分比布局。
7. 切图的时候切大分辨率的图，应用到布局当中。在小分辨率的手机上也会有很好的显示效果。

## 36-5：View绘制机制

1.ViewRootImpl 会调用 performTraversals(),其内部会调用 performMeasure()、performLayout、
performDraw()。
 2.performMeasure() 会 调 用 最 外 层 的 ViewGroup 的 measure()-->onMeasure(),ViewGroup 的
onMeasure()是抽象方法，但其提供了 measureChildren()，这之中会遍历子 View 然后循环调用
measureChild()这之中会用 getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam
一 起 获 取 本 View 的 MeasureSpec ， 然 后 调 用 子 View 的 measure() 到 View 的
onMeasure()-->setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize() 默 认 返 回
measureSpec 的测量数值，所以继承 View 进行自定义的 wrap_content 需要重写。
 3.performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本
View 的四个顶点位置。在 onLayout(抽象方法)中确定子 View 的位置，如 LinearLayout 会遍历子
View，循环调用 setChildFrame()-->子 View.layout()。
 4.performDraw()会调用最外层 ViewGroup 的 draw():其中会先后调用 background.draw()(绘制背景)、
onDraw()(绘制自己)、dispatchDraw()(绘制子 View)、onDrawScrollBars()(绘制装饰)。
 5.MeasureSpec 由 2 位 SpecMode(UNSPECIFIED、 EXACTLY(对应精确值和 match_parent)、
AT_MOST(对应 warp_content))和 30 位 SpecSize 组成一个 int,DecorView 的 MeasureSpec 由窗口大
小和其 LayoutParams 决定，其他 View 由父 View 的 MeasureSpec 和本 View 的 LayoutParams 决定。
ViewGroup 中有 getChildMeasureSpec()来获取子 View 的 MeasureSpec。
 6.三种方式获取 measure()后的宽高：
o 1.Activity#onWindowFocusChange()中调用获取
o 2.view.post(Runnable)将获取的代码投递到消息队列的尾部。
o 3.ViewTreeObservable.


# 37.View事件分发机制

## 37-1：事件分发机制

View 事件分发本质就是对 MotionEvent 事件分发的过程。
即当一个 MotionEvent 发生后，系统将这个点击事件传递
到一个具体的 View 上
o 点击事件的传递顺序： Activity （ Window ）→ViewGroup→ View
o 事件分发过程由三个方法共同完成：
   dispatchTouchEvent：用来进行事件的分发。如果
      事件能够传递给当前 View，那么此方法一定会被调
      用，返回结果受当前 View 的 onTouchEvent 和下级
      View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件
   onInterceptTouchEvent：在上述方法内部调用，对
      事件进行拦截。该方法只在 ViewGroup 中有，View
   （不包含 ViewGroup）是没有的。一旦拦截，则执
   行 ViewGroup 的 onTouchEvent，在 ViewGroup 中处
   理事件，而不接着分发给 View。且只调用一次，返
   回结果表示是否拦截当前事件
 onTouchEvent： 在 dispatchTouchEvent 方法中调
                  用，用来处理点击事件，返回结果表示是否消耗当前事件

## 37-2：如何解决View的事件冲突

o 常见开发中事件冲突的有 ScrollView 与 RecyclerView 的
滑动冲突、RecyclerView 内嵌同时滑动同一方向

o 滑动冲突的处理规则：
    对于由于外部滑动和内部滑动方向不一致导致的滑
   动冲突，可以根据滑动的方向判断谁来拦截事件。
    对于由于外部滑动方向和内部滑动方向一致导致的
   滑动冲突，可以根据业务需求，规定何时让外部
   View 拦截事件，何时由内部 View 拦截事件。
    对于上面两种情况的嵌套，相对复杂，可同样根据
   需求在业务上找到突破点。

o 滑动冲突的实现方法：
    外部拦截法：指点击事件都先经过父容器的拦截处
   理，如果父容器需要此事件就拦截，否则就不拦
   截。具体方法：需要重写父容器的
   onInterceptTouchEvent 方法，在内部做出相应的
   拦截。
    内部拦截法：指父容器不拦截任何事件，而将所有
   的事件都传递给子容器，如果子容器需要此事件就
   直接消耗，否则就交由父容器进行处理。具体方
   法：需要配合
   requestDisallowInterceptTouchEvent 方法。



## 37-2：事件分发的流程 & 你项目解决事件冲突的一些案例。

首先事件会回传给Activity的dispatchTouchEvent，然后又会传递给PhoneWindow，
紧接着再到DecorView，此时如果DecorView不拦截此次事件，那又会交由RootView去处理，
同样的如果RootView也不拦截则事件又会到ViewGroupA中，如果ViewGroupA也不拦截此次事件，
接着又会到View1，由于它是最底层View，则直接到onTouchEvent()进行处理，
如果返回true那此次事件最终就由View1给消费掉了，然后再将结果往回返回给Activity。

## 37-3.多点触摸事件平时接触过吗？如何监听用户第二个手指，第三个...？

我们可以重写 View 中的 onTouchEvent 方法，或者使用 setOnTouchListener 方法来处理触摸事件。

## 37-4：事件在哪些对象之间进行传递？

Activity、ViewGroup、View
一个点击事件产生后，传递顺序是：Activity（Window） -> ViewGroup ->
View

# 38.ViewPager---简介

## 38-1：什么是ViewPager

ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view。

1）ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。
2）ViewPager类需要一个PagerAdapter适配器类给它提供数据。
3）ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。


## 38-2：viewpager适配器

ViewPager的适配器就是PagerAdapter

它需要实现4个方法：

1. getCount()：ViewPager显示的Item个数。

2. boolean isViewFromObject(View view, Object object)：
   功能：该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key
   与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)
   返回值：如果对应的是同一个View，返回True，否则返回False。

3. Object instantiateItem(ViewGroup container, int position)：
   这个函数的实现的功能是创建指定位置的页面视图。
   适配器有责任增加即将创建的View视图到这里给定的container中，
   这是为了确保在finishUpdate(viewGroup)返回时这个已经完成
   返回值：返回一个代表新增视图页面的Object

4. void destroyItem(ViewGroup container, int position, Object object)：
   该方法实现的功能是移除一个给定位置的页面。
   适配器有责任从容器中删除这个视图。
   这是为了确保在finishUpdate(viewGroup)返回时视图能够被移除。

### 38-2-1:你了解ViewPager2吗？和ViewPager 1有哪些区别？

1. 从右到左的布局支持
2. 垂直方向
3. RecyclerView.Adapter取代PagerAdapter
4. 之前addOnPageChangeListener方法，我们需要覆盖三个方法onPageScrolled、onPageSelected、  onPageScrollStateChanged
   现在就只需要取代registerOnPageChangeCallback，就可以了
5. 更高效的notifyDataSetChanged

## 38-3:ViewPager + Fragment结合使用存在的内存泄漏的原因是什么？如何解决？

**原因:**一般ViewPager + Fragment结合使用出现内存泄漏的原因
         可能用某个集合存储了Fragment的实例,导致当用户滑动ViewPager的时候，
         某一个Fragment即将面临销毁的时候，由于这个集合持有的它的引用，
         因此不能被回收掉,如果Fragment里面有大量的数据占据内存，有可能会导致OOM。

解决方法：尽量不要使用集合来存储Fragment实例对象，除非你有良好的二次封装。再就是要做好每一页Fragment的数据缓存问题。

# 39.Binder--简介

## 1.什么是Binder？用来干什么？

Binder是一种进程间通信(IPC)的一种机制，
我觉得Binder是一个驱动，我们调用它都是通过系统来调用。

## 2.为什么单独创建了android使用的linux有那么多跨进程的机制

一般就是从性能和鲁棒性上考虑吧，

1. 出于性能上的考虑：Android是移动设备，相比于PC机的性能会有差距，
   在移动设备上进行频繁的跨进程通信本身就是一个极大的考验，
   Binder相比较于传统的socket/管道通信而言，更加高效，它在IPC时，
   只需要数据拷贝1次，而传统的socket之类的需要2次；

2. 出于安全上的考虑：传统的进程间通信对于通信双方的身份没有进行严格的验证，
   只有上层协议才会进行架构，比如说，socket通信时，IP地址是手动填写的，
   可以进行人为的伪造，而Binder支持通信双方进行身份校验，极大的保障了安全性；

3. 稳定性：Binder 基于 C|S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，
   架构清晰、职责明确又相互独立，自然稳定性更好。 共享内存虽然无需拷贝，但是控制负责，难以使用。
   从稳定性的角度讲，Binder 机制是优于内存共享的。

## Binder模型四个角色

Server，Client，ServiceManager（下面简称SMgr）以及Binder驱动

## 39-3:Binder机制

首先 Binder 驱动在内核空间创建一个数据接收缓存区；
o 接着在内核空间开辟一块内核缓存区，建立内核缓存区和
内核中数据接收缓存区之间的映射关系，以及内核中数据
接收缓存区和接收进程用户空间地址的映射关系；
o 发送方进程通过系统调用 copyfromuser() 将数据 copy 到
内核中的内核缓存区，由于内核缓存区和接收进程的用户
空间存在内存映射，因此也就相当于把数据发送到了接收
进程的用户空间，这样便完成了一次进程间的通信。

# 40.布局

## 40-1：说说Android中有哪些布局 & 特点

1. 线性布局
   1. 特点：在水平或者垂直方向上依次按照顺序来排列子元素，控件的排列顺序遵循其在布局文件中被写出的先后顺序。
   2. 适用场景：Android开发中最常见的 一种布局方式，
              值得注意的是LinearLayout中存在weight这一属性，
              在水平方向上代表列宽，在垂直方向上代表行距。一般这个值越大，
              则所占用的控件比例越大。
2. 相对布局
   1. 特点：以某一个子元素为参照物，其余子元素均按照其相对位置来完成布局。
   2. 适用场景：其属性很好的弥补了LinearLayout的缺点，在Android手机碎片化严重的今天，
              该布局是目前最推荐的一种布局方式，但也存在着一定的缺点，
              例如在修改了某一个控件的属性时，其他依赖于该控件的其他控件可能都需要修改其属性。
3. 帧布局
   1. 特点：所有的View都会放在左上角，并且后添加进去的View会覆盖之前放进去的View
   2. 适用场景：在开发中常做容器使用，用于动态添加布局对象，比如浏览单张图片这类的。
4. 表格布局
   1. 特点：每个TableLayout都是由一个或多个TableRow组成的，一个TableRow就代表TableLayout的一行。
   2. 适用场景：适用于多行多列的表格形式。需要注意的是，行和列的下标是从0开始的。
5. 约束布局
   可视化方式编写布局

## 40-2:布局文件到控件对象的过程

## 40-3：一个文本控件放在屏幕一半的一半的中间位置，你如何进行布局？
这里实际是在筛选你是否具备Android布局相关知识点,答案有多种，可以利用线性布局和相对布局的特性即可。

## 40-4:LinearLayout,FrameLayout,RelativeLayout性能对比，为什么？

RelativeLayout 会让子 View 调用 2 次 onMeasure，
LinearLayout  在有 weight 时，也会调用子  View  2 次
onMeasure
o RelativeLayout 的子 View 如果高度和 RelativeLayout 不同，
则会引发效率问题，当子 View 很复杂时，这个问题会更加严
重。如果可以，尽量使用 padding 代替 margin。
o 在不影响层级深度的情况下,使用 LinearLayout 和
FrameLayout 而不是 RelativeLayout。


# 41.控件-----listview

## 41-1：ListView 跟 RecyclerView 的区别

o 动画区别：
    在 RecyclerView 中，内置有许多动画 API，例如：
   notifyItemChanged(),  notifyDataInserted(),
   notifyItemMoved()等等；如果需要自定义动画效果，
   可以通过实现（RecyclerView.ItemAnimator 类）完成
   自定义动画效果，然后调用
   RecyclerView.setItemAnimator()；
    但是 ListView 并没有实现动画效果，但我们可以在
   Adapter 自己实现 item 的动画效果；
o 刷新区别：
    ListView 中通常刷新数据是用全局刷新
   notifyDataSetChanged()，这样一来就会非常消耗资
   源；本身无法实现局部刷新，但是如果要在 ListView 实
   现局部刷新，依然是可以实现的，当一个 item 数据刷新
   时，我们可以在 Adapter 中，实现一个
   onItemChanged()方法，在方法里面获取到这个 item
   的 position（可以通过 getFirstVisiblePosition()），然
   后调用 getView()方法来刷新这个 item 的数据；
    RecyclerView 中可以实现局部刷新，例如：
   notifyItemChanged()；
o 缓存区别：
    RecyclerView 比 ListView 多两级缓存，支持多个离
   ItemView 缓存，支持开发者自定义缓存处理逻辑，支
   持所有 RecyclerView 共用同一个
   RecyclerViewPool(缓存池)。
    ListView 和 RecyclerView 缓存机制基本一致，但缓存
   使用不同

## 41-2：RecyclerView在很多方面能取代ListView Google为什么没把ListView划上一条过时的横线

ListView 采用的是 RecyclerBin 的回收机制在一些轻量级的 List 显示时效率更高。

## 41-3：ListView 如何提高其效率

当 convertView 为空时，用 setTag()方法为每个 View 绑定一个存放控件的
ViewHolder 对象。当 convertView 不为空，重复利用已经创建的 view 的时候，
使用 getTag()方法获取绑定的 ViewHolder 对象，这样就避免了 findViewById
对控件的层层查询，而是快速定位到控件。
   ① 复用 ConvertView，使用历史的 view，提升效率 200%
   ② 自定义静态类 ViewHolder，减少 findViewById 的次数。提
   升效率 50%
   ③ 异步加载数据，分页加载数据。
   ④ 使用 WeakRefrence 引用 ImageView 对象

## 41-4：当 ListView 数据集改变后，如何更新 ListView

使用该 ListView 的 adapter 的 notifyDataSetChanged()方法。该方法会
使 ListView 重新绘制。

## 41-5：ListView 如何实现分页加载

① 设 置 ListView 的 滚 动 监 听 器 ： setOnScrollListener(new
OnScrollListener{….})
在监听器中有两个方法： 滚动状态发生变化的方法(onScrollStateChanged)和
listView 被滚动时调用的方法(onScroll)
② 在滚动状态发生改变的方法中，有三种状态：
   手指按下移动的状态：SCROLL_STATE_TOUCH_SCROLL: // 触摸滑动
   惯性滚动（滑翔（flgin）状态）：SCROLL_STATE_FLING: // 滑翔
   静止状态： SCROLL_STATE_IDLE: // 静止
对不同的状态进行处理：
分批加载数据，只关心静止状态：关心最后一个可见的条目，如果最后一个
可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每
次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以
提示用户无更多数据了。

## 41-6：ListView 可以显示多种类型的条目吗

可以的，ListView 显示的每个条目都是通过 baseAdapter 的
getView(int position, View convertView, ViewGroup parent)来展示的，理
论上我们完全可以让每个条目都是不同类型的 view。
比如：从服务器拿回一个标识为 id=1,那么当 id=1 的时候，我们就加载类
型一的条目，当 id=2 的时候，加载类型二的条目。常见布局在资讯类客户端中
可以经常看到。
除 此 之 外 adapter 还 提 供 了 getViewTypeCount （ ） 和
getItemViewType(int position)两个方法。在 getView 方法中我们可以根据不
同的 viewtype 加载不同的布局文件。

## 41-7：ListView 中如何优化图片

①、不要直接拿路径就去循环 BitmapFactory.decodeFile;使用 Options 保存图片大小、不要加载图片到内存去。
②、对图片一定要经过边界压缩尤其是比较大的图片，如果你的图片是后台
服务器处理好的那就不需要了
③、在 ListView 中取图片时也不要直接拿个路径去取图片，而是以
WeakReference （ 使 用 WeakReference 代 替 强 引 用 。 比 如 可 以 使 用
WeakReference mContextRef）、SoftReference、WeakHashMap 等的来存
储图片信息。
④、在 getView 中做图片转换时，产生的中间变量一定及时释放

2、异步加载图片基本思想：
1）、 先从内存缓存中获取图片显示（内存缓冲）
2）、获取不到的话从 SD 卡里获取（SD 卡缓冲）
3）、都获取不到的话从网络下载图片并保存到 SD 卡同时加入内存并显示
（视情况看是否要显示）
原理：
优化一：先从内存中加载，没有则开启线程从 SD 卡或网络中获取，这里注
意从 SD 卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅。
优化二：于此同时，在 adapter 里有个 busy 变量，表示 listview 是否处于
滑动状态，如果是滑动状态则仅从内存中获取图片，没有的话无需再开启线程去
外存或网络获取图片。
优化三：ImageLoader 里的线程使用了线程池，从而避免了过多线程频繁
创建和销毁，如果每次总是 new 一个线程去执行这是非常不可取的，好一点的
用的 AsyncTask 类，其实内部也是用到了线程池。在从网络获取图片时，先是
将其保存到 sd 卡，然后再加载到内存，这么做的好处是在加载到内存时可以做
个压缩处理，以减少图片所占内存。

## 41-8：.ListView 中图片错位的问题是如何产生的

图片错位问题的本质源于我们的 listview 使用了缓存 convertView，假设一
种场景，一个 listview 一屏显示九个 item，那么在拉出第十个 item 的时候，事
实上该 item 是重复使用了第一个 item，也就是说在第一个 item 从网络中下载
图片并最终要显示的时候，其实该 item 已经不在当前显示区域内了，此时显示
的后果将可能在第十个 item 上输出图像，这就导致了图片错位的问题。所以解
决之道在于可见则显示，不可见则不显示。


## 41-9：如何刷新 ListView 中单个 item 的数据，不刷新整个
ListView 的数据？
修改单个 Item 的数据,然后调用适配器的 notifyDataSetChanged()方法

# 42.冷/热启动

## 42-1:什么是冷热启动？

1. 冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，
          这个启动方式就是冷启动。它的特点就是冷启动因为系统会重新创建一个新的进程分配给它，
          所以会先创建和初始化Application类，再创建和初始化MainActivity类
          （包括一系列的测量、布局、绘制），最后显示在界面上。

2. 热启动：当启动应用时，后台已有该应用的进程
          例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），
          所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。
          它的特点就是热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，
          而是直接走MainActivity（包括一系列的测量、布局、绘制），
          所以热启动的过程只需要创建和初始化一个MainActivity就行了，
          而不必创建和初始化Application，因为一个应用从新进程的创建到进程的销毁，
          Application只会初始化一次。

## 42-2:冷启动流程

Application构造器–>attachBaseContext()
–>OnCreate()–>Activity构造器–>onCreate
–>配置主题背景等属性–>onStart()–>onResume–>测量布局绘制显示在界面上。

### 42-2-1:冷启动优化方案

a.减少onCreate方法的工作量。
b.不要让Application参与业务逻辑。
c.不要在Application中做耗时操作。
d.不要以静态变量方式在Application中保存数据。
e.布局优化/mainThread尽量延迟初始化

# 43.内存泄漏

如果一个无用对象（ 不需要再使用的对象） 仍然被其他对象持有引用， 造成该对象无法被系统回
收， 以致该对象在堆中所占用的内存单元无法被释放而造成内存空间浪费， 这中情况就是内存泄
露。


1. 单例导致内存泄露
单例模式在 Android 开发中会经常用到， 但是如果使用不当就会导致内存泄露。 因为单例的静态
特性使得它的生命周期同应用的生命周期一样长， 如果一个对象已经没有用处了， 但是单例还持
有它的引用， 那么在整个应用程序的生命周期它都不能正常被回收， 从而导致内存泄露。

```java
public class AppSettings {
private static AppSettings sInstance;
private Context mContext;
private AppSettings(Context context) {
this.mContext = context;
} p
ublic static AppSettings getInstance(Context context) {
if (sInstance == null) {
sInstance = new AppSettings(context);
} r
eturn sInstance;
}
}
``` 
如果我们在调用 getInstance(Context context)方法的时候传入的
context 参数是 Activity、 Service 等上下文， 就会导致内存泄露。

以 Activity 为例， 当我们启动一个 Activity， 并调用 getInstance(Context context)方法去获取
AppSettings 的单例， 传入 Activity.this 作为 context， 这样 AppSettings 类的单例 sInstance 就
持有了 Activity 的引用， 当我们退出 Activity 时， 该 Activity 就没有用了， 但是因为 sIntance
作为静态单例（ 在应用程序的整个生命周期中存在） 会继续持有这个 Activity 的引用， 导致这个
Activity 对象无法被回收释放， 这就造成了内存泄露。

为了避免这样单例导致内存泄露， 我们可以将 context 参数改为全局的上下文：
```java
private AppSettings(Context context) {
this.mContext = context.getApplicationContext();
} 
```

全ju的上下文 Application Context 就是应用程序的上下文， 和单例的生命周期一样长， 这样就避
免了内存泄漏。
单例模式对应应用程序的生命周期， 所以我们在构造单例的时候尽量避免使用 Activity的上下文，
而是使用 Application 的上下文。

2. 静态变量导致内存泄露
静态变量存储在方法区， 它的生命周期从类加载开始， 到整个进程结束。 一旦静态变量初始化后，
它所持有的引用只有等到进程结束才会释放。

3. 非静态内部类导致内存泄露
非静态内部类（ 包括匿名内部类） 默认就会持有外部类的引用， 当非静态内部类对象的生命周期
比外部类对象的生命周期长时， 就会导致内存泄露。

4. 未取消注册或回调导致内存泄露比如我们在 Activity 中注册广播， 
   如果在 Activity 销毁后不取消注册， 那么这个刚播会一直存在
系统中， 同上面所说的非静态内部类一样持有 Activity 引用， 导致内存泄露。 因此注册广播后在
Activity 销毁后一定要取消注册。


5. Timer 和 TimerTask 
   导致内存泄露Timer 和 TimerTask 在 Android 
   中通常会被用来做一些计时或循环任务， 比如实现无限轮播的ViewPager


6. 集合中的对象未清理造成内存泄露
这个比较好理解， 如果一个对象放入到 ArrayList、 HashMap 等集合中， 这个集合就会持有该对象
的引用。 当我们不再需要这个对象时， 也并没有将它从集合中移除， 这样只要集合还在使用（ 而
此对象已经无用了） ， 这个对象就造成了内存泄露。 并且如果集合被静态引用的话， 集合里面那
些没有用的对象更会造成内存泄露了。 所以在使用集合时要及时将不用的对象从集合 remove， 或
者 clear 集合， 以避免内存泄漏。
7. 资源未关闭或释放导致内存泄露
在使用 IO、 File 流或者 Sqlite、 Cursor 等资源时要及时关闭。 这些资源在进行读写操作时通常都
使用了缓冲， 如果及时不关闭， 这些缓冲对象就会一直被占用而得不到释放， 以致发生内存泄露。
因此我们在不需要使用它们的时候就及时关闭， 以便缓冲能及时得到释放， 从而避免内存泄露。
8. 属性动画造成内存泄露
动画同样是一个耗时任务， 比如在 Activity 中启动了属性动画（ ObjectAnimator） ， 但是在销毁
的时候， 没有调用 cancle 方法， 虽然我们看不到动画了， 但是这个动画依然会不断地播放下去，
动画引用所在的控件， 所在的控件引用 Activity， 这就造成 Activity 无法正常释放。 因此同样要
在 Activity 销毁的时候 cancel 掉属性动画， 避免发生内存泄漏。

9. WebView 造成内存泄露
关于 WebView 的内存泄露， 因为 WebView 在加载网页后会长期占用内存而不能被释放， 因此我
们在 Activity 销毁后要调用它的 destory()方法来销毁它以释放内存。

## 42-1:避免内存泄漏

总结下来只要做到以下这几点就能避
免大多数情况的内存泄漏：
构造单例的时候尽量别用 Activity 的引用；
静态引用时注意应用对象的置空或者少用静态引用；
使用静态内部类+软引用代替非静态内部类；
及时取消广播或者观察者注册；
耗时任务、 属性动画在 Activity 销毁时记得 cancel；
文件流、 Cursor 等资源及时关闭；
Activity 销毁时 WebView 的移除和销毁。