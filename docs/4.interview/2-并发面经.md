<!-- TOC -->

- [1.线程与进程](#1线程与进程)
  - [1-1：什么是进程](#1-1什么是进程)
  - [1-2：何为线程?](#1-2何为线程)
  - [1-3：2.3.2. 线程与进程的区别](#1-3232-线程与进程的区别)
  - [进程的通信方式](#进程的通信方式)
- [什么是上下⽂切换?](#什么是上下切换)
- [2.线程死锁](#2线程死锁)
  - [2-1：什么是线程死锁](#2-1什么是线程死锁)
  - [2-2：产生死锁的条件](#2-2产生死锁的条件)
- [3.synchronized关键字](#3synchronized关键字)
  - [3-1：synchronized关键字理解](#3-1synchronized关键字理解)
  - [3-2：JDK1.6优化有哪些？](#3-2jdk16优化有哪些)
  - [说说并发与并⾏的区别?](#说说并发与并的区别)
  - [为什么要使⽤多线程呢?](#为什么要使多线程呢)
  - [使⽤多线程可能带来什么问题?](#使多线程可能带来什么问题)
  - [线程的生命周期和状态](#线程的生命周期和状态)
  - [4.3． 一般线程和守护线程的区别](#43-一般线程和守护线程的区别)
  - [多线程公共用一个数据注意什么](#多线程公共用一个数据注意什么)
- [线程通信方式](#线程通信方式)
  - [如何避免线程死锁?](#如何避免线程死锁)
  - [如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？](#如何确保-n-个线程可以访问-n-个资源同时又不导致死锁)
  - [说说 sleep() ⽅法和 wait() ⽅法区别和共同点?](#说说-sleep-法和-wait-法区别和共同点)
  - [yield join notify notifyAll](#yield-join-notify-notifyall)
  - [为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？](#为什么我们调-start-法时会执-run-法为什么我们不能直接调run-法)
  - [中断线程有很多方法：](#中断线程有很多方法)
- [ThreadLocal](#threadlocal)
  - [2.3.13 ThreadLocal](#2313-threadlocal)
  - [ThreadLocal内存泄露问题](#threadlocal内存泄露问题)
- [线程池](#线程池)
  - [为什么要用线程池](#为什么要用线程池)
  - [使⽤线程池的好处：](#使线程池的好处)
  - [实现Runnable接⼝和Callable接⼝的区别](#实现runnable接和callable接的区别)
  - [实现 Runnable 接口比继承 Thread 类所具有的优势：](#实现-runnable-接口比继承-thread-类所具有的优势)
  - [执⾏execute()⽅法和submit()⽅法的区别是什么呢？](#执execute法和submit法的区别是什么呢)
  - [如何创建线程池](#如何创建线程池)
  - [创建线程](#创建线程)
- [Atomic原子类](#atomic原子类)
  - [什么是原子类](#什么是原子类)
  - [2. JUC 包中的原⼦类是哪4类?](#2-juc-包中的原类是哪4类)
- [AQS](#aqs)
  - [什么是AQS](#什么是aqs)
  - [对AQS原理分析](#对aqs原理分析)
  - [AQS 对资源的共享⽅式](#aqs-对资源的共享式)
  - [CAS](#cas)
  - [CAS思想](#cas思想)
- [1， 公平锁与非公平锁](#1-公平锁与非公平锁)
- [11.java基础-关键字-synchronized关键字](#11java基础-关键字-synchronized关键字)
  - [10-3：说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗](#10-3说说是怎么使-synchronized-关键字在项中到了吗)
  - [10-4：synchronized关键字最主要的三种使⽤⽅式（与单例模式结合比较高）](#10-4synchronized关键字最主要的三种使式与单例模式结合比较高)
  - [10-5：synchronized 关键字底层原理](#10-5synchronized-关键字底层原理)
  - [10-6：synchronized和ReentrantLock的区别](#10-6synchronized和reentrantlock的区别)
  - [2.sychronized和lock的区别?](#2sychronized和lock的区别)
  - [synchronized用在代码块和方法上有什么区别?](#synchronized用在代码块和方法上有什么区别)
  - [synchronized与static synchronized的区别](#synchronized与static-synchronized的区别)
- [乐观锁与悲观锁](#乐观锁与悲观锁)
  - [何谓悲观锁与乐观锁](#何谓悲观锁与乐观锁)
  - [两种锁的使用场景](#两种锁的使用场景)
  - [乐观锁常见的两种实现方式](#乐观锁常见的两种实现方式)
  - [乐观锁的缺点](#乐观锁的缺点)
  - [CAS与synchronized的使用情景](#cas与synchronized的使用情景)
- [并发级别](#并发级别)
  - [11-1：volatile 关键字作用以及Java内存数据不一致](#11-1volatile-关键字作用以及java内存数据不一致)
  - [11-2：说说 synchronized 关键字和 volatile 关键字的区别](#11-2说说-synchronized-关键字和-volatile-关键字的区别)
  - [11-3：get需要加锁么，为什么？ （蚂蚁金服）](#11-3get需要加锁么为什么-蚂蚁金服)

<!-- /TOC -->


# 1.线程与进程

## 1-1：什么是进程

系统运行一个程序，从创建，运行到消亡的过程这个是一个进程

## 1-2：何为线程?

线程是进程内的一个执行单元

## 1-3：2.3.2. 线程与进程的区别

1. 拥有资源
   进程是资源分配的基本单位，虽然线程不拥有资源，线程可以访问隶属进程的资源

2. 调度
   线程是独立调度的基本单位

3. 系统开销
   创建或者撤销进程的开销大于线程的开销

4. 通信方面
   线程间可以通过读写进行通信，进程通信需要PIC

## 进程的通信方式

1. 管道

管道分为有名管道和无名管道,无名管道数据只能单向流动,而且只能在具有亲缘关系的进程间使用;有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。

2. 信号量

信号量是一个计数器,可以用来控 制多个线程对共享资源的访问.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.

3. 信号

信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.

4. 消息队列

消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.

5. 共享内存

共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.

6. 套接字：可用于不同及其间的进程通信

# 什么是上下⽂切换?

当前任务在执⾏完 CPU时间⽚ 切换到另⼀个任务 之前 会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。 任务从保存到再加载的过程就是⼀次上下⽂切换。

# 2.线程死锁

## 2-1：什么是线程死锁

多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。

## 2-2：产生死锁的条件

1. 该资源任意⼀个时刻只由⼀个线程占⽤。
2. ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
3. 线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。
4. 若⼲进程之间形成⼀种头尾相接的循环等待资源关系。



# 3.synchronized关键字

## 3-1：synchronized关键字理解

1. 解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执
   ⾏。
2. 在Java早期版本中， synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex 
   Lock 来实现的， Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，但是在JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

## 3-2：JDK1.6优化有哪些？

JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

①偏向锁

引入偏向锁的目是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。

② 轻量级锁

轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，
因为使用轻量级锁时，不需要申请互斥量。

如果没有竞争，轻量级锁使用CAS操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因
此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

③ 自旋锁和自适应自旋

一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。为了让一个线程等待，我们只需要让
线程执行一个忙循环（自旋）也就是自旋。

自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。

另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自
旋时间以及锁的拥有者的状态来决定。

④ 锁消除

指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求
锁的时间。

⑤ 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了
使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。
   






## 说说并发与并⾏的区别?
1. 并发： 同⼀时间段，多个任务都在执⾏；
2. 并⾏： 单位时间内，多个任务同时执⾏。

## 为什么要使⽤多线程呢?

1. 线程间的切换和调度的成本远远⼩于进程。减少了线程上下⽂切换的开销。
2. 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
3. 发挥多核 CPU 的优势
4. 防止阻塞

## 使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

## 线程的生命周期和状态

1、 新建状态（New） ： 新创建了一个线程对象。
2、 就绪状态（Runnable） ： 线程对象创建后， 其他线程调用了该对象的 start()方法。
该状态的线程位于可运行线程池中， 变得可运行， 等待获取 CPU 的使用权。
3、 运行状态（Running） ： 就绪状态的线程获取了 CPU， 执行程序代码。
4、 阻塞状态（Blocked） ： 阻塞状态是线程因为某种原因放弃 CPU 使用权， 暂时停止
运行。 直到线程进入就绪状态， 才有机会转到运行状态。 阻塞的情况分三种：
（一） 、 等待阻塞： 运行的线程执行 wait()方法， JVM 会把该线程放入等待池中。 (wait
会释放持有的锁)
（二） 、 同步阻塞： 运行的线程在获取对象的同步锁时， 若该同步锁被别的线程占用，
则 JVM 会把该线程放入锁池中。
（三） 、 其他阻塞： 运行的线程执行 sleep()或 join()方法， 或者发出了 I/O 请求时， JVM
会把该线程置为阻塞状态。 当 sleep()状态超时、 join()等待线程终止或者超时、 或者 I/O 处
理完毕时， 线程重新转入就绪状态。 （注意,sleep 是不会释放持有的锁）
5、 死亡状态（Dead） ： 线程执行完了或者因异常退出了 run()方法， 该线程结束生命
周期

## 4.3． 一般线程和守护线程的区别

所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程， 比如垃圾回收线程就是一个很称职的守护者， 并且这种线程并不属于程序中不可或缺的部分。 因 此，当所有的非守护线程结束时， 程序也就终止了， 同时会杀死进程中的所有守护线程。 反过来说， 只要任何非守护线程还在运行， 程序就不会终止。

区别：
为守护线程是 JVM 自动创建的线程， 用户线程是程序创建的线程； 比如 JVM的垃圾回收线程是一个守护线程， 当所有线程已经撤离， 不再产生垃圾， 守护线程自然就没事可干了， 当垃圾回收线程是 Java 虚拟机上仅剩的线程时， Java 虚拟机会自动离开。



## 多线程公共用一个数据注意什么

1. 当我们在线程对象( Runnable )中定义了全局变量, run方法会修改该变量时,如果有多个线程同时使用刻线程对象, 那么就会造成全局变量的值被同时修改,造成错误
2. ThreadLocal是JDK引入的一种机制,它用于解决线程间共享变量,使用ThreadLocal声明的变量，即使在线程中属于全局变量,针对每个线程来讲,这个变量也是独立的。
3. volatile变量每次被线程访问时,都强迫线程从主内存中重读该变量的最新值,而当该变量发生修改变化时,也会强迫线程将最新的值刷新回主内存中。这样一来 ,不同的线程都能及时的看到该变量的最新值。

# 线程通信方式
1. 同步
同步是指多个线程通过 synchronized 关键字这种方式来实现线程间的通信。
2.wait/notify 机制





## 如何避免线程死锁?

1. 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资
源需要互斥访问）。
2. 破坏请求与保持条件 ：⼀次性申请所有的资源。
3. 破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放
它占有的资源。
4. 破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破
坏循环等待条件。

## 如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？
1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测

## 说说 sleep() ⽅法和 wait() ⽅法区别和共同点?

1. sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。
2. 两者都可以暂停线程的执⾏。
3. Wait 通常被⽤于线程间交互/通信， sleep 通常被⽤于暂停执⾏。
4. wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或notifyAll() ⽅法。 sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。

## yield join notify notifyAll

1. yield()方法是停止当前线程， 让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话， 那么 yield()方法将不会起作用， 并且由可执行状态后马上又被执行。

2. join 方法是用于在某一个线程的执行过程中调用另一个线程执行， 等到被调用的线程执行结束后， 再继续执行当前线程。 如： t.join();//主要用于等待 t 线程运行结束， 若无此句，main 则会执行完毕， 导致结果不可预测。

3. notify 方法只唤醒一个等待（对象的） 线程并使该线程开始执行。 所以如果有多个线程等待一个对象， 这个方法只会唤醒其中一个线程， 选择哪个线程取决于操作系统对多线程管理的实现。

4. notifyAll 会唤醒所有等待(对象的)线程， 尽管哪一个线程将会第一个处理取决于操作系统的实现


## 为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？

new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状
态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏
run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main
线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

## 中断线程有很多方法： 
1. 使用退出标志， 使线程正常退出， 也就是当 run 方法完成后线程终止。 
2. 通过 return 退出 run 方法
3. 通过对有些状态中断抛异常退出thread.interrupt() 中断。 
4. 使用 stop 方法强行终止线程（过期）



# ThreadLocal

## 2.3.13 ThreadLocal

通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。 如果想实现每⼀个线程都有⾃⼰的专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。 ThreadLocal 类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。
如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本。他们可以使⽤ get（） 和 set（） ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。


## ThreadLocal内存泄露问题

ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。所以，如ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候， key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。 ThreadLocalMap实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null 的记录。使⽤完ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法


# 线程池

## 为什么要用线程池

池化技术的思想主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。


## 使⽤线程池的好处：

1. 降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。
2. 提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。
3. 提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。

## 实现Runnable接⼝和Callable接⼝的区别

Runnable ⾃Java 1.0以来⼀直存在，但 Callable 仅在Java 1.5中引⼊,⽬的就是为了来处理 Runnable
不⽀持的⽤例。 Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。所以，如果
任务不需要返回结果或抛出异常推荐使⽤ Runnable 接⼝，这样代码看起来会更加简洁。

## 实现 Runnable 接口比继承 Thread 类所具有的优势： 
1. 适合多个相同的程序代码的线程去处理同一个资源 
2. 可以避免 java 中的单继承的限制 
3. 增加程序的健壮性， 代码可以被多个线程共享， 代码和数据独立
4. 线程池只能放入实现 Runable 或 callable 类线程， 不能直接放入继承 Thread 的类 
5. runnable 实现线程可以对线程进行复用， 因为 runnable 是轻量级的对象， 重复 new 不会耗费太大资源， 而 Thread 则不然， 它是重量级对象， 而且线程执行完就完了， 无法再次利用


## 执⾏execute()⽅法和submit()⽅法的区别是什么呢？

1. execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；
2. submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout， TimeUnit unit） ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完。

## 如何创建线程池

⽅式⼀：通过构造⽅法实现
⽅式⼆：通过Executor 框架的⼯具类Executors来实现

## 创建线程

1. 继承 Thread 类 
2. 实现 Runnable 接口 
3. 应用程序可以使用 Executor 框架来创建线程池 
4. 实现 Callable 接口



# Atomic原子类

## 什么是原子类

指⼀个操作是不可中断的。即使是在多个线程⼀起执⾏的时
候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。

## 2. JUC 包中的原⼦类是哪4类?

1. 基本类型

2. 数组类型

3. 引⽤类型

4. 对象的属性修改类型


# AQS

## 什么是AQS

AQS是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，⽐如我们提到的ReentrantLock， Semaphore，其他的诸如ReentrantReadWriteLock， SynchronousQueue，
FutureTask等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS⾮常轻松容易地构造出符合我们⾃⼰需求的同步器。

## 对AQS原理分析

如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。

## AQS 对资源的共享⽅式

1. Exclusive（独占）：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：
   * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
   * ⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的
2. Share（共享）：多个线程可同时执⾏，如Semaphore/CountDownLatch。 Semaphore、
CountDownLatch、 CyclicBarrier、 ReadWriteLock 我们都会在后⾯讲到。


## CAS

## CAS思想

一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。

CAS中有Unsafe类中的compareAndSwapInt方法，Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于 unsafe.cpp 中

Unsafe.cpp:

先想办法拿到变量 value 在内存中的地址。
通过 Atomic::cmpxchg 实现比较替换， 其中参数 x 是即将更新的值， 参数 e 是原内存的值。
其中 Atomic::cmpxchg 中对此指令加 lock 前缀， 而 lock 前缀有两个特性 1， 禁止该指令与
前面和后面的读写指令重排序 2， 把写缓冲区的所有数据刷新到内存中
这两点保证了内存屏障效果， 保证了 CAS 同时具有 volatile 读和 volatile 写的内存语义。

# 1， 公平锁与非公平锁
公平锁和非公平锁， 顾名思义， 公平锁就是获得锁的顺序按照先到先得的原则， 从实现上说， 要求当一个线程竞争某个对象锁时， 只要这个锁的等待队列非空， 就必须把这个线程阻塞并塞入队尾（插入队尾一般通过一个 CAS 保持插入过程中没有锁释放） 。 相对的， 非公平锁场景下， 每个线程都先要竞争锁， 在竞争失败或当前已被加锁的前提下才会被塞入等待队列， 在这种实现下， 后到的线程有可能无需进入等待队列直接竞争到锁。






# 11.java基础-关键字-synchronized关键字


## 10-3：说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗

💀💀💀

## 10-4：synchronized关键字最主要的三种使⽤⽅式（与单例模式结合比较高）

1. 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁
2. 修饰代码块: 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。
3. 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例。

补充：
* synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class类上锁。 
* synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

## 10-5：synchronized 关键字底层原理

① synchronized 同步语句块的情况
synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter
指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 

② synchronized 修饰⽅法的的情况
synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是
ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法， JVM 通过该 ACC_SYNCHRONIZED 访问
标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。

## 10-6：synchronized和ReentrantLock的区别
1. 两者都是可重⼊锁

* “可重⼊锁”概念是：⾃⼰可以再次获取⾃⼰的内部锁。⽐如⼀个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器
下降为0时才能释放锁。

2. synchronized 依赖于 JVM ⽽ ReentrantLock 依赖于 API

3. ReentrantLock ⽐ synchronized 增加了⼀些⾼级功能
 1. 等待可中断； 
 2. 可实现公平锁； 
 3. 可实现选择性通知（锁可以绑定多个条件）

## 2.sychronized和lock的区别?
synchronized:在需要同步的对象中加入此控制, synchronized可以加在方法上,也可以在特定代码块中,括号中表示需要锁的对象。lock :需要显示指定起始位置和终止位置. 一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能呆证锁的生效。且在加顺和解锁处需要通过lock()和unlock())显示指出。所以

1. synchronized是托管给JVM执行的,而lock是ava写的控制唢的代码。在Java1 .5中，synchronize是性能低效的。因为这是一一个重量级操作,需要凋用操作接口,导致有可能加唢消耗的系统时间比加赖以外的操作还多。相比之下使用ava提供的Lock对象，性能更高-些。但是到了lava1.6 ,发生了变化。synchronize在语义上很清斷,可以进行很多优化,有适应自旋,锁消除,锁粗化,轻量级锁,偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差。
2. synchronized原始采用的是CPU悲观锁机制,即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞
来等待线程释放锁。Lock 用的是乐观锁方式。所谓乐观锁就是每次不加锁而是假设没有冲突而去 完成某项操作,如果因为冲突失败就重试,直到成功为止。乐观锁实现的机制就是CAS操作。

## synchronized用在代码块和方法上有什么区别?
1. synchronized用在代码块锁的是调用该方法的对象( this )，也可以选择锁住任何一一个对象。
2. synchronized用在方法 上锁的是调用该方法的对象，
3. synchronized用在代码块可以减小锁的粒度 ,从而提高并发性能。
4. 无论用在代码块上还是用在方法上,都是获取对象的锁;每一个对象只有一一个锁与之相关联;实现同步需要很大的系统开销作为代价,甚至可能造成死锁,所以尽量避免无谓的同步控制。


## synchronized与static synchronized的区别

1. synchronized是对类的当前实例进行加锁,防止其他线程同时访问该类的该实例的所有synchronized块，同一个类的两个不同实例就没有这种约束了。
2. static synchronized恰好就是要控制类的所有实例的访问了, static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码快。

# 乐观锁与悲观锁 

## 何谓悲观锁与乐观锁

悲观锁

每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

## 两种锁的使用场景

乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

## 乐观锁常见的两种实现方式

乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

2. CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

* 需要读写的内存值 V
* 进行比较的值 A
* 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。



## 乐观锁的缺点

1 ABA 问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

## CAS与synchronized的使用情景

1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。


# 并发级别


部分在书本




## 11-1：volatile 关键字作用以及Java内存数据不一致

作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。


## 11-2：说说 synchronized 关键字和 volatile 关键字的区别

1. volatile关键字是线程同步的轻量级实现，但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。
2. synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升。
3. 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞
4. volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized关键字两者都能保证。
5. volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是多个线程之间访问资源的同步性。

## 11-3：get需要加锁么，为什么？ （蚂蚁金服）

get操作全程不需要加锁是因为Node的成员变量是用volatile修饰的，数组用volatile修饰主要是保证在数组扩容的时候保证可见性。
