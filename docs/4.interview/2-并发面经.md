<!-- TOC -->

- [1.线程与进程](#1线程与进程)
  - [1-1：什么是进程](#1-1什么是进程)
  - [1-2：何为线程?](#1-2何为线程)
  - [1-3：线程与进程的区别](#1-3线程与进程的区别)
  - [1-4：进程的通信方式](#1-4进程的通信方式)
  - [1-5：并发级别](#1-5并发级别)
  - [1-6：happen-before原则是什么](#1-6happen-before原则是什么)
- [2.什么是上下⽂切换?](#2什么是上下切换)
- [3.线程死锁](#3线程死锁)
  - [3-1：什么是线程死锁](#3-1什么是线程死锁)
  - [3-2：产生死锁的条件](#3-2产生死锁的条件)
  - [3-3：如何解决线程死锁问题](#3-3如何解决线程死锁问题)
- [4.synchronized关键字](#4synchronized关键字)
  - [4-1：synchronized关键字理解](#4-1synchronized关键字理解)
  - [4-2：JDK1.6优化有哪些？](#4-2jdk16优化有哪些)
  - [4-4：底层原理](#4-4底层原理)
  - [4-5：谈谈 synchronized和ReentrantLock 的区别](#4-5谈谈-synchronized和reentrantlock-的区别)
  - [4-6：synchronized锁的膨胀过程（升级过程）](#4-6synchronized锁的膨胀过程升级过程)
- [5.volatile关键字](#5volatile关键字)
  - [5-1：为什么要是用volatile关键字](#5-1为什么要是用volatile关键字)
  - [5-2：synchronized 关键字和 volatile 关键字的区别](#5-2synchronized-关键字和-volatile-关键字的区别)
- [6.并发基础](#6并发基础)
  - [6-1：并发特性](#6-1并发特性)
  - [6-2：并发级别](#6-2并发级别)
  - [6-3：快速失败与安全失败](#6-3快速失败与安全失败)
  - [说说并发与并⾏的区别?](#说说并发与并的区别)
  - [6-4：为什么要使⽤多线程呢?](#6-4为什么要使多线程呢)
  - [6-5：使⽤多线程可能带来什么问题?](#6-5使多线程可能带来什么问题)
  - [6-6：线程的生命周期和状态](#6-6线程的生命周期和状态)
  - [6-7：一般线程和守护线程的区别](#6-7一般线程和守护线程的区别)
  - [6-8：多线程公共用一个数据注意什么](#6-8多线程公共用一个数据注意什么)
  - [6-9：如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？](#6-9如何确保-n-个线程可以访问-n-个资源同时又不导致死锁)
- [7.创建线程方式](#7创建线程方式)
- [8.线程基本操作与线程协作](#8线程基本操作与线程协作)
  - [8-1：说说 sleep() ⽅法和 wait() ⽅法区别和共同点?](#8-1说说-sleep-法和-wait-法区别和共同点)
  - [8-2：yield join notify notifyAll](#8-2yield-join-notify-notifyall)
  - [8-3：为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？](#8-3为什么我们调-start-法时会执-run-法为什么我们不能直接调run-法)
  - [8-4：中断线程方法](#8-4中断线程方法)
- [9.线程同步](#9线程同步)
- [10.线程池](#10线程池)
  - [10-1：ThreadLocal内存泄露问题](#10-1threadlocal内存泄露问题)
  - [10-2：使⽤线程池的好处：](#10-2使线程池的好处)
  - [10-3：常规实现线程池方法](#10-3常规实现线程池方法)
  - [10-4：线程池增长策略](#10-4线程池增长策略)
  - [10-5：线程池拒绝策略](#10-5线程池拒绝策略)
  - [10-6：BlockingQueue](#10-6blockingqueue)
  - [10-7：实现Runnable接⼝和Callable接⼝的区别](#10-7实现runnable接和callable接的区别)
  - [:0-8：实现 Runnable 接口比继承 Thread 类所具有的优势](#0-8实现-runnable-接口比继承-thread-类所具有的优势)
  - [10-9：执⾏execute()⽅法和submit()⽅法的区别是什么呢？](#10-9执execute法和submit法的区别是什么呢)
- [11.Atomic原子类](#11atomic原子类)
  - [11-1：什么是原子类](#11-1什么是原子类)
  - [11-2：原子类的作用？](#11-2原子类的作用)
  - [11-3：i++自增操作不是原子性的，如何决绝原子性问题](#11-3i自增操作不是原子性的如何决绝原子性问题)
  - [11-4：CAS](#11-4cas)
  - [11-5：CAS的ABA问题](#11-5cas的aba问题)
  - [11-6：基本数据类型原子类的优势](#11-6基本数据类型原子类的优势)
- [12.AQS](#12aqs)
  - [12-1：对AQS原理分析](#12-1对aqs原理分析)
  - [12-2：AQS 对资源的共享⽅式](#12-2aqs-对资源的共享式)
  - [12-3：AQS 组件](#12-3aqs-组件)
- [13.锁](#13锁)
- [14：乐观锁与悲观锁](#14乐观锁与悲观锁)
  - [14-1：定义](#14-1定义)
  - [14-2：两种锁的使用场景](#14-2两种锁的使用场景)
  - [14-3：乐观锁常见的两种实现方式](#14-3乐观锁常见的两种实现方式)
  - [14-4：乐观锁的缺点](#14-4乐观锁的缺点)
- [15.并发容器](#15并发容器)
  - [15-1：JDK 提供的并发容器总结](#15-1jdk-提供的并发容器总结)
  - [15-2：CopyOnWriteArrayList 是如何做到的？](#15-2copyonwritearraylist-是如何做到的)

<!-- /TOC -->


# 1.线程与进程

## 1-1：什么是进程

系统运行一个程序，从创建，运行到消亡的过程这个是一个进程

## 1-2：何为线程?

线程是进程内的一个执行单元

## 1-3：线程与进程的区别

1. 拥有资源
   进程是资源分配的基本单位，虽然线程不拥有资源，线程可以访问隶属进程的资源

2. 调度
   线程是独立调度的基本单位

3. 系统开销
   创建或者撤销进程的开销大于线程的开销

4. 通信方面
   线程间可以通过读写进行通信，进程通信需要PIC

## 1-4：进程的通信方式

1. 管道

管道分为有名管道和无名管道,无名管道数据只能单向流动,而且只能在具有亲缘关系的进程间使用;有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。

2. 信号量

信号量是一个计数器,可以用来控 制多个线程对共享资源的访问.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.

3. 信号

信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.

4. 消息队列

消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.

5. 共享内存

共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.

6. 套接字：可用于不同及其间的进程通信

## 1-5：并发级别

书本

## 1-6：happen-before原则是什么

书本

# 2.什么是上下⽂切换?

当前任务在执⾏完 CPU时间⽚ 切换到另⼀个任务 之前 会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。 任务从保存到再加载的过程就是⼀次上下⽂切换。

# 3.线程死锁

## 3-1：什么是线程死锁

多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。

## 3-2：产生死锁的条件

1. 该资源任意⼀个时刻只由⼀个线程占⽤。
2. ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
3. 线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。
4. 若⼲进程之间形成⼀种头尾相接的循环等待资源关系。

## 3-3：如何解决线程死锁问题

1. ⼀次性申请所有的资源。
2. 占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. 靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。

# 4.synchronized关键字

## 4-1：synchronized关键字理解

1. 解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执
   ⾏。
2. 在Java早期版本中， synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex 
   Lock 来实现的， Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽
   操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，但是
   在JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开
   销。

## 4-2：JDK1.6优化有哪些？

JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

①偏向锁

引入偏向锁的目是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。

② 轻量级锁

轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。

如果没有竞争，轻量级锁使用CAS操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因
此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

③ 自旋锁和自适应自旋

一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。为了让一个线程等待，我们只需要让
线程执行一个忙循环（自旋）也就是自旋。

自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。

另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自
旋时间以及锁的拥有者的状态来决定。

④ 锁消除

指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求
锁的时间。

⑤ 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了
使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。
   
## 4-4：底层原理

书本

## 4-5：谈谈 synchronized和ReentrantLock 的区别

1. 两者都是可重入锁

自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的。

2. synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

3. ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

4. ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。

5. synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类借助于
   Condition接口与newCondition() 方法。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，

## 4-6：synchronized锁的膨胀过程（升级过程）

1. 整个膨胀过程在自旋下完成；

2. mark->has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行步骤（3），否则执行步骤（4）；

3. mark->monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；

4. 如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资
   源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；

5. 如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：

    通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；
    通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为
    markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；
    如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；

6. 如果是无锁，重置监视器值；


# 5.volatile关键字

## 5-1：为什么要是用volatile关键字

目前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。

要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。

volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。

## 5-2：synchronized 关键字和 volatile 关键字的区别

1. volatile关键字是线程同步的轻量级实现，但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。
   synchronized关键字在1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。

2. 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞

3. volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。

4. volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。


# 6.并发基础

## 6-1：并发特性

1. 原子性 : 要么所有的操作都执行，要么都不执行。
2. 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
3. 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。
            volatile 关键字可以禁止指令进行重排序优化。

## 6-2：并发级别

## 6-3：快速失败与安全失败

## 说说并发与并⾏的区别?
1. 并发： 同⼀时间段，多个任务都在执⾏；
2. 并⾏： 单位时间内，多个任务同时执⾏。

## 6-4：为什么要使⽤多线程呢?

1. 线程间的切换和调度的成本远远⼩于进程。减少了线程上下⽂切换的开销。
2. 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
3. 发挥多核 CPU 的优势
4. 防止阻塞

## 6-5：使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

## 6-6：线程的生命周期和状态

1. 新建状态（New） ： 新创建了一个线程对象。
2. 就绪状态（Runnable） ： 线程对象创建后， 其他线程调用了该对象的 start()方法。该状态的线程位于可运行线程池中， 变得
   可运行， 等待获取 CPU 的使用权。
3. 运行状态（Running） ： 就绪状态的线程获取了 CPU， 执行程序代码。
4. 阻塞状态（Blocked） ： 阻塞状态是线程因为某种原因放弃 CPU 使用权， 暂时停止运行。 直到线程进入就绪状态， 才有机会
   转到运行状态。 阻塞的情况分三种：
5. 死亡状态（Dead） ： 线程执行完了或者因异常退出了 run()方法， 该线程结束生命周期

## 6-7：一般线程和守护线程的区别

所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程， 比如垃圾回收线程就是一个很称职的守护者， 并且这种线程并不属于程序中不可或缺的部分。 因 此，当所有的非守护线程结束时， 程序也就终止了， 同时会杀死进程中的所有守护线程。 反过来说， 只要任何非守护线程还在运行， 程序就不会终止。

区别：
为守护线程是 JVM 自动创建的线程， 用户线程是程序创建的线程； 比如 JVM的垃圾回收线程是一个守护线程， 当所有线程已经撤离， 不再产生垃圾， 守护线程自然就没事可干了， 当垃圾回收线程是 Java 虚拟机上仅剩的线程时， Java 虚拟机会自动离开。


## 6-8：多线程公共用一个数据注意什么

1. 当我们在线程对象( Runnable )中定义了全局变量, run方法会修改该变量时,如果有多个线程同时使用刻线程对象, 那么就会造成全局变量的值被同时修改,造成错误
2. ThreadLocal是JDK引入的一种机制,它用于解决线程间共享变量,使用ThreadLocal声明的变量，即使在线程中属于全局变量,针对每个线程来讲,这个变量也是独立的。
3. volatile变量每次被线程访问时,都强迫线程从主内存中重读该变量的最新值,而当该变量发生修改变化时,也会强迫线程将最新的值刷新回主内存中。这样一来 ,不同的线程都能及时的看到该变量的最新值。

## 6-9：如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？
1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测


# 7.创建线程方式


# 8.线程基本操作与线程协作

## 8-1：说说 sleep() ⽅法和 wait() ⽅法区别和共同点?

1. sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。
2. 两者都可以暂停线程的执⾏。
3. Wait 通常被⽤于线程间交互/通信， sleep 通常被⽤于暂停执⾏。
4. wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或notifyAll() ⽅法。 sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。

## 8-2：yield join notify notifyAll

1. yield()方法是停止当前线程， 让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话， 那么 yield()方法将不会起作用， 并且由可执行状态后马上又被执行。

2. join 方法是用于在某一个线程的执行过程中调用另一个线程执行， 等到被调用的线程执行结束后， 再继续执行当前线程。 如： t.join();//主要用于等待 t 线程运行结束， 若无此句，main 则会执行完毕， 导致结果不可预测。

3. notify 方法只唤醒一个等待（对象的） 线程并使该线程开始执行。 所以如果有多个线程等待一个对象， 这个方法只会唤醒其中一个线程， 选择哪个线程取决于操作系统对多线程管理的实现。

4. notifyAll 会唤醒所有等待(对象的)线程， 尽管哪一个线程将会第一个处理取决于操作系统的实现


## 8-3：为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？

new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开
始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅
法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

## 8-4：中断线程方法 
1. 使用退出标志， 使线程正常退出， 也就是当 run 方法完成后线程终止。 
2. 通过 return 退出 run 方法
3. 通过对有些状态中断抛异常退出thread.interrupt() 中断。 
4. 使用 stop 方法强行终止线程（过期）

# 9.线程同步

# 10.线程池

## 10-1：ThreadLocal内存泄露问题

ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。所以，如ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候， key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。 ThreadLocalMap实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null 的记录。使⽤完ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法

## 10-2：使⽤线程池的好处：

1. 降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。
2. 提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。
3. 提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。

## 10-3：常规实现线程池方法


## 10-4：线程池增长策略

## 10-5：线程池拒绝策略

## 10-6：BlockingQueue

## 10-7：实现Runnable接⼝和Callable接⼝的区别

Runnable ⾃Java 1.0以来⼀直存在，但 Callable 仅在Java 1.5中引⼊,⽬的就是为了来处理 Runnable
不⽀持的⽤例。 Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。所以，如果
任务不需要返回结果或抛出异常推荐使⽤ Runnable 接⼝，这样代码看起来会更加简洁。

## :0-8：实现 Runnable 接口比继承 Thread 类所具有的优势
1. 适合多个相同的程序代码的线程去处理同一个资源 
2. 可以避免 java 中的单继承的限制 
3. 增加程序的健壮性， 代码可以被多个线程共享， 代码和数据独立
4. 线程池只能放入实现 Runable 或 callable 类线程， 不能直接放入继承 Thread 的类 
5. runnable 实现线程可以对线程进行复用， 因为 runnable 是轻量级的对象， 重复 new 不会耗费太大资源， 而 Thread 则不然， 它是重量级对象， 而且线程执行完就完了， 无法再次利用


## 10-9：执⾏execute()⽅法和submit()⽅法的区别是什么呢？

1. execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；
2. submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout， TimeUnit unit） ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完。


# 11.Atomic原子类

## 11-1：什么是原子类

原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。

原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。

## 11-2：原子类的作用？

提供一种简单、性能高效、线程安全地更新一个变量的方式。

## 11-3：i++自增操作不是原子性的，如何决绝原子性问题

Atomic原子类就是来解决这个问题的，


（1）Unsafe是什么？

（3）Unsafe为什么是不安全的？

（4）Unsafe的实例怎么获取？

（5）Unsafe的CAS操作？

（6）Unsafe的阻塞/唤醒操作？

（7）Unsafe实例化一个类？

（8）实例化类的六种方式？

（9）原子操作是什么？

（10）原子操作与数据库ACID中A的关系？

（11）AtomicInteger怎么实现原子操作的？

（12）AtomicInteger主要解决了什么问题？

（13）AtomicInteger有哪些缺点？


（17）AtomicStampedReference是怎么解决ABA的？


（19）CPU的缓存架构是怎样的？

（20）CPU的缓存行是什么？

（21）内存屏障又是什么？

（22）伪共享是什么原因导致的？

（23）怎么避免伪共享？

（24）消除伪共享在java中的应用？

（25）LongAdder的实现方式？

（26）LongAdder是怎么消除伪共享的？

（27）LongAdder与AtomicLong的性能对比？

（28）LongAdder中的cells数组是无限扩容的吗？


## 11-4：CAS

一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。

## 11-5：CAS的ABA问题

## 11-6：基本数据类型原子类的优势

多线程环境使用原子类保证线程安全（基本数据类型）

# 12.AQS

## 12-1：对AQS原理分析

如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。

## 12-2：AQS 对资源的共享⽅式

1. Exclusive（独占）：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：
   * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
   * ⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的
2. Share（共享）：多个线程可同时执⾏，如Semaphore/CountDownLatch。 Semaphore、
CountDownLatch、 CyclicBarrier、 ReadWriteLock 我们都会在后⾯讲到。

## 12-3：AQS 组件

Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

# 13.锁

0. 死锁

1. 共享锁：

　　也叫s锁/读锁，能查看但无法修改和删除的一种数据锁，加锁后其他用户可以并发读取，查询数据，但不能修改，增加，删除数据，读锁可以被多个线程所持有，该锁可被多个线程持有，用于资源数据共享；

2. 互斥锁：

　　也叫做x锁/排它锁/写锁/独占锁/ ，该锁每一次只能被一个线程锁持有，加锁后任何线程试图再次加锁的线程会被阻塞，直到当前线程解锁，例子：如果 线程A 对deta1加上排它锁后，则其他线程不能再对data1 加任何类型的锁，获得互斥锁的线既能读取数据又能修改数据

3. 可重入锁/不可重入锁

4. 自旋锁

5. 公平锁/非公平锁

　　多个线程按照申请锁的顺序来获取锁，简单来说，如果一个线程组里，能保证每个线程都能拿到锁，比如ReentrantLock(公平锁的实现是同步队列FIFO来实现)

　　获取锁的方式是随机获取的，保证不了每个线程都能拿到锁，也就是存在有线程饿死，一直拿不到锁，比如synchronized，ReentrantLock（非公平锁的实现）

6. 悲观锁/乐观锁

　　当线程去操作数据的时候，总认为别的线程回去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized

　　线程去操作数据的时候，认为别的线程不会修改，更新的时候会判断别人是否回去更新数据，通过版本来判断，如果数据被修改了就拒绝更新，比如CAS是乐观锁，但严格来说并不是锁，通过原子性来保证数据的同步，比如数据库的乐观锁，通过版本控制来实现，但是CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响

　　小结:悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁多；

7. 数据库锁

    * 分段锁
    * 行锁
    * 表锁

8. JVM为了提高锁的获取与释放而作的优化锁
　
   * 偏向锁
   * 轻量级锁
   * 重量级锁

# 14：乐观锁与悲观锁 

## 14-1：定义

悲观锁

每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去
更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于
write_condition机制，其实都是提供的乐观锁。

## 14-2：两种锁的使用场景

乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但
如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用
悲观锁就比较合适。

## 14-3：乐观锁常见的两种实现方式

乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数
据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更
新，否则重试更新操作，直到更新成功。

2. CAS算法

## 14-4：乐观锁的缺点

1 ABA 问题

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期
引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的
pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的
执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突
（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用
对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享
变量合并成一个共享变量来操作。

# 15.并发容器

## 15-1：JDK 提供的并发容器总结

ConcurrentHashMap: 线程安全的 HashMap
CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.
ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

## 15-2：CopyOnWriteArrayList 是如何做到的？
CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。

从 CopyOnWriteArrayList 的名字就能看出CopyOnWriteArrayList 是满足CopyOnWrite 的 ArrayList，所谓CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。
