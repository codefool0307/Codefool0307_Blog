<!--
 * @Author: 孙浩然
 * @Date: 2020-07-29 08:00:58
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-09 16:31:32
 * @FilePath: \docs\4.interview\6.1-操作系统.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

## 1-1：什么是操作系统

1. 操作系统是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；
2. 操作系统本质上是运⾏在计算机上的软件程序 ；
3. 操作系统为⽤户提供⼀个与系统交互的操作界⾯ ；
4. 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应⽤程序，⽽内核就是能操作硬件的程序）。

## 1-2：运⾏的程序基本都是运⾏在⽤户态，如果我们调⽤操作系统提供的系统态级别的⼦功能咋办呢？

我们运⾏的⽤户程序中，凡是与系统态级别的资源有关的操作，都必须通过系统调⽤⽅式向操作系统提出服务请求，并由操作系统代为完成。

## 1-3：进程与线程的区别

⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈。

线程是进程划分成的更⼩的运⾏单位,⼀个进程在其执⾏的过程中可以产⽣多个线程。线程和进
程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互
影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反。

## 那你再说说进程有哪⼏种状态?

1. 创建状态(new) ：进程正在被创建，尚未到就绪状态。
2. 就绪状态(ready) ：进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源即可运⾏。
3. 运⾏状态(running) ：进程正在处理器上上运⾏
4. 阻塞状态(waiting) ：进程正在等待某⼀事件⽽暂停运⾏。即使处理器空闲，该进程也不能运⾏。
5. 结束状态(terminated) ：进程正在从系统中消失。

## 进程间的通信常⻅的的有哪⼏种⽅式呢?

1. 管道/匿名管道：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。

2. 有名管道: 为了克服匿名管道缺点，提出了有名管道。有名管道严格遵循先进先出。

3. 信号：⽤于通知接收进程某个事件已经发⽣；

4. 消息队列：消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐FIFO更有优势。

5. 信号量：这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。

6. 共享内存：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对
⽅进程中对共享内存中数据的更新。

7. 套接字: 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。

## 线程间的同步的⽅式

1. 互斥量：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。

2. 信号量：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资
源的最⼤线程数量
3. 事件:通过通知操作如Wait/Notify的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的⽐较操作

## 进程的调度算法

1. 先到先服务调度算法:从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。

2. 短作业优先的调度算法:从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。

3. 时间⽚轮转调度算法:每个进程被分配⼀个时间段

4. 多级反馈队列调度算法:既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。

5. 优先级调度:为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以FCFS⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 操作系统的内存管理主要是做什么？

操作系统的内存管理主要负责内存的分配与回收，另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。


## 内存管理有哪⼏种⽅式?

简单分为连续分配管理⽅式和⾮连续分配管理⽅式这两种。

连续分配管理⽅式是指为⼀个⽤户程序分配⼀个连续的内存空间，如块式管理

⾮连续分配管理⽅式允许⼀个程序使⽤的内存分布在离散或者说不相邻的内存中，常⻅的如⻚式管理和段式管理。

1. 块式管理：将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，
   
2. ⻚式管理：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。

3. 段式管理：把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多。每个段定义了⼀组逻辑信息

4. 段⻚式管理机制：就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说段⻚式管理机制 中段与段之间以及段的内部的都是离散的

##  快表和多级⻚表

1. 快表
为了解决虚拟地址到物理地址的转换速度，操作系统在⻚表⽅案基础之上引⼊了快表来加速虚拟地址到物理地址的转换。可以把块表理解为⼀种特殊的⾼速缓冲存储器，其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。使⽤快表之后的地址转换流程是这样的：
  1. 根据虚拟地址中的⻚号查快表；
  2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；
  3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；
  4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。

2. 多级⻚表
为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景，

## 分⻚机制和分段机制有哪些共同点和区别呢？

1. 共同点 ：
   * 分⻚机制和分段机制都是为了提⾼内存利⽤率，较少内存碎⽚。
   * ⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的。

2. 区别 ：
   * ⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。
分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以
体现为代码段，数据段，能够更好满⾜⽤户的需要。


## 为什么要有虚拟地址空间呢？

1. ⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。
2. 想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个QQ⾳乐都不⾏。

总结来说：如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。

# 1 内存管理-虚拟内存

# 2 内存管理-内存分段

# 3 内存管理-内存分页

# 4 内存管理-段页式内存管理

# 5 内存管理-Linux内存管理


## 死锁的条件
