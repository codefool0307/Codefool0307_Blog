<!--
 * @Author: 孙浩然
 * @Date: 2020-07-29 08:00:58
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-16 08:38:42
 * @FilePath: \docs\4.interview\6.1-操作系统.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

## 1-1：什么是操作系统

1. 操作系统是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；
2. 操作系统本质上是运⾏在计算机上的软件程序 ；
3. 操作系统为⽤户提供⼀个与系统交互的操作界⾯ ；
4. 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应⽤程序，⽽内核就是能操作硬件的程序）。

## 1-2：运⾏的程序基本都是运⾏在⽤户态，如果我们调⽤操作系统提供的系统态级别的⼦功能咋办呢？

我们运⾏的⽤户程序中，凡是与系统态级别的资源有关的操作，都必须通过系统调⽤⽅式向操作系统提出服务请求，并由操作系统代为完成。

## 1-3：进程与线程的区别

⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈。

线程是进程划分成的更⼩的运⾏单位,⼀个进程在其执⾏的过程中可以产⽣多个线程。线程和进
程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互
影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反。

## 那你再说说进程有哪⼏种状态?

1. 创建状态(new) ：进程正在被创建，尚未到就绪状态。
2. 就绪状态(ready) ：进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源即可运⾏。
3. 运⾏状态(running) ：进程正在处理器上上运⾏
4. 阻塞状态(waiting) ：进程正在等待某⼀事件⽽暂停运⾏。即使处理器空闲，该进程也不能运⾏。
5. 结束状态(terminated) ：进程正在从系统中消失。

## 进程间的通信常⻅的的有哪⼏种⽅式呢?

1. 管道/匿名管道：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。

2. 有名管道: 为了克服匿名管道缺点，提出了有名管道。有名管道严格遵循先进先出。

3. 信号：⽤于通知接收进程某个事件已经发⽣；

4. 消息队列：消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐FIFO更有优势。

5. 信号量：这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。

6. 共享内存：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对
⽅进程中对共享内存中数据的更新。

7. 套接字: 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。

## 线程间的同步的⽅式

1. 互斥量：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。

2. 信号量：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资
源的最⼤线程数量
3. 事件:通过通知操作如Wait/Notify的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的⽐较操作

## 进程的调度算法

1. 先到先服务调度算法:从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。

2. 短作业优先的调度算法:从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。

3. 时间⽚轮转调度算法:每个进程被分配⼀个时间段

4. 多级反馈队列调度算法:既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成。

5. 优先级调度:为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以FCFS⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 操作系统的内存管理主要是做什么？

操作系统的内存管理主要负责内存的分配与回收，另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。


## 内存管理有哪⼏种⽅式?

简单分为连续分配管理⽅式和⾮连续分配管理⽅式这两种。

连续分配管理⽅式是指为⼀个⽤户程序分配⼀个连续的内存空间，如块式管理

⾮连续分配管理⽅式允许⼀个程序使⽤的内存分布在离散或者说不相邻的内存中，常⻅的如⻚式管理和段式管理。

1. 块式管理：将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，
   
2. ⻚式管理：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。

3. 段式管理：把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多。每个段定义了⼀组逻辑信息

4. 段⻚式管理机制：就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说段⻚式管理机制 中段与段之间以及段的内部的都是离散的

##  快表和多级⻚表

1. 快表
为了解决虚拟地址到物理地址的转换速度，操作系统在⻚表⽅案基础之上引⼊了快表来加速虚拟地址到物理地址的转换。可以把块表理解为⼀种特殊的⾼速缓冲存储器，其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。使⽤快表之后的地址转换流程是这样的：
  1. 根据虚拟地址中的⻚号查快表；
  2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；
  3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；
  4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。

2. 多级⻚表
为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景，

## 分⻚机制和分段机制有哪些共同点和区别呢？

1. 共同点 ：
   * 分⻚机制和分段机制都是为了提⾼内存利⽤率，较少内存碎⽚。
   * ⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内存是连续的。

2. 区别 ：
   * ⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。
分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以
体现为代码段，数据段，能够更好满⾜⽤户的需要。

## 为什么要有虚拟地址空间呢？

1. ⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。
2. 想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个QQ⾳乐都不⾏。

总结来说：如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。

## 通过虚拟地址访问内存优势

1. 程序可以使⽤⼀系列相邻的虚拟地址来访问物理内存中不相邻的⼤内存缓冲区。
2. 程序可以使⽤⼀系列虚拟地址来访问⼤于可⽤物理内存的内存缓冲区。当物理内存的供应量变⼩时，内存管
   理器会将物理内存⻚（通常⼤⼩为 4 KB）保存到磁盘⽂件。数据或代码⻚会根据需要在物理内存与磁盘之间
   移动。
3. 不同进程使⽤的虚拟地址彼此隔离。⼀个进程中的代码⽆法更改正在由另⼀进程或操作系统使⽤的物理内
   存。

# 1 内存管理-虚拟内存

## 为什么会有虚拟内存

一开始接触虚拟内存是在单片机中接触的，因为单片机的CPU是直接操作内存的「物理地址」。要想在内存中同时运行两个程序是不可能的。

这个是因为问题是这两个程序都引用了绝对物理地址，为了解决这个问题

我们可以把进程所使用的地址「隔离」开来，让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，
互不干涉。但是每个进程都不能访问物理地址，

之后操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换
变成物理地址，然后再通过物理地址访问内存

## 分段机制下，虚拟地址和物理地址是如何映射的？-----更改中

分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。

![avatar](http://code.clouddn.com/04_06_interview_OS_01.jpg)


1. <font color=red>段选择子</font>就保存在段寄存器里面。段选择子里面最重要的是<font color=red>
   段号</font>，用作段表的索引。<font color=red>段表</font>里面保存的是这个<font color=red>段
   的基地址、段的界限和特权等级等。</font>

2. 虚拟地址中的<font color=red>段内偏移量</font>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

---------下面大体了解就好------------

分段机制会把程序的虚拟地址分成4个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址：

![avatar](http://code.clouddn.com/04_06_interview_OS_02.jpg)

如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。


## 分段缺陷

分段解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：

第一个就是内存碎片的问题。

第二个就是内存交换的效率低的问题。


## 为什么会产生内存碎片的问题

1. 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；

2. 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，
   这也会导致内存的浪费；

## 如何解决

解决外部内存碎片的问题就是内存交换。

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

## 分段为什么会导致内存交换效率低的问题？

对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。

## 内存分页

分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。

## 操作系统是如何管理虚拟地址与物理地址之间的关系？

主要有两种方式，分别是内存分段和内存分页



## 什么是虚拟内存(Virtual Memory)?

比如说我们平时使⽤电脑特别是Windows系统的时候，很多时候我们使⽤点开了很多占内存的软件，这些软件占
⽤的内存可能已经远远超出了我们电脑本身具有的物理内存。 

为什么可以这样呢？正是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存⼤⼩的可⽤内存空间。另外，虚拟内存为每个进程提供了⼀个⼀致的、私有的地址空间，它让每个进程产⽣了⼀种⾃⼰在独享主存的错觉（每个进程拥有⼀⽚连续完整的内存空间） 。这样会更加有效地管理内存并减少出错。

## 局部性原理

局部性原理是虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分程序到内存就开始运行。

局部性原理表现在以下两个方面：

1. 时间局部性 ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据被访问过，不久
   以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着⼤量的循环操作。

2. 空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时
   间内所访问的地址，可能集中在⼀定的范围之内，这是因为指令通常是顺序存放、顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。
   
   时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结构实现。空间局部性通常是使⽤较⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，

## 虚拟存储器

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执
行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大
的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程
序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这
样，计算机好像为用户提供了一个比实际内存大的多的存储器一虚拟存储器。

实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用CPU 的计算时间，页的调入调出花费的时间，换来
了一个虚拟的更大的空间来支持程序的运行。

## 虚拟内存技术的实现呢？

虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：

1. 请求分⻚存储管理 ：建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能和⻚⾯置换功能。请求分⻚是⽬前最常⽤的⼀种实现虚拟存储器的⽅法。请求分⻚存储管理系统中，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏。假如在作业运⾏的过程中发现要访问的⻚⾯不在内存，则由处理器通知操作系统按照对应的⻚⾯置换算法将相应的⻚⾯调⼊到主存，同时操作系统也可以将暂时不⽤的⻚⾯置换到外存中。

2. 请求分段存储管理 ：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅
   式就如同请求分⻚储存管理⽅式⼀样，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏；在执⾏
   过程中，可使⽤请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，⽽⼜需要装⼊新的
   段时，根据置换功能适当调出某个段，以便腾出空间⽽装⼊新的段。

3. 请求段⻚式存储管理


## 请求分页与分页存储管理的不同？

根本区别在于，是否要求将程序所需全部的地址空间都装入内存，分页存储是这样要求的，所以无法提供虚拟内存

## 常见的页面置换算法有哪些？

地址映射过程中，若在⻚⾯中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。


当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。

1. 最佳置换算法（OPT）：理论上最好的算法，每次置换选择的将是最久不会被访问的页面

2. 最近最久未使用（LRU）: 记录的是页面上次的访问时间，实现方式有栈或者寄存器两种，对于栈每次置换栈
   顶元素，每次访问都会将页面置于栈底；寄存器保存的是访问时间，每次置换掉访问时间离现在最晚的的

3. 最少使用（LFU）：该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰页，记录的是一段时间内的使用频
   率。

4. 先进先出（FIFO）：每次置换的将是最先进来的页面

5. 第二次机会算法 ：由于先进先出可能会将经常使用的页面置换出去，所以增加了一个访问位，当页面被访问
   时，将该位置成1，当发生缺页中断时，会将该位置成0，会给该页面一次机会。

6. 最近未使用（NRU）：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改
   时设置 M=1。其中 R 位会定时被清零。当发生缺页中断时，最先置换00，最后置换11的页面，至于中间的
   两个分类，NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）

# 书本


