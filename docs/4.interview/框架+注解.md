# ------Spring---------------------------------------------------------------------------------------------------------

# 1.Spring概述

## 1-1：什么是spring?

Spring是一种轻量级框架，主要的目的就是提高开发人员的开发效率以及系统的可维护性。

它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。

Spring的6个特征：

1. 核心技术：依赖注入（DI），AOP，事件（Events），资源，i18n，验证，数据绑定，类型转换，SpEL。

2. 测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。

3. 数据访问：事务，DAO支持，JDBC，ORM，编组XML。

4. Web支持：Spring MVC和Spring WebFlux Web框架。

5. 集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。

6. 语言：Kotlin，Groovy，动态语言。

## 1-2：Spring的优缺点是什么？

1. 优点：
   1，降低了组件之间的耦合性，实现了软件各层之间的解耦。

   2，可以使用容器提供的众多服务，如事务管理，消息服务等。

   3，容器提供单例模式支持。

   4，容器提供了AOP技术，利用它可以很容易实现一些拦截，如权限拦截，运行期监控等。

   5，容器提供了众多的辅助类，能够加快应用的开发。

   6，spring对于主流的应用框架提供了很好的支持，例如mybatis等。

   7，spring属于低入侵式设计。

   8，独立于各种应用服务器。

   9，spring的DI机制降低了业务对象替换的复杂性。

   10，spring的高度开放性，并不强制应用完全依赖于它，开发者可以自由选择spring的部分或者全部。

spring的缺点：

   使用了大量的反射机制，反射机制非常占用内存。

# 2.Spring用到的设计模式有哪些

## 2-1：Spring的设计模式

1. 工厂模式:通过 BeanFactory 或 ApplicationContext 创建 bean 对象。

2. 单例模式:Bean默认为单例模式。
    
    xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>
    注解：@Scope(value = "singleton")

3. 代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;

4. 模板模式:
   
   Spring 中 jdbcTemplate、hibernateTemplate 等
   以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
   一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，
   而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。

5. 观察者模式:
   
   Spring 事件驱动模型就是观察者模式，比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。

6. 适配器模式
   
   * 在SpringAOP和SpringMVC中都有适配器模式

   虽然Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，
   
   比如说Spring预定义的通���要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象
   
   （如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。

  * spring MVC中的适配器模式

    在Spring MVC中，DispatcherServlet根据请求信息调用HandlerMapping，
    
    解析请求对应的Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，
    
    开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，
    
    具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。

    因为Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。
    如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，

7. 装饰者模式

   当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面

   Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。
   
   我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 Wrapper或者 Decorator。这些类基本上都是动态地给一个对象添加一些额外的职责

## 2-2：代理模式

   AOP实现的关键在于代理设计模式，AOP代理主要分为静态代理和动态代理。
   
   静态代理的代表为Aspect:动态代理则以 SpringAOP为代表。

   (1)AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代
      
      理类，因此也称为编译时增强，他会在编译阶段将AsDectJ(切面)织入到Java字节码中，运
      
      行的时候就是增强之后的AOP对象。
   
   (2)SpringAOP使用的动态代理，所谓的动态代理就是说AOP框恕不会去修改字节码，而是每次运行时
   
      在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，
      
      并且在特定的切点做了增强处理，并回调原对象的方法。

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB 动态代理:

    1）JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和
       Proxy类，InvocationHandler通过invoke(方法反射来调用目标类中的代码，动态地将横切逻
       辑和业务编织在一起;接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的
       实例，生成目标类的代理对象。
    
    2）如果代理类没有实现InvocationHandler 接口，那么Spring AOP会选择使用CGLIB
       来动态代理目标类。CGLIB(Code Generation Library)，是一个代码生成的类库，可以在运
       行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现
       AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是
       无法使用CGLIB做动态代理的。

   (3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静
       态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无
       需特定的编译器处理。


# 3. 循环依赖

## 3-1：什么是Spring的循环依赖

就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，然后去创建 B 对象的时候，又发现 B 对象依赖 C，然后去创建 C 对象的时候，又发现 C 对象依赖 A。

## 3-2：什么是三级缓存

1. 第一级缓存：单例缓存池 singletonObjects。
2. 第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。
3. 第三级缓存：singletonFactories 单例对象工厂缓存

先从一级缓存singletonObjects中去获取，如果获取到 Bean 就直接返回。
如果获取不到或者对象正在创建中，那就再从二级缓存earlySingletonObjects中获取，如果获取到就直接返回。
如果前两级缓存都没成功返回，且允许 singletonFactories(allowEarlyReference=true)通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。

## 3-3：什么是早期暴露的对象

你是一个不完整的对象，你的属性还没有值，你的对象也没有被初始化。这就是早期暴露的对象，只是提前拿出来给你认识认识。但他非常重要。这是多级缓存解决循环依赖问题的一个巧妙的地方。

## 3-4：如何解决循环依赖

主要是用三级缓存来解决循环依赖问题

比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决

1. 使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~
2. 实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
3. 初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
4. 为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~
5. 实例化B，并将其放入缓存。（此时B也能够被引用了）
6. 初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
7. 此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回
8. B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。
9. 因为B实例已经成功返回了，因此最终A也初始化成功
10. 到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美


# 4.IOC

## 4-1：IOC原理

ioc也叫控制反转，是一种设计思想。就是将对象的创建和管理交由spring管理。

ioc容器本质上是一个map，存放着各种bean对象，key是bean对象名，value是bean配置信息。bean对象的创建、依赖关系都交由ioc容器完成，使用时不需要关心bean对象什么时候创建也不需要手动维护对象间的关系。

ioc容器相当于一个第三方的容器，关联着使用资源的双方。

比如一个user类和userinfo类，user类要使用userinfo类的属性，需要调用时创建user类和userinfo类的的对象，然后进行属性注入。
但是如果将user和userinfo都交由ioc容器管理，调用时只需要从ioc容器中取出user对象，那么user对象需要的userinfo属性会在ioc容器中进行注入，取出的user对象是已经完成依赖注入的对象。

## 2-2：IOC容器种类

## 2-3：BeanFactory与ApplicationContext区别

ApplicationContext和BeanFactory是Spring的两大核心接口。都可以当做Spring的容器

其中ApplicationContext是 BeanFactory的子接口。

(1）BeanFactory:是Spring里面最底层的接口，包含了各种Bean的定义，读取bean
配置文档，管理 bean 的加载、实例化，控制 bean的生命周期，维护 bean之间的依赖关系。
ApplicationContext 接口作为 BeanFactory的派生，除了提供BeanFactory所具有的功能外，
还提供了更完整的框架功能:继承MessageSource，因此支持国际化。统一的资源文件访问
方式。提供在监听器中注册bean的事件。同时加载多个配置文件。载入多个(有继承关系）
上下文，使得每个上下文都专注于一个特定的层次，比如应用web层

(2）BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时
(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring
的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用
getBean方法才会抛出异常。
ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动
时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注
入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当
你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的 BeanFactory，
ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较
慢。

(3)BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，
如使用 ContextLoader。
（4） BeanFactory和 ApplicationContext 都支持 BeanPostProcessor、
BeanFactoryPostProcessor的使用，但两者之间的区别是: BeanFactory需要手动注册，而
ApplicationContext则是自动注册。


# 5.依赖注入

## 5-1：依赖注入概念

Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。

## 5-2：有哪些不同类型的IOC（依赖注入）方式？

构造器依赖注入： 构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。

Setter方法注入： Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。

接口注入：定义接口

## 5-3：三种方式的区别小结

1. 基于constructor的注入，会固定依赖注入的顺序；该方式不允许我们创建bean对象之间的循环依赖关系，
   这种限制其实是一种利用构造器来注入的益处 
   没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；

2. 基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，
   而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，
   CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。

3. 使用直接在成员变量上写上注解来注入这种方式看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；

# 6.IOC与DI的的区别

IOC:  控制反转,将类的对象的创建交给Spring类管理创建. 
DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. 


# 7.Spring面向切面编程(AOP)

## 7-1：什么是aop

面相切面编程，与传统oop相比，传统oop编程是自顶向下的编写主业务逻辑，但往往需要参杂着一些与主业务逻辑无关或关系不大的逻辑，这就产生了横切性问题。Aop能很好的隔离和管理这些与主业务逻辑关联不大的业务代码，使得代码的可读性和可维护性大大提高。

能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装
起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

## 7-2：AOP的相关概念：

(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知
(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)
(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式
(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程
(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段
(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类
(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO



# 8.Spring Bean
## 8-1：Bean的五种作用域

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话

## 8-2：Spring 中的单例 bean 的线程安全问题了解吗？

单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。

常见的有两种解决办法：

在Bean对象中尽量避免定义可变的成员变量（不太现实）。

在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

## 8-3：Bean的生命周期

（1）实例化（必须的）构造函数构造对象
（2）装配（可选的）为属性赋值
（3）回调（可选的）（容器-控制类和组件-回调类）
（4）初始化(init-method=" ")
（5）就绪
（6）销毁（destroy-method=" "） 

（1）实例化Bean：
对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入
另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当
容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。
（2）设置对象属性（依赖注入）：
实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通 过BeanWrapper提供的设置属性的接口完成依赖注入。
（3）处理Aware接口：
接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：
①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方
法，此处传递的就是Spring配置文件中Bean的id值；
②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的
是Spring工厂自身。
③如果这个Bean已经实现了ApplicationContextAware接口，会调用
setApplicationContext(ApplicationContext)方法，传入Spring上下文；
（4）BeanPostProcessor：
如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用
postProcessBeforeInitialization(Object obj, String s)方法。
（5）InitializingBean 与 init-method：
如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。
（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object
obj, String s)方法；由于这个方法是在Bean初始化结束时使用的，所以可以被应用于内存或缓存技术；
以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。
（7）DisposableBean： 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的
destroy()方法；
（8）destroy-method：
最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
方法二：实现org.springframework.beans.factory.DisposableBean接口。
执行它的destroy()方法。
如果一个Bean实现了org.springframework.beans.factory.DisposableBean接口，则会自动

## 8-4：Spring的Bean注入方式

1. set方法注入
2. 构造器注入
3. 静态工厂注入
4. 实例工厂注入
 
1. set注入
如果我们需要使用set注入，那么必须要为属性提供set方法，

Spring容器就是通过调用bean的set方法为属性注入值的。

而在xml文件中，使用set注入的方式就是通过property标签，

2. 构造器注入

  就是通过调用bean所属类的带参构造器为bean的属性注入值。

  我们如果需要使用构造器注入，就得为类提供包含参数的构造方法。
  
  构造器注入，实际上有多种匹配属性值的方式，比如说

（一）匹配构造器的参数名称

  我们需要通过constructor-arg标签为构造器传入参数值，
  每个constructor-arg标签对应直接匹配参数名
  
（二）匹配构造器的参数下标

  通过参数在参数列表中的下标进行匹配的方式。

  通过参数的下标为构造器的参数赋值，
  
  参实的下标从0开始。使用第一种方式配置，若赋值的类型与参数的类型不一致，
  
  将会在容器初始化bean的时候抛出异常。
  
  如果bean存在多个参数数量一样的构造器，
  
  Spring容器会自动找到类型匹配的那个进行调用。
  
  比如说，Car有如下两个构造器，Spring容器将会调用第二个，
  
  因为上面的配置中，index = 1对应的value是double类型，
  
  与第二个构造器匹配，而第一个不匹配：

（三）匹配构造器的参数类型

  直接通过匹配构造器的参数类型，

从而选择一个能够完全匹配的构造器，调用这个构造器完成bean的创建和属性注入。

类型并不需要按构造器中声明的顺序编写，Spring也能进行匹配。

3. 静态工厂注入

  静态工厂注入就是我们编写一个静态的工厂方法，

这个工厂方法会返回一个我们需要的值，然后在配置文件中，

我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，

4.  实例工厂与静态工厂类似，不同的是，
   静态工厂调用工厂方法不需要先创建工厂类的对象，因为静态方法可以直接通过类调用，
   所以在上面的配置文件中，并没有声明工厂类的bean。但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。

# 9.SpringMVC

## 9-1：什么是MVC模式

MVC应该是一个设计模式，

它就是强制性把一个应用程序的输入，处理和输出分开。

将一个应用程序分为三个部分：Model，View，Controller。

1. Model 模型
   
   完成业务逻辑：由javaBean构成，在MVC的三个部件中，模型拥有最多的处理任务。
   例如它可能用象EJBs和javabean这样的构件对象来处理数据库。
   由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。

2. View 视图
   就是负责跟用户交互的界面。一般就是由HTML，css元素组成的界面，
   当然现在还有一些像js，ajax，flex一些也都属于视图层。 
   在视图层里没有真正的处理发生，之负责数据输出，并允许用户操纵的方式。
   MVC能为应用程序处理很多不同的视图。 

3. Controller 控制器
   接收请求—>调用模型—>根据结果派发页面并经过模型处理返回相应数据

## 9-2：MVC优缺点（为什么使用MVC）

<font color=yellow>A、优点</font>

1. 分工明确,开发人员可以只关注整个结构中的其中某一层：
   使用MVC可以把数据库开发，程序业务逻辑开发，页面开发分开，每一层都具有相同的特征，方便以后的代码维护。

2. 可以降低层与层之间的依赖：
   视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，
   同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。

3. 方便各层逻辑的复用：
   

缺点:

1、如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。
2、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。

3、由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。

4、MVC并不适合小型甚至中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。 

*如何改善：

第一个缺点，可以采用一些设计模式来到改善。

第二个缺点，可以通过系统的缓存机制来减小对性能的影响；

## 9-1：SpringMVC流程

1）用户发送请求至前端控制器DispatcherServlet:

2）DispatcherServlet收到请求后，题用HandlerMapping处理器映射器,请求获取Handle;

3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给
   DispatcherServlet;

4） DispatcherServlet调用HandlerAdapter处理器适配器;

5）HandlerAdapter 经过适配调用具体处理器(Handler，也叫后端控制器):

6）Handler执行完成返回 ModelAndView;

7）HandlerAdapter将Handler执行结果ModelAndView返���给DispatcherServlet:

8） DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析;

9）ViewResolver解析后返回具体View:

10）DispatcherServlet对 View进行渲染视图（即将模型数据填充至视图中）

11） DispatcherServlet 响应用户。

## 9-2：SpringMVC的参数绑定概念

参数绑定，我认为就是客户端发送请求，而请求中包含一些数据，

在 SpringMVC 中，提交请求的数据是通过方法形参来接收的。

从客户端请求的 key/value 数据，经过参数绑定，将 key/value 数据绑定到 Controller 的形参上，

然后在 Controller 就可以直接使用该形参。

在是一个参数绑定组件，将请求的数据转换为我们需要的数据称为参数绑定组件，也就是参数绑定转换器。

SpringMVC 内置了很多参数转换器，只有在极少数情况下需要我们自定义参数转换器。

## 9-3：SpringMVC的参数绑定支持类型

1. 默认支持类型

      1. HttpServletRequest 对象
      2. HttpServletResponse 对象
      3. HttpSession 对象
      4. Model/ModelMap 对象　

2. 基本数据类型的绑定
3. 包装数据类型的绑定
4. POJO（实体类）类型的绑定
5. 复合POJO（实体类）类型的绑定
6. 数组类型的绑定
7. List类型的绑定
8. Map类型的绑定

# 10.Spring事务

## 10-1：spring事务种类

spring支持编程式事务管理和声明式事务管理两种方式
①编程式事务管理使用TransactionTemplate.
②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，
将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完
目标方法之后根据执行情况提交或者回滚事务。

## 10-2：Spring两种事务区别

1）声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务 
   规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。

2）声明式事务管理要优于编程式事务管理，这正是 spring倡导的非侵入式的开发方式，使业务代码不受污染，
   只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。

## 10-3：事务管理接口

1. PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。
2. TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。
3. TransactionStatus： 事务运行状态。

我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，

而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。

PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离界别、传播行
为等来进行事务管理 ，

而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。


## 10-4：事务传播行为

PROPAGATION_REQUIRED:如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

PROPAGATION_SUPPORTS:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

PROPAGATION_MANDATORY:支持当前事务，如果当前仔在事分，影果当前不存在事务，就抛出异常。

PROPAGATION_REOUIRES NEW:创建新事务，无论当前存不存在事务，都创建新事务。

PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。

PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED属性执行。

## 10-5：事务隔离级别

ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。
ISOLATION_READ_UNCOMMITTED:读未提交，允许另外一个事务可以看到这个事务未提交的数据。
ISOLATION_READ_COMMITTED:读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。
ISOLATION_REPEATABLE_READ:可重复读，保证一个事务修改的数据提交后才能另一事务读取，但是不能看到该事务对已有记录的更新。
ISOLATION_SERIALIZABLE:一个事务在执行的过程中完全看不到其他事务对数据库所


## 10-6：Spring的事务和数据库的事务隔离是一个概念么？

Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是： PlatformTransactionManager 。
通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。

## 10-7：事务属性详解

事务属性主要包括五部分：隔离级别、传播行为、回滚规则、是否只读、事务超时

## 10-8：事务传播行为

事务传播行为是为了解决业务层方法之间互相调用的事务问题。

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如

我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。

这个时候就涉及到业务层方法之间互相调用的事务问题。

如果我们的 bMethod()如果发生异常需要回滚，

如何配置事务传播行为才能让 aMethod()也跟着回滚呢

这个时候就需要事务传播行为的知识了，

## 10-9：Spring事务底层原理

1. 划分处理单元 IOC
之前在看源码，发现Spring 解决的问题是对单个数据库进行局部事务处理的，

具体的实现首先使用 Spring 中的 IOC 划分了事务处理单元。

并且将对事务的各种配置放到了 IOC 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。

2. AOP 拦截需要进行事务处理的类
Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，

具体操作（比如事务实行的配置和读取，事务对象的抽象），

用 TransactionProxyFactoryBean 接口来使用 AOP 功能，

生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，

将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，

转化为 Spring 事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），

转化为 TransactionAttribute 表示的数据对象。

3. 对事物处理实现（事务的生成、提交、回滚、挂起）
Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。

适配的具体事务处理器：DataSource 数据源支持、

Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，

JPA、JTA 数据源事务处理支持。

这些支持都是通过设计 PlatformTransactionManager、

AbstractPlatforTransaction 一系列事务处理的支持。 

为常用数据源支持提供了一系列的 TransactionManager。




## 10-9：@Transactional 注解使用详解

方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。

类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

接口 ：不推荐在接口上使用。

## 10-10：注解常用属性

1. propagation	事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过
2. isolation	事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过
3. timeout	事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。
4. readOnly	指定事务是否为只读事务，默认值为 false。
5. rollbackFor	用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。

## 注解原理

@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。

通过createAopProxy() 方法 决定了是使用 JDK 还是 Cglib 来做动态代理

如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

# ----MyBatis------------------------------------------------------------------------------------------------------------------------

# 1.MyBatis

## 1-1：MyBatis是什么

就和传统的JDBC一样，就是个连接数据库进行增删改查的开源框架

## 1-2：ORM是什么

指将数据库中的每一行数据用对象的形式表现出来。

## 1-3：JPA

是Java持久化接口

## 1-4：MyBatis优点

1. 简单易学，容易上手（相比于Hibernate） ---- 基于SQL编程

2. 消除了JDBC大量冗余的代码，不需要手动开关连接

3. 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDB提供了可扩展性，所以只要这个数据库有针对Java的
   jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。

4. 提供了很多第三方插件（分页插件 / 逆向工程）

5. 能够与Spring很好的集成

## 1-5：为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联
对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

## 1-6：传统JDBC开发存在的问题，如何解决的

1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
   解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。

2. Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
   解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。

3. 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
   解决： Mybatis自动将java对象映射至sql语句。

4. 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比
    较方便。
    解决：Mybatis自动将sql执行结果映射至java对象。

## 1-7：Hibernate 和 MyBatis 的区别

1） Mybatis 它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，
2） Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性
能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运
营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的
前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定
义多套 sql 映射文件，工作量大。
3） Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是
Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象
模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都
是好架构，所以框架只有适合才是最好。

# 2.MyBatis步骤

## 2-1：MyBatis编程步骤是什么样的？

1. 从核心配置文件mybatis-config.xml中获取Environment（这里面是数据源）；
2. 从Environment中取得DataSource；
3. 从Environment中取得TransactionFactory；
4. 从DataSource里获取数据库连接对象Connection；
5. 在取得的数据库连接上创建事务对象Transaction；
6. 创建Executor对象（该对象非常重要，事实上sqlsession的所有操作都是通过它完成的）；
7. 创建sqlsession对象。


# 3.MyBatis的原理

## 3-1：MyBatis的解析和运行原理

MyBatis的运行过程分为两大步：

1. 读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory；
   - 第一步：通过org.apache.ibatis.builder.xml.XMLConfigBuilder解析配置的XML文件，对出所配置的参数，并将读取的能容存入org.apache.ibatis.session.
     Configuration类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中，以便后续将这些内容读出。
   - 第二步：使用Configuration对象去创建SqlSessionFactory。MyBatis中的SqlSessionFactory是个接口，而不是一个实现类，为此MyBatis提供了一个默认的实现类
     org.apache.ibatis.session.default.DefaultSqlSessionFactory。在大部分情况下都没有必要自己创建新的SqlSessionFactory实现类。

2. SqlSession的执行过程。
    主要使用JDK动态代理

## 3-2：MyBatis的工作原理(启动)

1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着<select | update | delete | insert>标签项。

2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。

3、SqlSession对象完成和数据库的交互：
a、用户程序调用mybatis接口层api（即Mapper接口中的方法）
b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象
c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象
d、JDBC执行sql。
e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。

## 3-3：MyBatis底层原理

SqlSession为主要的调配者，持有Configuration与Executor，

先是创建Mapper委托Configuration去以MapperProxy给Mapper接口做动态代理，

底层查询方法根据mapper.xml的查询类型执行SqlSession的查询方法，

而SqlSession在查询时又委托Executor去做实际的查询，

Executor会使用Statement查询结果集，然后使用ResultSetmapping做结果集的映射POJO，

然后返回给SqlSession，因为动态代理，所以mapper的方法实际是SqlSession执行的查询方法，

所以这时候SqlSession返回给方法查询结果，

表面看起来像是Mapper的方法返回的结果，实际上却是SqlSession在做事情。

# 4.MyBatis的预编译

## 4-1：为什么需要预编译

预编译（#{}）会将SQL提前编译好，#{}位置为占位符，执行时候一个占位符就对应一个变量，不会影响到SQL结
构，所以不会存在SQL注入问题；
非预编译（${}）不会提前编译SQL，${}位置会直接将变量拼接进来会影响到SQL的本身机构

## 4-2：MyBatis是如何做到SQL预编译的呢？

在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。

## 4-3：Mybatis如何防止SQL注入

攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵参数检验不足的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。

在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。


# 5.执行器

## Mybatis都有哪些Executor执行器？它们之间的区别是什么？

Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。

1. SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

2. ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

3. BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

## Mybatis中如何指定使用哪一种Executor执行器？

在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。

# 6.延迟加载
## 2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。

它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。

# 7.sql符号问题

## 10-1：#{}和${}的区别是什么？

1. ${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
2. #{}是 sql 的参数占位符，Mybatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，
   比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。

## 12-1：Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？

Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind。

其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

## 12-2：Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。

有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

## 4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？

能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

t_id t_name s_id

| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |


## 当实体类中的属性名和表中的字段名不一样 ，怎么办

解决方法1

            在Mapper.xml映射文件中，写SQL语句时起别名

解决方法2

            在Mybatis全局配置文件中开启驼峰命名，注意：前提是数据库中的字段是按驼峰命名规则的两个单词之间加“_”命名的

               <settings>
                     <!-- 开启驼峰命名规则，可以将数据库中的下划线映射为驼峰命名
                     例如：user_name可以映射为userName -->
                     <setting name="mapUnderscoreToCamelCase" value="true" />
               </settings>
解决方法3

            在Mapper.xml映射文件中使用resultMap自定义映射规则

# 8.映射文件
## 10-2：Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为 sql 片段标签，通过<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。


## 3.11 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？

不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。

原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。


## 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？

Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。


3.13 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？

## Mybatis映射文件中，如果A标签通过include引用了B标签的内，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？

虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。

原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。

## 4.2 Mybatis是否可以映射Enum枚举类？

Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。


# 9.Mapper文件

##  Mapper 编写有哪几种方式？

第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。

1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置

<mappers>
	<mapper resource="mapper.xml 文件的地址" />
	<mapper resource="mapper.xml 文件的地址" />
</mappers>

2、定义 mapper 接口
3、实现类集成 SqlSessionDaoSupportmapper 方法中可以this.getSqlSession()进行数据增删改查。
4、spring 配置

<bean id=" " class="mapper 接口的实现">
 <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>


第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：

1、在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和
mappre 接口的名称相同且在同一个目录，这里可以不用配置

<mappers>
	<mapper resource="mapper.xml 文件的地址" />
	<mapper resource="mapper.xml 文件的地址" />
</mappers>

2、定义 mapper 接口：
   1、mapper.xml 中的 namespace 为 mapper 接口的地址
   2、mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致
   3、Spring 中定义

<bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
	<property name="mapperInterface" value="mapper 接口地址" />
	<property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>


第三种：使用 mapper 扫描器：
1、mapper.xml 文件编写：mapper.xml 中的 namespace 为 mapper 接口的地址；
   mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；
   如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。
2、定义 mapper 接口：注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录
3、配置 mapper 扫描器：

<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="mapper 接口包地址"></property>
	<property name="sqlSessionFactoryBeanName"value="sqlSessionFactory"/>
</bean>


## 在mapper中如何传递多个参数

1、第一种：

DAO 层的函数

public UserselectUser(String name,String area);

对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二参数，更多参数一致往后加即可。

<select id="selectUser"resultMap="BaseResultMap">

select * fromuser_user_t

whereuser_name = #{0}

anduser_area=#{1}

</select>

2、第二种： 使用 @param 注解:

public interface usermapper {

user selectuser(@param(“username”) string

username,@param(“hashedpassword”) string hashedpassword);

}

然后,就可以在 xml 像下面这样使用(推荐封装为一个 map,作为单个参数传递给

mapper):

<select id=”selectuser” resulttype=”user”>

select id, username, hashedpassword

from some_table

where username = #{username}

and hashedpassword = #{hashedpassword}

</select>

3、第三种：多个参数封装成 maptry {

我们使用 Map 集合来装载我们的参数

Map < String, Object > map = new HashMap();

map.put("start", start);

map.put("end", end);

return sqlSession.selectList("StudentID.pagination", map);

} catch (Exception e) {

e.printStackTrace();

sqlSession.rollback();

throw e;

} finally {

MybatisUtil.closeSqlSession();

}

## 使用MyBatis的mapper接口调用时有哪些要求？

1) Mapper接口方法名和Mapper.xml中定义的每个SQL的id相同； 
2) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sqlparameterType类型相同 
3) Mapper接口方法的输入输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 
4) Mapper.xml文件中的namespace，就是接口的类路径。


# 接口

## 什么是MyBatis的接口绑定？有哪些实现方式？

接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 

我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。

一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；
//这种方式不用写mapper.xml
@Select("select * from `tb_Teacher` where id = #{id}")
	public teacher  selectTeacherByID(int id);

另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。
  <select id="selectUserByID" parameterType="int" resultType="test.student">
        
        select id,name,age,stuCountry stu_country from `tb_Student` where id = #{id}
    </select>

两种方式选择：

当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。



## 这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗

Dao 接口，也就是一个Mapper接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中MappedStatement的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。




















## Mybatis如何执行批量操作

1. 设置SqlSession为批量操作类型

```java
sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);
    try {
     namemapper mapper = sqlsession.getmapper(namemapper.class);
     for (string name : names) {
         mapper.insertname(name);
     }
     sqlsession.commit();
    }catch(Exception e){
     e.printStackTrace();
     sqlSession.rollback(); 
     throw e; 
    }
     finally {
         sqlsession.close();
    }
```
然后执行insert方法即可

2. 通过foreach 遍历需要操作的值

```java
<insert id="insertByBatch" parameterType="java.util.List">
        insert into user(name)
        values
        <foreach collection="list" item="item" index="index" separator=",">
            (#{item.name,jdbcType=VARCHAR}
        </foreach>
    </insert>
```

# 13.插入与分页

## 6.1 Mybatis是如何进行分页的？分页插件的原理是什么？

Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：select _ from student，拦截 sql 后重写为：select t._ from （select \* from student）t limit 0，10

## 6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。

Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

# 14.缓存

## 14-1：Mybatis的一级、二级缓存

一级缓存是mybatis默认就帮我们开启的，一级缓存是SqlSession级别的缓存。
在操作数据库时需要构造sqlSession对象，
在对象中有一个数据结构（HashMap）用于存储缓存数据。
不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

二级缓存是mapper级别的缓存，
多个SqlSession去操作同一个Mapper的sql语句，
多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

# ---Servlet--------------------------------------------------------------------------------
# 1.servlet

## 1-1：Servlet生命周期

加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例

初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象

处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求

销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁

卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。

简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。

## 1-2：forward和redirect的区别

实际发生位置不同，地址栏不同

转发是发生在服务器的

转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。
重定向是发生在浏览器的

- **重定向是由浏览器进行跳转的**，进行重定向跳转的时候，**浏览器的地址会发生变化的**。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。**这是由浏览器进行的页面跳转**实现重定向**会发出两个http请求**，**request域对象是无效的，因为它不是同一个request对象**
用法不同:

很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上

request.getRequestDispatcher("/资源名 URI").forward(request,response)

转发时"/"代表的是本应用程序的根目录【zhongfucheng】
response.send("/web应用/资源名 URI");

重定向时"/"代表的是webapps目录
能够去往的URL的范围不一样:

转发是服务器跳转只能去往当前web应用的资源
重定向是服务器跳转，可以去往任何的资源
传递数据的类型不同

转发的request对象可以传递各种类型的数据，包括对象
重定向只能传递字符串
跳转的时间不同

转发时：执行到跳转语句时就会立刻跳转
重定向：整个页面执行完之后才执行跳转
那么转发(forward)和重定向(redirect)使用哪一个？

根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。
典型的应用场景：

转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变
重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了

## tomcat容器是如何创建servlet类实例？用到了什么原理

当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）
在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。

## Servlet安全性问题
由于Servlet是单例的，当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。

## servlet写就行了，为什么要有springMVC这个东西呢

比如说在数据库进行了添加删除更改功能，在web.xml中注册新sevlet，并映射对应的/insert /delete /update /XXX，在这些新的servlet中调用View和Model层完成功能。

这样新定义servlet的方法比较麻烦，要去继承HttpServlet接口，实现接口方法，手写调用jsp的重定向或者请求转发，还要再web.xml中注册。

Spring主要也是通过DispatcherServlet实现了Servlet这个接口，又叫前端控制器，来自前端的请求会先到达这里，它负责到后台去匹配合适的handler。DispatcherServlet的主要工作流程如下：

前端请求到达DispatcherServlet。

前端控制器请求HandlerMappering 查找Handler。

如果查找到存在的处理器，进一步去调用service和dao层

返回结果再到controller层，渲染具体的视图，返回结果给页面。

## Servlet与SpringMVC区别

Servlet：性能最好，处理Http请求的标准。

SpringMVC：开发效率高（好多共性的东西都封装好了，是对Servlet的封装，核心的DispatcherServlet最终继承自HttpServlet）

## servlet加载顺序

web.xml 的加载顺序是：context- param -> listener -> filter -> servlet

## filter和Interceptor的区别

1、filter接口在javax.servlet包下面。inteceptor定义在org.springframework.web.servlet中。
2、filter是servlet规定的，interceptor即可用于web程序，也可用于application中。
3、filter是servlet容器支持的，interceptor是spring框架支持的。
4、filter通过dochain放行，interceptor通过prehandler放行。
5、filter只在方法前后执行，interceptor粒度更细，可以深入到方法前后，异常抛出前后。

## jsp和servlet区别

通过 http 请求一个 JSP 页面是，首先 Tomcat 会调用 service（）方法将JSP编译成为 Servlet，然后执行 Servlet。

## Servlet是线程安全的吗？

Servlet不是线程安全的

比如说，当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

Thread1和Thread2调用了同一个Servlet1，所以此时如果Servlet1中定义了实例变量或静态变量，那么可能会发生线程安全问题（因为所有的线程都可能使用这些变量）

## 



# ---SpringBoot------------------------------------------------------------------------------

# 1.SpringBoot介绍

## 1-1：什么是 Spring Boot？

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。

## 15-2：springboot跟spring的差别？

1. Maven依赖
   Spring创建Web应用程序所需的最小依赖项至少需要两个


   而Spring Boot只需要一个依赖项来启动和运行Web应用程序：


2. MVC配置
   使用Spring和Spring Boot创建JSP Web应用程序所需的配置中

   Spring需要将@EnableWebMvc注解添加到@Configuration注解类，并定义一个视图解析器来解析从控制器返回的
   视图

   SpringBoot一旦我们添加了Spring boot web starter，Spring Boot只需要一些属性来使上面的事情正常工作

3. 模板引擎配置
 
 Spring和Spring Boot中配置Thymeleaf模板引擎中

   在Spring中，我们需要为视图解析器添加 thymeleaf-spring5依赖项和一些配置：

   Spring Boot 只需要spring-boot-starter-thymeleaf的依赖项 来启用Web应用程序中的Thymeleaf支持。

   一旦依赖关系添加成功后，我们就可以将模板添加到src / main / resources / templates文件夹中，Spring Boot将自动显示它们。


4. 安全配置
   
   Spring和Spring Boot框架启用默认的HTTP Basic身份验证。

   Spring需要标准的 spring-security-web和spring-security-config 依赖项来在应用程序中设置Security。

   同样，Spring Boot也需要这些依赖项才能使其工作。
   
   但是我们只需要定义spring-boot-starter-security的依赖关系，它会自动将所有相关的依赖项添加到类路径
   中。

5. 应用引导Application Bootstrap
   
   Spring和Spring Boot中应用程序引导的基本区别在于servlet。
   
spring引导

   方法一：web.xml引导方法

Servlet容器（服务器）读取web.xml
web.xml中定义的DispatcherServlet由容器实例化
DispatcherServlet通过读取WEB-INF / {servletName} -servlet.xml来创建WebApplicationContext
，DispatcherServlet注册在应用程序上下文中定义的bean
   
   方法二：servlet 3+引导方法

容器搜索实现ServletContainerInitializer的 类并执行
SpringServletContainerInitializer找到实现类WebApplicationInitializer的子类
WebApplicationInitializer创建会话使用XML或上下文@Configuration类
WebApplicationInitializer创建DispatcherServlet，使用先前创建的上下文。
   
Spring Boot引导

   spring boot仅仅使用Servlet 3来引导程序。
   默认情况下，Spring Boot使用嵌入式容器来运行应用程序。
   
   Spring Boot使用public static void main入口点来启动嵌入式Web服务器。

   此外，它还负责将Servlet，Filter和ServletContextInitializer bean从应用程序上下文绑定到嵌入式
   servlet容器。

   Spring Boot的另一个特性是它会自动扫描同一个包中的所有类或Main类的子包中的组件。

   Spring Boot提供了将其部署为外部容器中的Web存档的选项。在这种情况下，我们必须扩展
   SpringBootServletInitializer：

1. 打包和部署
   与spring相比，在部署环境中Spring Boot的一些优点包括

      提供嵌入式容器支持
      使用命令java -jar独立运行jar
      在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突
      部署时灵活指定配置文件的选项
      用于集成测试的随机端口生成

## 1-3：Spring Boot 有哪些优点？

容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。
开箱即用，远离繁琐的配置。
提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
没有代码生成，也不需要XML配置。
避免大量的 Maven 导入和各种版本冲突。

# 2.Springboot的启动流程

## 2-1：启动流程

springboot启动流程

启动流程主要分为三个部分，

1. 第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，

2. 第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，

3. 第三部分是自动化配置模块，该模块作为springboot自动配置核心，

一、启动：

 每个SpringBoot程序都有一个主入口，也就是main方法，
 
 main里面调用SpringApplication.run()启动整个springboot程序，
 
 这个方法所在类需要使用
 
 @SpringBootApplication注解，
 @ImportResource注解(if need)，
 @SpringBootApplication包括三个注解，
 
 然后，@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置

@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境

@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下

当运行SpringApplication的main方法时,

首先进入run方法

run方法中去创建了一个SpringApplication实例，

在该构造方法内，我们可以发现其调用了一个初始化的initialize方法

该方法中主要实现就是：

   1. 创建了应用的监听器SpringApplicationRunListeners并开始监听

   2. 加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载      
      StandardEnvironment，其最终也是继承了ConfigurableEnvironment，

   3. 配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)

   4. 创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，

       * 创建方法主要流程就是：方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回，ConfigurableApplicationContext类图如下：

   5. 回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联

   6. 之后refreshContext(context)方法将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。

     
配置结束后，Springboot返回了应用环境上下文。我认为Springboot的启动，

主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，

并基于以上条件，在容器中开始实例化我们需要的Bean，

## 17-8：如何在自定义端口上运行 Spring Boot 应用程序？

为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090

# 3.配置

## 3-1：什么是 JavaConfig？

它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。

## 3-2：JavaConfig

使用 JavaConfig 的优点在于：

（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。

（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。

（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。

# 4.Spring Boot自动配置

## 4-1：Spring Boot自动配置原理

注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，

@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。

筛选有效的自动配置类。

每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能

## 4-2：你如何理解 Spring Boot 配置加载顺序？

在 Spring Boot 里面，可以使用以下几种方式来加载配置。

1）properties文件；

2）YAML文件；

3）系统环境变量；

4）命令行参数；

# 5.YAML与XML文件

## 17-5：什么是 YAML？

YAML 是一种可读的数据序列化语言。

通常用于配置文件。与属性文件相比，

如果我们想要在配置文件中添加复杂的属性，

YAML 文件就更加结构化，而且更少混淆。

YAML 具有分层配置数据。

## 17-6：YAML 配置的优势在哪里 ?

配置有序，在一些特殊的场景下，配置有序很关键
支持数组，数组中的元素可以是基本数据类型也可以是对象
简洁
相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。

## 17-7：Spring Boot 是否可以使用 XML 配置 ?

Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。

spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?

单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。

spring boot 核心的两个配置文件：

bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；
application (. yml 或者 . properties)：由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
什么是 Spring Profiles？

Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。



# 6.安全

## 6-1：如何实现 Spring Boot 应用程序的安全性？

为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。

## 6-2：比较一下 Spring Security 和 Shiro 各自的优缺点 ?

由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：

Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架
Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单
Spring Security 功能强大；Shiro 功能简单
Spring Boot 中如何解决跨域问题 ?

跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有���，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。

@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .maxAge(3600);
    }
}

项目中前后端分离部署，所以需要解决跨域的问题。
我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。
当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。
我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(urlBasedCorsConfigurationSource);
    }
}

## 5-3：什么是 CSRF 攻击？

CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。

# 7.监视器

## 7-1：Spring Boot 中的监视器是什么？

Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。

如何在 Spring Boot 中禁用 Actuator 端点安全性？

默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。

我们如何监视所有 Spring Boot 微服务？

Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。

# 8.整合第三方项目

## 8-1：什么是 WebSockets？

WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。

1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。

2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。

3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信

4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。

## 8-2：什么是 Spring Data ?

Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：

SpringData 项目支持 NoSQL 存储：

MongoDB （文档数据库）
Neo4j（图形数据库）
Redis（键/值存储）
Hbase（列族数据库）
SpringData 项目所支持的关系数据存储技术：

# 9.JDBC
## 9-1：JPA
Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。

## 9-2：什么是 Spring Batch？

Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。

## 9-3：什么是 FreeMarker 模板？

FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。

## 9-4：如何集成 Spring Boot 和 ActiveMQ？

对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。它只需要很少的配置，并且不需要样板代码。

## 9-5：什么是 Apache Kafka？

Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。

## 9-6：什么是 Swagger？你用 Spring Boot 实现了它吗？

Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。

## 9-7：前后端分离，如何维护接口文档 ?

前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。

# 10.其他

## 22-1：如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？

这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>

## 22-2：您使用了哪些 starter maven 依赖项？

使用了下面的一些依赖项

spring-boot-starter-activemq

spring-boot-starter-security

这有助于增加更少的依赖关系，并减少版本的冲突。

## 22-3：Spring Boot 中的 starter 到底是什么 ?

它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，

在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），

然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，

然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。

## 22-4：spring-boot-starter-parent 有什么用 ?

定义了 Java 编译版本为 1.8 。
使用 UTF-8 格式编码。
继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。
执行打包操作的配置。
自动化的资源过滤。
自动化的插件配置。
针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。
Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?

Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。

Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。

## 22-5：运行 Spring Boot 有哪几种方式？

1）打包用命令或者放到容器中运行

2）用 Maven/ Gradle 插件运行

3）直接执行 main 方法运行

## 22-6：Spring Boot 需要独立的容器运行吗？

可以不需要，内置了 Tomcat/ Jetty 等容器。

开启 Spring Boot 特性有哪几种方式？

1）继承spring-boot-starter-parent项目

2）导入spring-boot-dependencies项目依赖

## 22-7：如何使用 Spring Boot 实现异常处理？

Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。

## 22-8：如何使用 Spring Boot 实现分页和排序？

使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。

## 22-9：微服务中如何实现 session 共享 ?

在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。

Spring Boot 中如何实现定时任务 ?

定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。

在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。

使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。

使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。


## 10-10：Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

@ComponentScan：Spring组件扫描。

# -------------注解-----------------------------------------------------------
# 1.注解

## 1-1：@Autowired和@Resource的区别是什么？

1. @Resources按名字，是JDK的，@Autowired按类型，是Spring的。
2. @Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，
   如果允许null值，可以设置它required属性为false。
3. @Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上，
   但它默认按名称装配。名称可以通过@Resource的name属性指定，如果没有指定name属性，
   当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，
   当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。

## 1-2：@SpringBootApplication

这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。

我们可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。

@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。
@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类

```java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```

## 23-2：@Autowired

自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。

@Service
public class UserService {
  ......
}

@RestController
@RequestMapping("/users")
public class UserController {
   @Autowired
   private UserService userService;
   ......
}

## 23-3：@Component,@Repository,@Service, @Controller

@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

## 23-4：@RestController

@RestController注解是@Controller和@ResponseBody的合集,

表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。

## 23-5：@RestController与@Controller的区别

单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，

这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。

@Controller +@ResponseBody 返回 JSON 或 XML 形式数据

## 23-6：@Scope

声明 Spring Bean 的作用域，使用方法:

@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
四种常见的 Spring Bean 的作用域：

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。

## 23-7：Configuration

一般用来声明配置类，可以使用@Component注解替代，

不过使用Configuration注解声明配置类更加语义化。

@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}

## 23-8：@PathVariable和@RequestParam

@PathVariable用于获取路径参数，@RequestParam用于获取查询参数。

举个简单的例子：

@GetMapping("/klasses/{klassId}/teachers")
public List<Teacher> getKlassRelatedTeachers(
         @PathVariable("klassId") Long klassId,
         @RequestParam(value = "type", required = false) String type ) {
...
}
如果我们请求的 url 是：/klasses/{123456}/teachers?type=web

那么我们服务获取到的数据就是：klassId=123456,type=web。

## 23-9：@RequestBody

用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）

的 body 部分并且Content-Type 为 application/json 格式的数据，

接收到数据之后会自动将数据绑定到 Java 对象上去。

系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象。


## 23-10：@value(常用)

使用 @Value("${property}") 读取比较简单的配置信息：

@Value("${wuhan2020}")
String wuhan2020;

## 23-11：@ConfigurationProperties(常用)

通过@ConfigurationProperties读取配置信息并与 bean 绑定。

@Component
@ConfigurationProperties(prefix = "library")
class LibraryProperties {
    @NotEmpty
    private String location;
    private List<Book> books;

    @Setter
    @Getter
    @ToString
    static class Book {
        String name;
        String description;
    }
  省略getter/setter
  ......
}
你可以像使用普通的 Spring bean 一样，将其注入到类中使用。

## 23-12：PropertySource（不常用）

@PropertySource读取指定 properties 文件

@Component
@PropertySource("classpath:website.properties")

class WebSite {
    @Value("${url}")
    private String url;

  省略getter/setter
  ......
}


## 23-13：一些常用的字段验证的注解

@NotEmpty 被注释的字符串的不能为 null 也不能为空
@NotBlank 被注释的字符串非 null，并且必须包含一个非空白字符
@Null 被注释的元素必须为 null
@NotNull 被注释的元素必须不为 null
@AssertTrue 被注释的元素必须为 true
@AssertFalse 被注释的元素必须为 false
@Pattern(regex=,flag=)被注释的元素必须符合指定的正则表达式
@Email 被注释的元素必须是 Email 格式。
@Min(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Max(value)被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@DecimalMin(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@Size(max=, min=)被注释的元素的大小必须在指定的范围内
@Digits (integer, fraction)被注释的元素必须是一个数字，其值必须在可接受的范围内
@Past被注释的元素必须是一个过去的日期
@Future 被注释的元素必须是一个将来的日期
......
6.2. 验证请求体(RequestBody)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person {

    @NotNull(message = "classId 不能为空")
    private String classId;

    @Size(max = 33)
    @NotNull(message = "name 不能为空")
    private String name;

    @Pattern(regexp = "((^Man$|^Woman$|^UGM$))", message = "sex 值不在可选范围")
    @NotNull(message = "sex 不能为空")
    private String sex;

    @Email(message = "email 格式不正确")
    @NotNull(message = "email 不能为空")
    private String email;

}
我们在需要验证的参数上加上了@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException。

@RestController
@RequestMapping("/api")
public class PersonController {

    @PostMapping("/person")
    public ResponseEntity<Person> getPerson(@RequestBody @Valid Person person) {
        return ResponseEntity.ok().body(person);
    }
}
6.3. 验证请求参数(Path Variables 和 Request Parameters)
一定一定不要忘记在类上加上 Validated 注解了，这个参数可以告诉 Spring 去校验方法参数。

@RestController
@RequestMapping("/api")
@Validated
public class PersonController {

    @GetMapping("/person/{id}")
    public ResponseEntity<Integer> getPersonByID(@Valid @PathVariable("id") @Max(value = 5,message = "超过 id 的范围了") Integer id) {
        return ResponseEntity.ok().body(id);
    }
}
更多关于如何在 Spring 项目中进行参数校验的内容，请看《如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！》这篇文章。

1. 全局处理 Controller 层异常
介绍一下我们 Spring 项目必备的全局处理 Controller 层异常。

相关注解：

@ControllerAdvice :注解定义全局异常处理类
@ExceptionHandler :注解声明异常处理方法
如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出MethodArgumentNotValidException，我们来处理这个异常。

@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    /**
     * 请求参数异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) {
       ......
    }
}
更多关于 Spring Boot 异常处理的内容，请看我的这两篇文章：

SpringBoot 处理异常的几种常见姿势
使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！
8. JPA 相关
8.1. 创建表
@Entity声明一个类对应一个数据库实体。

@Table 设置表明

@Entity
@Table(name = "role")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    省略getter/setter......
}
8.2. 创建主键
@Id ：声明一个字段为主键。

使用@Id声明之后，我们还需要定义主键的生成策略。我们可以使用 @GeneratedValue 指定主键生成策略。

1.通过 @GeneratedValue直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
JPA 使用枚举定义了 4 中常见的主键生成策略，如下：

Guide 哥：枚举替代常量的一种用法

public enum GenerationType {

    /**
     * 使用一个特定的数据库表格来保存主键
     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,
     */
    TABLE,

    /**
     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做"序列(sequence)"的机制生成主键
     */
    SEQUENCE,

    /**
     * 主键自增长
     */
    IDENTITY,

    /**
     *把主键生成策略交给持久化引擎(persistence engine),
     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种
     */
    AUTO
}

@GeneratedValue注解默认使用的策略是GenerationType.AUTO

public @interface GeneratedValue {

    GenerationType strategy() default AUTO;
    String generator() default "";
}
一般使用 MySQL 数据库的话，使用GenerationType.IDENTITY策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。

2.通过 @GenericGenerator声明一个主键策略，然后 @GeneratedValue使用这个策略

@Id
@GeneratedValue(generator = "IdentityIdGenerator")
@GenericGenerator(name = "IdentityIdGenerator", strategy = "identity")
private Long id;
等价于：

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
jpa 提供的主键生成策略有如下几种：

public class DefaultIdentifierGeneratorFactory
  implements MutableIdentifierGeneratorFactory, Serializable, ServiceRegistryAwareService {

 @SuppressWarnings("deprecation")
 public DefaultIdentifierGeneratorFactory() {
  register( "uuid2", UUIDGenerator.class );
  register( "guid", GUIDGenerator.class );   // can be done with UUIDGenerator + strategy
  register( "uuid", UUIDHexGenerator.class );   // "deprecated" for new use
  register( "uuid.hex", UUIDHexGenerator.class );  // uuid.hex is deprecated
  register( "assigned", Assigned.class );
  register( "identity", IdentityGenerator.class );
  register( "select", SelectGenerator.class );
  register( "sequence", SequenceStyleGenerator.class );
  register( "seqhilo", SequenceHiLoGenerator.class );
  register( "increment", IncrementGenerator.class );
  register( "foreign", ForeignGenerator.class );
  register( "sequence-identity", SequenceIdentityGenerator.class );
  register( "enhanced-sequence", SequenceStyleGenerator.class );
  register( "enhanced-table", TableGenerator.class );
 }

 public void register(String strategy, Class generatorClass) {
  LOG.debugf( "Registering IdentifierGenerator strategy [%s] -> [%s]", strategy, generatorClass.getName() );
  final Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );
  if ( previous != null ) {
   LOG.debugf( "    - overriding [%s]", previous.getName() );
  }
 }

}
8.3. 设置字段类型
@Column 声明字段。

示例：

设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空

@Column(name = "user_name", nullable = false, length=32)
private String userName;
设置字段类型并且加默认值，这个还是挺常用的。

Column(columnDefinition = "tinyint(1) default 1")
private Boolean enabled;
8.4. 指定不持久化特定字段
@Transient ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。

如果我们想让secrect 这个字段不被持久化，可以使用 @Transient关键字声明。

Entity(name="USER")
public class User {

    ......
    @Transient
    private String secrect; // not persistent because of @Transient

}
除了 @Transient关键字声明， 还可以采用下面几种方法：

static String secrect; // not persistent because of static
final String secrect = “Satish”; // not persistent because of final
transient String secrect; // not persistent because of transient
一般使用注解的方式比较多。

8.5. 声明大字段
@Lob:声明某个字段为大字段。

@Lob
private String content;
更详细的声明：

@Lob
//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟 加载，而 FetchType. LAZY 表示延迟加载 ；
@Basic(fetch = FetchType.EAGER)
//columnDefinition 属性指定数据表对应的 Lob 字段类型
@Column(name = "content", columnDefinition = "LONGTEXT NOT NULL")
private String content;
8.6. 创建枚举类型的字段
可以使用枚举类型的字段，不过枚举字段要用@Enumerated注解修饰。

public enum Gender {
    MALE("男性"),
    FEMALE("女性");

    private String value;
    Gender(String str){
        value=str;
    }
}
@Entity
@Table(name = "role")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    @Enumerated(EnumType.STRING)
    private Gender gender;
    省略getter/setter......
}
数据库里面对应存储的是 MAIL/FEMAIL。

8.7. 增加审计功能
只要继承了 AbstractAuditBase的类都会默认加上下面四个字段。

@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}

我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:


@Configuration
@EnableJpaAuditing
public class AuditSecurityConfiguration {
    @Bean
    AuditorAware<String> auditorAware() {
        return () -> Optional.ofNullable(SecurityContextHolder.getContext())
                .map(SecurityContext::getAuthentication)
                .filter(Authentication::isAuthenticated)
                .map(Authentication::getName);
    }
}
简单介绍一下上面设计到的一些注解：

@CreatedDate: 表示该字段为创建时间时间字段，在这个实体被 insert 的时候，会设置值

@CreatedBy :表示该字段为创建人，在这个实体被 insert 的时候，会设置值

@LastModifiedDate、@LastModifiedBy同理。

@EnableJpaAuditing：开启 JPA 审计功能。

8.8. 删除/修改数据
@Modifying 注解提示 JPA 该操作是修改操作,注意还要配合@Transactional注解使用。

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {

    @Modifying
    @Transactional(rollbackFor = Exception.class)
    void deleteByUserName(String userName);
}
8.9. 关联关系
@OneToOne 声明一对一关系
@OneToMany 声明一对多关系
@ManyToOne声明多对一关系
MangToMang声明多对多关系
更多关于 Spring Boot JPA 的文章请看我的这篇文章：一文搞懂如何在 Spring Boot 正确中使用 JPA 。

9. 事务 @Transactional
在要开启事务的方法上使用@Transactional注解即可!

@Transactional(rollbackFor = Exception.class)
public void save() {
  ......
}

我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。

@Transactional 注解一般用在可以作用在类或者方法上。

作用于类：当把@Transactional 注解放在类上时，表示所有该类的public 方法都配置相同的事务属性信息。
作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。
更多关于关于 Spring 事务的内容请查看：

可能是最漂亮的 Spring 事务管理详解
一口气说出 6 种 @Transactional 注解失效场景
10. json 数据处理
10.1. 过滤 json 数据
@JsonIgnoreProperties 作用在类上用于过滤掉特定字段不返回或者不解析。

//生成json时将userRoles属性过滤
@JsonIgnoreProperties({"userRoles"})
public class User {

    private String userName;
    private String fullName;
    private String password;
    @JsonIgnore
    private List<UserRole> userRoles = new ArrayList<>();
}
@JsonIgnore一般用于类的属性上，作用和上面的@JsonIgnoreProperties 一样。


public class User {

    private String userName;
    private String fullName;
    private String password;
   //生成json时将userRoles属性过滤
    @JsonIgnore
    private List<UserRole> userRoles = new ArrayList<>();
}
10.2. 格式化 json 数据
@JsonFormat一般用来格式化 json 数据。：

比如：

@JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone="GMT")
private Date date;
10.3. 扁平化对象
@Getter
@Setter
@ToString
public class Account {
    @JsonUnwrapped
    private Location location;
    @JsonUnwrapped
    private PersonInfo personInfo;

  @Getter
  @Setter
  @ToString
  public static class Location {
     private String provinceName;
     private String countyName;
  }
  @Getter
  @Setter
  @ToString
  public static class PersonInfo {
    private String userName;
    private String fullName;
  }
}

未扁平化之前：

{
    "location": {
        "provinceName":"湖北",
        "countyName":"武汉"
    },
    "personInfo": {
        "userName": "coder1234",
        "fullName": "shaungkou"
    }
}
使用@JsonUnwrapped 扁平对象之后：

@Getter
@Setter
@ToString
public class Account {
    @JsonUnwrapped
    private Location location;
    @JsonUnwrapped
    private PersonInfo personInfo;
    ......
}
{
  "provinceName":"湖北",
  "countyName":"武汉",
  "userName": "coder1234",
  "fullName": "shaungkou"
}
11. 测试相关
@ActiveProfiles一般作用于测试类上， 用于声明生效的 Spring 配置文件。

@SpringBootTest(webEnvironment = RANDOM_PORT)
@ActiveProfiles("test")
@Slf4j
public abstract class TestBase {
  ......
}
@Test声明一个方法为测试方法

@Transactional被声明的测试方法的数据会回滚，避免污染测试数据。

@WithMockUser Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。

    @Test
    @Transactional
    @WithMockUser(username = "user-id-18163138155", authorities = "ROLE_TEACHER")
    void should_import_student_success() throws Exception {
        ......
    }



 SpringBoot自动配置原理

