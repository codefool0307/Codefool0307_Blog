# 1. 分布式事务理论

## 1.1 CAP

### 1.1.1 概念

CAP就是一致性、可用性、分区容忍性

### 1.1.2 一致性

#### 1.1.2.1 概念

对于分布式的存储系统，一个数据往往会存在多份进行存储。
那么对数据进行操作的时候，要么在所有的数据副本操作成功，要么在所有的数据副本操作失败
比如说，数据库主从集群模式下，对于应用程序从数据库读取数据的场景，如果要满足一致性：

- 如果说应用程序向主数据库写数据失败，那么向从数据库读取数据也失败
- 如果说应用程序向主数据库写数据成功，那么向从数据库读取数据也成功

#### 1.1.2.2 实现

1. 应用程序将数据写入主数据库后，将数据同步到从数据库中
2. 数据写入到主数据库后，主数据库将数据同步到从数据库会存在一定的时间延时，这个过程需要将从数据库锁定
   等待数据同步完成之后再释放从数据库锁

#### 1.1.2.3 特点

1. 存在数据同步过程，可能有延时
2. 为了保证各个节点的一致性，需要对相应的资源进行锁定。

### 1.1.3 可用性

#### 1.1.3.1 概念

客户端访问数据的时候，能够得到快速响应，但是这个时候，各个存储节点的数据可能会不一致，
也就是说，我应用程序往数据库写入了数据，但是呢，可用性并不需要读取最新的数据。

#### 1.1.3.2 实现

1. 应用程序将数据写入主数据库后，将数据同步到从数据库中
2. 数据写入到主数据库后，主数据库将数据同步到从数据库这个过程不再需要将从数据库锁定
3. 应用程序向从数据库查询数据的时候，从数据库一定要返回数据，如果这个时候主从数据同步没有开始，也是要返回的，

#### 1.1.3.3 特点

1. 所有的请求都会被相应都会被相应

### 1.1.4 分区容忍性

#### 1.1.4.1 概念

因为如果只把存储系统部署到一个系统里，如果出现故障，整个系统都不能用了，
但是如果把存储系统部署到多个不同的节点，因为这些节点在不用的网络中，就会出现网络问题，导致某节点间的通信出现问题
但是呢，系统还能提供对外服务

#### 1.1.4.2 实现

1. 应用程序将数据写入主数据库后，将数据同步到从数据库中，用异步方式代替同步方式
2. 一个节点挂了没事，其他节点那还能继续提供服务

#### 1.1.4.3 特点

## 1.2 Base理论

### 1.2.1 概念

因为在CAP理论使用过程中，通常采用AP组合，Base理论主要是对AP组合的一种扩展，
就是说，当系统出现故障的时候，

- base理论允许部分数据不可用，但是会保证核心功能可以用
- 允许数据在一段时间内不一致，但是经过一段时间，数据也要保持一致

### 1.2.2 基本可用

### 1.2.3 软状态

比如说，我买东西的时候，可能会出现，支付中的状态，但是最后还是会变成支付成功

这个“支付中”的状态也就是一个软状态，或者说是一个中间状态

### 1.2.4 基本可用

# 2.分布式事务应用场景

# 3.分布式事务架构

# 4.分布式事务解决方案

## 4.1 解决方案

1. 强一致性事务
2. 最终一致性事务

# 5.强一致性分布式事务

## 5.1 概念

在任意时刻，读取任意节点上的数据都是最新写入的（一个孩子就不管什么时候都要最新的）

## 5.2 适用场景

比如说银行业务肯定是要用强一致性事务的
比如说，a给b转了100块钱，b的账户肯定要少100，a的账户增加100，一定要保证要么都执行，要么都不执行

## 5.3 优缺点

1. 对数据一致性要求比较高
2. 任意时刻的数据都是最新的
但是呢，缺点就是
1. 在分布式事务没有完全提交和回滚之前，是不会查到最新数据的
2. 实现很复杂

## 5.4 方案

1. DTP模型
2. 2PC模型
3. 3PC模型

## 5.(4-1) DTP

### 5.(4-1).1 概念

dtp定义了全局事务、分支事务和控制线程

全局事务是`事务管理器`管理的事务，能够一次性操作多个资源管理器
分支事务是事务管理器管理的全局事务中，每个`资源管理器`中能够独立执行的事务
控制线程主要是执行全局事务的线程，

### 5.(4-1).2 执行流程


### 5.(4-1).3 存在的问题

## 5.(4-2) 2PC

### 5.(4-2).1 概念

### 5.(4-2).2 执行流程

主要是分为了两部分：`prepare阶段`和`commit阶段`

1. prepare阶段
   在prepare阶段，事务管理器给每个参与全局事务的资源管理器发送prepare消息，资源管理器要么返回失败，
   要么在本地执行相应的事务，将事务写入到本地的redolog文件和undolog文件，这个时候，事务还没有提交
   但是呢，资源管理器会往事务管理器发送消息
2. commit阶段
   如果事务管理器收到了资源管理器返回来的消息，这类资源管理器主要是参与全局事务管理器的资源管理器
   - 如果说收到的是失败的消息，那么直接给prepare阶段执行成功的资源管理器发送回滚消息，
   - 如果说收到的是成功的消息，向每个资源管理器发送commit消息
   并且释放事务处理过程中的锁资源

### 5.(4-2).3 存在的问题

1. 同步阻塞问题
   事务执行的过程中，参与事务的节点资源都会进行加锁操作，导致其他访问这个资源的进程或者线程阻塞
2. 单点故障问题
   如果事务管理器发生了故障，那么资源管理器会一直阻塞
3. 数据不一致问题
   如果commit阶段，因为网络问题，有一部分资源管理器没有收到commit指令，那么就会数据不一致

## 5.(4-3) 3PC

### 5.(4-3).1 概念

在2PC的基础上，把2PC的prepare阶段分为了两个阶段

### 5.(4-3).2 执行流程

1. CanCommit阶段
   事务管理器给每个参与全局事务的资源管理器发送CanCommit消息
    - 如果资源管理器认为`不能`执行事务，就会向事务管理器发送`no消息`
    - 如果资源管理器认为`可以`执行事务，就会向事务管理器发送`yes消息`
2. PreCommit阶段
   - 如果收到了`yes消息`的话，事务管理器会给资源管理器发送precommit消息，资源管理器收到消息之后，执行事务操作
                           将undo和redo信息写入事务日志，并将事务管理器相应一个ack状态，这个时候不会提交事务
   - 如果收到了`no消息`的话，事务管理器会给资源管理器发送abort消息，资源管理器收到之后，会中断事务的执行，同时返回一个ack消息
3. doCommit阶段
   - 如果响应了ack状态，事务管理器会给资源管理器发送docommit消息，资源管理器收到消息后，
                     会正式提交事务，并释放资源同时响应资源管理器，完成事务提交
   - 如果收到了ack消息，事务管理器会给资源管理器发送rollback消息，资源管理器会利用undolog日志回滚事务，
                     并释放资源，

### 5.(4-3).3 存在的问题

1. 数据不一致
2. 网络延时

# 6.最终一致性分布式事务

## 6.1 概念

不要求数据时时刻刻都是相等的，允许有一个中间状态，只要过一段时间，能够达到数据的最终一致就可以了

## 6.2 适用场景

比如在支付中，会有订单服务、支付服务、库存服务、积分服务等等，很多种服务，而且每个服务都是单独部署的


## 6.3 优缺点

1. 性能较高，不用要求数据时刻保护一直，不会因为长时间持有事务占用的资源而消耗太多的性能
2. 适合高并发场景
但是呢，缺点就是
   因为数据存在短暂的数据一致性，所以在某个时刻查询出来的数据状态可能不一致，对于一些场景不太适合，
   比如说资金交易等等吧

## 6.4 服务模式

1. 可查询操作
2. 幕等操作
3. TCC操作

## 6.4 方案

1. TCC
2. 可靠消息最终一致性
3. 最大努力通知型

## 6.(4-1) TCC

### 6.(4-1).1 三阶段

1. try阶段
2. confirm阶段
3. cancel阶段

### 6.(4-1).2 执行流程

1. try阶段
   不会执行任何业务逻辑，只是做业务的一致性检查和预留相应的资源
   比如说，我买了一个东西，提交订单之后，订单的状态就设置为待提交，然后再数据库中传递字段，也就是商品数量
2. confirm阶段
   当try阶段操作全部执行成功，那么开始执行confirm阶段， 在confirm阶段，TCC认为confirm阶段是不会出现错误的
   - 也就是说如果try执行成功，confirm一定会执行成功
   - 如果confirm出现问题，那么需要引入`重试机制`或者`人工干预`了
   比如说，在confirm阶段，订单服务会把订单数据的状态标记为已提交，然后在数据库中，实现真正的减库存操作
3. Cancel阶段
   如果try解读那执行异常或者失败，那么就会执行cancle阶段，并释放try阶段预留的资源
   - TCC认为try阶段是不会出现错误的
   - 如果cancel出现错误，那么需要引入`重试机制`或者`人工干预`了
   比如说，订单服务奖订单数据标记为已取消状态，数据库实现回滚操作

### 6.(4-1).3 优缺点

优点：
   1. 不会锁定所有的资源，提高了性能
   2. 
   1. 


### 6.(4-1).4 注意事项



## 6.(4-2) 可靠消息最终一致性

### 6.(4-2).1 概念

dtp定义了全局事务、分支事务和控制线程

全局事务是`事务管理器`管理的事务，能够一次性操作多个资源管理器
分支事务是事务管理器管理的全局事务中，每个`资源管理器`中能够独立执行的事务
控制线程主要是执行全局事务的线程，

### 6.(4-2).2 执行流程


### 6.(4-2).3 存在的问题

## 6.(4-3) 最大努力通知型

### 6.(4-3).1 概念

dtp定义了全局事务、分支事务和控制线程

全局事务是`事务管理器`管理的事务，能够一次性操作多个资源管理器
分支事务是事务管理器管理的全局事务中，每个`资源管理器`中能够独立执行的事务
控制线程主要是执行全局事务的线程，

### 6.(4-3).2 执行流程


### 6.(4-3).3 存在的问题













# 80.分布式事务

## XA事务

### 概念

XA事务是一种基于两阶段提交的分布式事务，在使用XA分布式事务的嘶吼，innodb的事务隔离级别会设置为串性化

### 组成

1. 事务管理器
2. 资源管理器
3. 应用程序

### 过程

由于XA事务是基于两阶段提交的分布式事务，所以也是分成了prepare阶段和commit阶段

1. prepare阶段
   事务管理器向资源管理器发送准备指令，资源管理器收到指令之后，执行数据的修改操作并记录相关的日志信息，
   然后向事务管理器返回可以提交或者不可以提交的结果信息。
2. commit阶段
   事务管理器接收了所有的资源管理器返回的结果信息，
   - 如果某一个或者多个资源管理器向事务管理器返回的结果信息是`不可以提交`的，或者说超时，
     那么事务管理器向所有资源管理器发送`回滚指令`，
   - 如果事务管理器收到了所有的资源管理器返回的结果信息是`可以提交`的
     那么事务管理器向所有的资源管理器发送`提交事务`的指令。

## 数据一致性

### 分类

1. 数据多副本
2. 调用超时
3. 缓存与数据库不一致
4. 多个缓存节点数据不一致

# ---------------------------------------------------------------------------------------

# 7.分布式主键

## 7.1 方案

1. UUID
2. 数据库自增ID
3. 数据库多主模式
4. 号段模式
5. Redis
6. 雪花算法（SnowFlake）

## 7.2 UUID

### 7.2.1 特点

UUID可以生成一个唯一性id，但是，对于数据库来说主键不宜太长

### 7.2.2 优缺点

优点：生成足够简单，本地生成无网络消耗，具有唯一性
缺点：
   1. 无序的字符串，不具备趋势自增特性
   2. 长度过长，存储以及查询对MySQL的性能消耗较大
   3. 作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。

## 7.3 基于数据库自增ID

### 7.3.1 特点

需要一个单独的MySQL实例用来生成ID，
当我们需要一个ID的时候，向表中插入一条记录返回主键ID，但这种方式有一个比较致命的缺点，
访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大

### 7.3.2 优缺点

优点：实现简单，ID单调自增，数值类型查询速度快
缺点：DB单点存在宕机风险，无法扛住高并发场景

## 7.4 基于数据库集群模式

### 7.4.1 特点

可以采用主从模式或者多主模式，同时为了解决重复的id，一般是对于不同的数据库设置不同的步长就好了
比如说
mysql1设置起始值是1，步长是2
mysql1设置起始值是2，步长是2

但是吧，万一增加了第三台mysql服务器，需要对第一、二台服务器进行重新设置

### 7.4.2 优缺点

优点：解决DB单点问题
缺点：
   1. 不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。

## 7.5 基于数据库的号段模式

### 7.5.1 特点

每次从数据库取出一个号段范围，那么这个业务就用这个号段范围的数据，如果说不够用了，再重新申请
同时有可能很多业务端都进行操作，那么采用版本号version乐观锁进新更新

### 7.5.2 优缺点

优点：不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多
缺点：

## 7.6 基于Redis模式

### 7.6.1 特点

利用redis的 incr命令实现ID的原子性自增，但是要考虑到redis的持久化问题
   - RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。
   - AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，
     会导致Redis重启恢复的数据时间过长。

### 7.6.2 优缺点


## 7.7 基于雪花算法（Snowflake）模式

### 7.7.1 特点

Snowflake生成的是Long类型的ID，主要由
正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特）
构成



### 7.7.2 优缺点

优点：生成足够简单，本地生成无网络消耗，具有唯一性
缺点：
   1. 无序的字符串，不具备趋势自增特性
   2. 长度过长，存储以及查询对MySQL的性能消耗较大
   3. 作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。






## 82.1 产生原因

当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，也就是那些物理分区，
分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，
而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，
最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，
这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理

# ---------------------------------------------------------------------------------------

# 分布式锁

## 为什么要有分布式锁

比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，
如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，
导致数据库的数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。
而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，
如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。

## 特点

互斥性： 同一时刻只能有一个线程持有锁
可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁
锁超时：和J.U.C中的锁一样支持锁超时，防止死锁
高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效
具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒

## 分布式锁安全问题

在GC的时候会发生STW(stop-the-world),例如CMS垃圾回收器，他会有两个阶段进行STW防止引用继续进行变化
会出现比如说，
1. client1获取了锁并且设置了锁的超时时间，但是client1之后出现了STW，这个STW时间比较长，导致分布式锁进行了释放，
   client2获取到了锁，这个时候client1恢复了锁，那么就会出现client1，2同时获取到锁，这个时候分布式锁不安全问题就出现了。
2. 还有就是时钟发生跳跃
3. 还有长时间的网络io
   主要是我们这个获取了锁之后我们进行网络调用，其调用时间由可能比我们锁的过期时间都还长，那么也会出现不安全的问题

## 常见的分布式锁

1. Zookeeper
2. Redis
3. Mysql

## Redis实现分布式锁

### 方案

方案一：SETNX + EXPIRE
方案二：SETNX + value值是（系统时间+过期时间）
方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)
方案四：SET的扩展命令（SET EX PX NX）
方案五：SET EX PX NX  + 校验唯一随机值,再释放锁
方案六: 开源框架:Redisson
方案七：多机实现的分布式锁Redlock

### SETNX + EXPIRE

先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记了释放。
但是这个方式会存在一个缺陷就是setnx和expire是分开的两步操作，不具有原子性，
如果执行完第一条指令应用异常或者重启了，锁将无法过期。
所以就需要使用Lua脚本来保证原子性

### Lua脚本

### SETNX + value值是（系统时间+过期时间）

巧妙移除expire单独设置过期时间的操作，把过期时间放到setnx的value值里面来。解决了`方案一`发生异常，锁得不到释放的问题。
但是也存在问题
   过期时间是客户端自己生成的，必须要求分布式环境下，每个客户端的时间必须同步。
   如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，
   最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖
   该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。

### SET的扩展命令（SET EX PX NX）

保证了原子性，但是存在
   1. 比如说锁过期释放了，业务还没执行完。假设线程a获取锁成功，一直在执行临界区的代码。
      但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。
      显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。
   2. 还有就是锁被别的线程误删。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的
      线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁。那线程a就把线程b的锁释放掉了，
      但是线程b临界区业务代码可能都还没执行完呢。

### SET EX PX NX + 校验唯一随机值,再删除

锁可能被别的线程误删，那我们给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下
但是可能存在锁过期释放，业务没有执行完的问题

### Redisson框架

开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。

主要思路就是：
只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，
如果线程1还持有锁，那么就会不断的延长锁key的生存时间。
因此，Redisson就是使用Redisson解决了锁过期释放，业务没执行完问题。



