<!-- TOC -->

- [1.java基础-java特性](#1java基础-java特性)
  - [1-1：java特点](#1-1java特点)
- [2.java基础-面对对象-综述](#2java基础-面对对象-综述)
  - [2-1：面对对象三大特征(特点)](#2-1面对对象三大特征特点)
  - [2-2：面对对象的五大原则](#2-2面对对象的五大原则)
  - [2-3：Java创建对象方式](#2-3java创建对象方式)
  - [2-4：new abc是在堆里面呢？](#2-4new-abc是在堆里面呢)
  - [2-4：⾯向过程性能⽐⾯向对象⾼](#2-4向过程性能向对象)
- [3.java基础-面对对象-多态](#3java基础-面对对象-多态)
  - [3-1：多态的必要条件（实现方式、机制）](#3-1多态的必要条件实现方式机制)
  - [3-3：多态的好处](#3-3多态的好处)
  - [3-4：多态的例子](#3-4多态的例子)
- [4.java基础-面对对象-重载与重写](#4java基础-面对对象-重载与重写)
  - [4-1：重载与重写](#4-1重载与重写)
  - [4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？](#4-2java-中是否可以覆盖override一个-private-或者是-static-的方法)
- [5.java基础-面对对象-接口与抽象类](#5java基础-面对对象-接口与抽象类)
  - [5-1：接⼝和抽象类的区别是什么？](#5-1接和抽象类的区别是什么)
  - [5-2：Java 抽象类可以有构造函数吗？作用是什么](#5-2java-抽象类可以有构造函数吗作用是什么)
  - [5-3: Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗？](#5-3-java-抽象类可以实现接口吗-它们需要实现所有的方法吗)
  - [5-4：Java 抽象类可以是 final 的吗？](#5-4java-抽象类可以是-final-的吗)
  - [5-5：Java 抽象类可以有 static 方法吗？](#5-5java-抽象类可以有-static-方法吗)
  - [5-6：可以创建抽象类的实例吗？](#5-6可以创建抽象类的实例吗)
  - [5-7：抽象类必须有抽象方法吗？](#5-7抽象类必须有抽象方法吗)
  - [5-8：何时选用抽象类而不是接口？](#5-8何时选用抽象类而不是接口)
  - [5-9：Java中的抽象方法是什么？](#5-9java中的抽象方法是什么)
  - [5-10：Java抽象类中可以包含main方法吗？](#5-10java抽象类中可以包含main方法吗)
  - [5-11：创建⼀个对象⽤什么运算符?对象实体与对象引⽤有何不同?](#5-11创建个对象什么运算符对象实体与对象引有何不同)
  - [5-12：interface实现方法](#5-12interface实现方法)
- [6.java基础-值传递与引用传递](#6java基础-值传递与引用传递)
- [7.java基础-深拷贝与浅拷贝](#7java基础-深拷贝与浅拷贝)
  - [7-1：深拷贝与浅拷贝](#7-1深拷贝与浅拷贝)
  - [7-2：浅拷贝方法](#7-2浅拷贝方法)
  - [7-3：深拷贝方法](#7-3深拷贝方法)
- [8.java基础-面对对象-构造器](#8java基础-面对对象-构造器)
  - [8-1：⼀个类的构造⽅法的作⽤是什么? 若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? 为什么?](#8-1个类的构造法的作是什么-若个类没有声明构造法该程序能正确执吗-为什么)
  - [8-2：构造⽅法有哪些特性？](#8-2构造法有哪些特性)
- [9.java基础-面对对象-静态与非静态](#9java基础-面对对象-静态与非静态)
  - [9-1：静态⽅法和实例⽅法有何不同](#9-1静态法和实例法有何不同)
  - [9-2：静态变量和实例变量的区别？](#9-2静态变量和实例变量的区别)
- [10.java基础-运算符-相等问题](#10java基础-运算符-相等问题)
  - [10-1： == 与 equals](#10-1--与-equals)
  - [10-2：为什么要重写hashcode与equals](#10-2为什么要重写hashcode与equals)
  - [10-3：重写equals不重写hashcode会出现什么问题](#10-3重写equals不重写hashcode会出现什么问题)
  - [10-4：为什么两个对象有相同的hashcode值，它们也不一定是相等的？](#10-4为什么两个对象有相同的hashcode值它们也不一定是相等的)
  - [10-5：hashcode和equals源码写一下](#10-5hashcode和equals源码写一下)
  - [10-5：说说&和&&的区别。](#10-5说说和的区别)
  - [10-6：用最有效率的方法算出 2 乘以 8 等于几?](#10-6用最有效率的方法算出-2-乘以-8-等于几)
  - [10-7：i++和++i的区别，及其线程安全问题](#10-7i和i的区别及其线程安全问题)
- [11.java基础-数据类型-8种常见类型](#11java基础-数据类型-8种常见类型)
  - [11-1：八种数据类型是什么？-中兴](#11-1八种数据类型是什么-中兴)
  - [11-2：数据类型的范围](#11-2数据类型的范围)
  - [11-3：为什么byte类型是-128~+127](#11-3为什么byte类型是-128127)
  - [11-4：java为什么除了基本数据类型还要有引用数据类型](#11-4java为什么除了基本数据类型还要有引用数据类型)
  - [11-5：String为什么不是基本数据类型-字节](#11-5string为什么不是基本数据类型-字节)
- [12.java基础-数据类型-自动拆装箱](#12java基础-数据类型-自动拆装箱)
  - [12-1：为什么要有自动拆装箱](#12-1为什么要有自动拆装箱)
  - [12-2：Integer缓存机制](#12-2integer缓存机制)
  - [12-3：自动拆装箱的原理](#12-3自动拆装箱的原理)
  - [12-4：自动拆装箱使用场景](#12-4自动拆装箱使用场景)
  - [12-5：自动拆装箱带来的问题](#12-5自动拆装箱带来的问题)
  - [12-6：String转出int型， 判断能不能转？ 如何转？](#12-6string转出int型-判断能不能转-如何转)
  - [12-7：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?](#12-7short-s1--1-s1--s1--1有什么错-short-s1--1-s11有什么错)
  - [12-8：int与Integer区别](#12-8int与integer区别)
- [13.java基础-关键字-访问权限关键字](#13java基础-关键字-访问权限关键字)
  - [13-1：访问控制关键字级别](#13-1访问控制关键字级别)
  - [13-2: 通过反射访问private成员和方法，既然能访问为什么要private？](#13-2-通过反射访问private成员和方法既然能访问为什么要private)
- [14.java基础-关键字-static](#14java基础-关键字-static)
  - [14-1：static使用场景](#14-1static使用场景)
- [15.java基础-关键字-final关键字](#15java基础-关键字-final关键字)
  - [15-1：final关键字使用特点](#15-1final关键字使用特点)
  - [15-2：final, finally, finalize 的区别。](#15-2final-finally-finalize-的区别)
  - [15-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？](#15-3使用-final-关键字修饰一个变量时是引用不能变还是引用的对象不能变)
- [16.java基础-关键字-this关键字和super关键字](#16java基础-关键字-this关键字和super关键字)
- [17.java基础-关键字-transient](#17java基础-关键字-transient)
- [18.java基础-集合map-hashmap的数据结构](#18java基础-集合map-hashmap的数据结构)
  - [18-1：hashmap的数据结构](#18-1hashmap的数据结构)
  - [18-2：扩容死循环问题](#18-2扩容死循环问题)
  - [18-2；为什么JDK8时候引入了红黑树？](#18-2为什么jdk8时候引入了红黑树)
  - [18-3：为什么不把链表全部换为红黑树](#18-3为什么不把链表全部换为红黑树)
  - [18-4：为什么是使用红黑树而不是AVL树？](#18-4为什么是使用红黑树而不是avl树)
  - [18-5：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？](#18-5为什么在jdk17的时候是先进行扩容后进行插入而在jdk18的时候则是先插入后进行扩容的呢)
  - [18-6：为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）](#18-6为什么在jdk18中进行对hashmap优化的时候把链表转化为红黑树的阈值是8而不是7或者不是20呢面试蘑菇街问过)
  - [18-7：扰动函数以及作用](#18-7扰动函数以及作用)
  - [18-8：哈希冲突的解决方法](#18-8哈希冲突的解决方法)
  - [18-9：HashMap的put操作](#18-9hashmap的put操作)
  - [18-10：HashMap的get操作](#18-10hashmap的get操作)
  - [18-11：hashmap的get和put操作的时间复杂度](#18-11hashmap的get和put操作的时间复杂度)
  - [18-12：hashmap的String类型如何计算hashcode的](#18-12hashmap的string类型如何计算hashcode的)
  - [18-13：reHash过程](#18-13rehash过程)
  - [18-14：hash函数以及常用方法](#18-14hash函数以及常用方法)
  - [18-15：HashMap为什么要树化?](#18-15hashmap为什么要树化)
  - [18-16：hashmap树化门槛及作用](#18-16hashmap树化门槛及作用)
  - [18-17：hashmap的特性](#18-17hashmap的特性)
  - [18-18：HashMap为什么可以插入空值?](#18-18hashmap为什么可以插入空值)
  - [18-19：JDK的hashmap与Redis的hashmap的区别](#18-19jdk的hashmap与redis的hashmap的区别)
  - [18-20：为什么要两次hash](#18-20为什么要两次hash)
- [19.java基础-集合map-hashmap源码数值分析](#19java基础-集合map-hashmap源码数值分析)
  - [19-1：HashMap中(tab.length - 1) & hash作用](#19-1hashmap中tablength---1--hash作用)
  - [19-2：请解释一下HashMap的参数loadFactor，它的作用是什么？](#19-2请解释一下hashmap的参数loadfactor它的作用是什么)
  - [19-3：HashMap的扩容因子为什么是0.75](#19-3hashmap的扩容因子为什么是075)
  - [19-4：为什么默认初始化桶数组大小为16](#19-4为什么默认初始化桶数组大小为16)
  - [19-5：hashmap为什么是2的次幂](#19-5hashmap为什么是2的次幂)
- [20.java基础-集合map-hashmap线程问题](#20java基础-集合map-hashmap线程问题)
  - [20-1：hashMap是否线程安全](#20-1hashmap是否线程安全)
  - [20-2：为什么hashmap中String、integer包装类适合作为key](#20-2为什么hashmap中stringinteger包装类适合作为key)
  - [20-3：线程安全的Map](#20-3线程安全的map)
  - [20-4：设计线程安全的map](#20-4设计线程安全的map)
- [21.java基础-集合map-ConcurrentHashMap](#21java基础-集合map-concurrenthashmap)
  - [21-1：ConcurrentHashMap的底层实现](#21-1concurrenthashmap的底层实现)
  - [21-2：为何会出现ConcurrenHashMap?](#21-2为何会出现concurrenhashmap)
  - [21-3：为什么ConcurrentHashMap（hashtable）为何不支持null键和null值](#21-3为什么concurrenthashmaphashtable为何不支持null键和null值)
  - [21-4：ConcurrentHashMap的put操作](#21-4concurrenthashmap的put操作)
  - [21-5：分段锁原理](#21-5分段锁原理)
  - [21-6：hashmap与ConcurrentHashMap中put的区别](#21-6hashmap与concurrenthashmap中put的区别)
  - [21-7：扩容机制](#21-7扩容机制)
  - [21-8：什么时候会发生扩容机制](#21-8什么时候会发生扩容机制)
- [22.java基础-集合map-TreeMap](#22java基础-集合map-treemap)
  - [22-1：TreeMap底层原理：](#22-1treemap底层原理)
  - [22-2：使用场景](#22-2使用场景)
- [23.java基础-集合map-LinkedHashmap](#23java基础-集合map-linkedhashmap)
  - [23-1：linkedhashmap的底层原理](#23-1linkedhashmap的底层原理)
- [24.java基础-集合map-HashTable](#24java基础-集合map-hashtable)
  - [24-1：HashTable的底层原理](#24-1hashtable的底层原理)
- [25.java基础-集合list-ArrayList](#25java基础-集合list-arraylist)
  - [25-1：数组(Array)和列表(ArrayList)有什么区别？ 什么时候应该使用 Array 而不是ArrayList？](#25-1数组array和列表arraylist有什么区别-什么时候应该使用-array-而不是arraylist)
  - [25-2：扩容机制](#25-2扩容机制)
  - [25-3：ArrayList的add操作](#25-3arraylist的add操作)
  - [25-4：Arraylist初始大小以及扩容大小](#25-4arraylist初始大小以及扩容大小)
  - [25-5：那如何解决ArrayList线程不安全问题呢？](#25-5那如何解决arraylist线程不安全问题呢)
- [26.java基础-集合list-vector](#26java基础-集合list-vector)
  - [26-1：Vector是保证线程安全的](#26-1vector是保证线程安全的)
- [27.java基础-集合list-linkedlist](#27java基础-集合list-linkedlist)
- [28.java基础-集合set-HashSet](#28java基础-集合set-hashset)
  - [28-1：hashset原理](#28-1hashset原理)
  - [28-2：hashSet的内存泄漏](#28-2hashset的内存泄漏)
  - [28-3：为什么HashSet不安全](#28-3为什么hashset不安全)
  - [28-4：如何保证线程安全](#28-4如何保证线程安全)
- [29.java基础-集合set-TreeSet](#29java基础-集合set-treeset)
  - [29-1：TreeSet原理](#29-1treeset原理)
- [30.java基础-集合set-LinkedSet](#30java基础-集合set-linkedset)
  - [30-1：LinkedSet原理](#30-1linkedset原理)
- [31.java基础-集合-集合大比较（区别和使用场景）](#31java基础-集合-集合大比较区别和使用场景)
  - [31-1：set和list、map的区别](#31-1set和listmap的区别)
  - [31-2：arraylist、linkedlist区别和适用场景](#31-2arraylistlinkedlist区别和适用场景)
  - [31-3：vector、Arraylist区别和适用场景](#31-3vectorarraylist区别和适用场景)
  - [31-4：HashMap、Treemap、linkedHashMap区别和适用场景](#31-4hashmaptreemaplinkedhashmap区别和适用场景)
  - [31-5：HashTable、Hashmap区别和适用场景](#31-5hashtablehashmap区别和适用场景)
  - [31-6： ConcurrentHashMap、Hashmap区别和适用场景](#31-6-concurrenthashmaphashmap区别和适用场景)
  - [31-7： Hashset、Hashmap区别和适用场景](#31-7-hashsethashmap区别和适用场景)
  - [31-8：treeset、hashset区别和适用场景](#31-8treesethashset区别和适用场景)
  - [31-9：JAVA集合类](#31-9java集合类)
  - [31-10：并发集合](#31-10并发集合)
  - [31-11：并发集合出现的原因](#31-11并发集合出现的原因)
  - [31-11：collection与collections的区别](#31-11collection与collections的区别)
  - [31-12：Collections有哪些静态方法](#31-12collections有哪些静态方法)
  - [31-13：Comparable和Comparator区别](#31-13comparable和comparator区别)
- [32.java基础-设计类问题](#32java基础-设计类问题)
  - [32-1：如果想要一个key对应多个Value的话，怎么设计Map](#32-1如果想要一个key对应多个value的话怎么设计map)
  - [32-2：插入一万个元素之后会不会扩容，扩容扩多少](#32-2插入一万个元素之后会不会扩容扩容扩多少)
  - [32-3：创建一个对象HashMap<Integer,Integer> map=new HashMap<>先put(10),然后get(new Long(10))结果是多少？](#32-3创建一个对象hashmapintegerinteger-mapnew-hashmap先put10然后getnew-long10结果是多少)
  - [32-4：两个线程同时操作一个集合，一个线程读，一个线程写。有可能会产生并发问题吗？](#32-4两个线程同时操作一个集合一个线程读一个线程写有可能会产生并发问题吗)
- [33.java基础-IO-各种流](#33java基础-io-各种流)
  - [33-1：为何还要有字符流](#33-1为何还要有字符流)
  - [33-2：字节流和字符流区别](#33-2字节流和字符流区别)
  - [33-3：同步、异步与阻塞、非阻塞](#33-3同步异步与阻塞非阻塞)
  - [33-4：BIO\NIO\AIO区别](#33-4bionioaio区别)
  - [33-5：linux的5种IO模型](#33-5linux的5种io模型)
  - [33-6：IO多路复用](#33-6io多路复用)
  - [33-7：三种常用的实现方式-select](#33-7三种常用的实现方式-select)
  - [33-8：三种常用的实现方式-poll](#33-8三种常用的实现方式-poll)
  - [33-9：三种常用的实现方式-epoll](#33-9三种常用的实现方式-epoll)
  - [33-10：三种常用的实现方式区别](#33-10三种常用的实现方式区别)
- [34.java基础-反射](#34java基础-反射)
  - [34-1：什么是反射](#34-1什么是反射)
  - [34-2：反射会导致性能问题呢？](#34-2反射会导致性能问题呢)
  - [34-3：如果避免反射导致的性能问题？](#34-3如果避免反射导致的性能问题)
  - [34-2：获取class对象方法](#34-2获取class对象方法)
  - [34-3：Class.forName和classloader.loadClass的区别](#34-3classforname和classloaderloadclass的区别)
  - [34-4：哪些类不能反射](#34-4哪些类不能反射)
  - [34-5：反射优缺点](#34-5反射优缺点)
  - [34-6：反射的应用场景](#34-6反射的应用场景)
- [35.java基础-注解](#35java基础-注解)
  - [35-1：元注解以及分类](#35-1元注解以及分类)
  - [35-2：Java常用注解](#35-2java常用注解)
- [36.java基础-泛型](#36java基础-泛型)
  - [36-1：什么是泛型](#36-1什么是泛型)
  - [36-2：编译器如何处理泛型](#36-2编译器如何处理泛型)
  - [36-3：为什么Java要用这种编译器](#36-3为什么java要用这种编译器)
  - [36-4: 什么是类型擦除](#36-4-什么是类型擦除)
  - [36-5：类型擦除过程](#36-5类型擦除过程)
  - [36-6：泛型带来的问题](#36-6泛型带来的问题)
  - [36-7：List泛型和原始类型List之间的区别?](#36-7list泛型和原始类型list之间的区别)
  - [36-8：List泛型和原始类型List泛型之间的区别?](#36-8list泛型和原始类型list泛型之间的区别)
  - [36-9:子类继承父类的public可以写成private吗](#36-9子类继承父类的public可以写成private吗)
  - [36-10：多态时是否会出现类型擦除](#36-10多态时是否会出现类型擦除)
- [37-java基础-异常](#37-java基础-异常)
  - [37-1：异常的分类](#37-1异常的分类)
  - [37-2：Java 中的两种异常类型是什么？ 他们有什么区别？](#37-2java-中的两种异常类型是什么-他们有什么区别)
  - [37-3：异常类型](#37-3异常类型)
  - [37-4：什么是OOM？常见有哪些OOM？](#37-4什么是oom常见有哪些oom)
  - [37-3：异常链](#37-3异常链)
- [38.java基础-常用类-String](#38java基础-常用类-string)
  - [38-1：String为什么是final的？](#38-1string为什么是final的)
  - [38-2：拼接方式](#38-2拼接方式)
  - [38-3: String、StringBuffer和StringBuilder区别](#38-3-stringstringbuffer和stringbuilder区别)
  - [38-4：StringBuffer如何实现线程安全](#38-4stringbuffer如何实现线程安全)
  - [38-5：String 和 char[] 数组谁更适合存密码](#38-5string-和-char-数组谁更适合存密码)
  - [38-6：String str = new String("abc");创建了几个对象-百度，京东](#38-6string-str--new-stringabc创建了几个对象-百度京东)
  - [38-7：处理数据量较大的字符串用string还是stringbuilder，为什么](#38-7处理数据量较大的字符串用string还是stringbuilder为什么)
  - [38-8：为什么StringBuffer和StringBuilder比String更快（不变性）](#38-8为什么stringbuffer和stringbuilder比string更快不变性)
  - [38-9：如何把一段逗号分割的字符串转换成一个数组?](#38-9如何把一段逗号分割的字符串转换成一个数组)
  - [38-10：String的内部属性](#38-10string的内部属性)
  - [38-11：String的常用方法](#38-11string的常用方法)
- [39.java基础-常用类-枚举](#39java基础-常用类-枚举)
  - [39-1：enum线程安全](#39-1enum线程安全)
  - [39-2: switch 是否可用于String类型的判断，Java哪个版本之后有此功能的](#39-2-switch-是否可用于string类型的判断java哪个版本之后有此功能的)
- [40.Java基础-常用类-时间类](#40java基础-常用类-时间类)
  - [40-1：SimpDateFormat是线程不安全的类，不要定义为static变量，如果定义，必须加锁或工具类](#40-1simpdateformat是线程不安全的类不要定义为static变量如果定义必须加锁或工具类)
- [41.java基础-常用类-Object类](#41java基础-常用类-object类)
  - [41-1：Object类有哪些方法](#41-1object类有哪些方法)
  - [41-2：为什么操作线程方法会在Object对象中](#41-2为什么操作线程方法会在object对象中)
- [42.java基础-序列化](#42java基础-序列化)
  - [42-1：什么是序列化和饭序列化](#42-1什么是序列化和饭序列化)
  - [42-2：序列化的作用](#42-2序列化的作用)
  - [42-3：java对象如何实现序列化](#42-3java对象如何实现序列化)
  - [42-4：java对象如何实现反序列化](#42-4java对象如何实现反序列化)
  - [42-5：哪些不会被序列化](#42-5哪些不会被序列化)
  - [42-6：序列化协议有哪些](#42-6序列化协议有哪些)
  - [42-7：该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？](#42-7该接口并没有方法和字段为什么只有实现了该接口的类的对象才能被序列化呢)
  - [42-8: 什么是serialVersionUID](#42-8-什么是serialversionuid)
- [---------------------------------------------------------------------------------------------------------------](#hr)
- [1.线程与进程](#1线程与进程)
  - [1-1：什么是进程](#1-1什么是进程)
  - [1-2：何为线程?](#1-2何为线程)
  - [1-3：线程与进程的区别](#1-3线程与进程的区别)
  - [1-4：进程的通信方式](#1-4进程的通信方式)
- [2.进程调度](#2进程调度)
  - [2-1：什么时候会发生CPU调度](#2-1什么时候会发生cpu调度)
  - [2-2：抢占式与非抢占式](#2-2抢占式与非抢占式)
  - [2-3：进程调度任务过程](#2-3进程调度任务过程)
  - [2-4：进程的调度算法](#2-4进程的调度算法)
- [3.并发级别](#3并发级别)
- [4.并行与并发](#4并行与并发)
  - [4-1：并行与并发概念](#4-1并行与并发概念)
  - [4-2：并发特性](#4-2并发特性)
- [5.多线程](#5多线程)
  - [5-1：为什么要使⽤多线程呢?](#5-1为什么要使多线程呢)
  - [5-2：使⽤多线程可能带来什么问题?](#5-2使多线程可能带来什么问题)
  - [5-3：多线程公共用一个数据注意什么](#5-3多线程公共用一个数据注意什么)
  - [5-4：如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？](#5-4如何确保-n-个线程可以访问-n-个资源同时又不导致死锁)
  - [5-5：单cpu上多线程效率和单线程比如何](#5-5单cpu上多线程效率和单线程比如何)
- [6.线程的基本操作](#6线程的基本操作)
  - [6-1：线程的生命周期和状态](#6-1线程的生命周期和状态)
  - [6-2：说说 sleep() ⽅法和 wait() ⽅法区别和共同点?](#6-2说说-sleep-法和-wait-法区别和共同点)
  - [6-3：yield join notify notifyAll](#6-3yield-join-notify-notifyall)
  - [6-4：为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？](#6-4为什么我们调-start-法时会执-run-法为什么我们不能直接调run-法)
  - [6-5：中断线程方法](#6-5中断线程方法)
  - [6-6：一般线程和守护线程以及两者区别](#6-6一般线程和守护线程以及两者区别)
- [7.创建线程](#7创建线程)
  - [7-1：创建线程的方式](#7-1创建线程的方式)
  - [7-2：创建线程的对比](#7-2创建线程的对比)
  - [7-3：实现Runnable接⼝和Callable接⼝的区别](#7-3实现runnable接和callable接的区别)
  - [7-4：实现 Runnable 接口比继承 Thread 类所具有的优势](#7-4实现-runnable-接口比继承-thread-类所具有的优势)
- [8.线程安全与线程同步](#8线程安全与线程同步)
  - [8-1：线程安全方式](#8-1线程安全方式)
  - [8-2：线程同步方式](#8-2线程同步方式)
- [9.synchronized关键字](#9synchronized关键字)
  - [9-1：synchronized关键字理解](#9-1synchronized关键字理解)
  - [9-2：JDK1.6优化有哪些？](#9-2jdk16优化有哪些)
  - [9-3：底层原理](#9-3底层原理)
  - [9-4：谈谈 synchronized和ReentrantLock 的区别](#9-4谈谈-synchronized和reentrantlock-的区别)
  - [9-5：Lock和synchronized的区别](#9-5lock和synchronized的区别)
  - [9-6：synchronized的优势](#9-6synchronized的优势)
  - [9-7：synchronized锁的膨胀过程（升级过程）](#9-7synchronized锁的膨胀过程升级过程)
  - [9-8：那如何判断共享数据不会被线程竞争？](#9-8那如何判断共享数据不会被线程竞争)
- [10.volatile关键字](#10volatile关键字)
  - [10-1：为什么要是用volatile关键字](#10-1为什么要是用volatile关键字)
  - [10-2：为什么其他线程能感知到变量更新](#10-2为什么其他线程能感知到变量更新)
  - [10-3：volatile为什么不保证原子性吗？](#10-3volatile为什么不保证原子性吗)
  - [10-4：怎么保证输出结果是20000呢？](#10-4怎么保证输出结果是20000呢)
  - [10-5：为什么要重排](#10-5为什么要重排)
  - [10-6： 有哪几种重排](#10-6-有哪几种重排)
  - [10-7：举例说一下指令重排](#10-7举例说一下指令重排)
  - [10-8： volatile怎么实现禁止指令重排？](#10-8-volatile怎么实现禁止指令重排)
  - [10-9：happen-before原则是什么](#10-9happen-before原则是什么)
  - [10-10：volatile都不保证原子性，为啥我们还要用它？](#10-10volatile都不保证原子性为啥我们还要用它)
  - [10-11：synchronized 关键字和 volatile 关键字的区别](#10-11synchronized-关键字和-volatile-关键字的区别)
- [11.线程池](#11线程池)
  - [10-1：使⽤线程池的好处](#10-1使线程池的好处)
  - [10-2：常规实现线程池方法](#10-2常规实现线程池方法)
  - [10-3：线程池增长策略](#10-3线程池增长策略)
  - [10-4：线程池拒绝策略](#10-4线程池拒绝策略)
- [12.锁](#12锁)
  - [12-1：锁](#12-1锁)
  - [12-2：乐观锁与悲观锁](#12-2乐观锁与悲观锁)
  - [12-3：两种锁的使用场景](#12-3两种锁的使用场景)
  - [12-4：乐观锁常见的两种实现方式](#12-4乐观锁常见的两种实现方式)
  - [12-5：乐观锁的缺点](#12-5乐观锁的缺点)
  - [12-6：自旋锁](#12-6自旋锁)
  - [12-7：自旋锁的优缺点](#12-7自旋锁的优缺点)
  - [12-8：自旋锁的升级——自适应自旋](#12-8自旋锁的升级自适应自旋)
  - [12-9：自旋锁使用场景](#12-9自旋锁使用场景)
  - [12-10：可重入锁（递归锁）](#12-10可重入锁递归锁)
  - [12-11：可重入锁使用场景](#12-11可重入锁使用场景)
  - [12-12：可重入锁如果加了两把，但是只释放了一把会出现什么问题？](#12-12可重入锁如果加了两把但是只释放了一把会出现什么问题)
  - [12-13：如果只加了一把锁，释放两次会出现什么问题？](#12-13如果只加了一把锁释放两次会出现什么问题)
  - [12-14：读写锁](#12-14读写锁)
  - [12-15：公平锁](#12-15公平锁)
  - [12-16：非公平锁](#12-16非公平锁)
  - [12-17：公平锁与非公平锁优缺点](#12-17公平锁与非公平锁优缺点)
  - [12-18：公平锁与非公平锁使用场景](#12-18公平锁与非公平锁使用场景)
  - [12-19：共享锁](#12-19共享锁)
  - [12-20：共享锁使用场景](#12-20共享锁使用场景)
  - [12-21：独占锁](#12-21独占锁)
  - [12-22：独占锁使用场景](#12-22独占锁使用场景)
  - [12-23：重量级锁](#12-23重量级锁)
  - [12-24：重量级锁使用场景](#12-24重量级锁使用场景)
  - [12-25：轻量级锁](#12-25轻量级锁)
  - [12-26：轻量级锁优缺点](#12-26轻量级锁优缺点)
  - [12-27：偏向锁](#12-27偏向锁)
  - [12-28：偏向锁优缺点](#12-28偏向锁优缺点)
  - [12-29：分段锁](#12-29分段锁)
  - [12-30：互斥锁](#12-30互斥锁)
  - [12-31：同步锁](#12-31同步锁)
  - [12-32：死锁](#12-32死锁)
  - [12-33：锁粗化](#12-33锁粗化)
  - [12-34：锁消除](#12-34锁消除)
  - [12-35：提高锁性能的方法](#12-35提高锁性能的方法)
- [13.ThreadLocal](#13threadlocal)
  - [13-1：什么是ThreadLocal](#13-1什么是threadlocal)
  - [13-2：ThreadLocal的实现原理](#13-2threadlocal的实现原理)
  - [13-3：ThreadLocal的优势](#13-3threadlocal的优势)
  - [13-4：ThreadLocal内存泄露问题](#13-4threadlocal内存泄露问题)
- [14.无锁](#14无锁)
  - [14-1：CAS](#14-1cas)
  - [14-2：CAS的ABA问题](#14-2cas的aba问题)
- [11.Atomic原子类](#11atomic原子类)
  - [11-1：为什么要使用原子类](#11-1为什么要使用原子类)
  - [11-2：什么是原子类](#11-2什么是原子类)
  - [11-3：原子类的作用？](#11-3原子类的作用)
  - [11-4：i++自增操作不是原子性的，如何决绝原子性问题](#11-4i自增操作不是原子性的如何决绝原子性问题)
  - [11-5：基本数据类型原子类的优势](#11-5基本数据类型原子类的优势)
  - [11-6：为什么是unsafe](#11-6为什么是unsafe)
- [12. 死锁](#12-死锁)
  - [12-1：什么是线程死锁](#12-1什么是线程死锁)
  - [12-2：产生死锁的条件](#12-2产生死锁的条件)
  - [12-3：如何解决线程死锁问题](#12-3如何解决线程死锁问题)
- [13.AQS](#13aqs)
  - [13-1：对AQS原理分析](#13-1对aqs原理分析)
  - [13-2：AQS 对资源的共享⽅式](#13-2aqs-对资源的共享式)
  - [13-3：AQS 组件](#13-3aqs-组件)
- [14.并发容器](#14并发容器)
  - [14-1：JDK 提供的并发容器总结](#14-1jdk-提供的并发容器总结)
  - [14-2：CopyOnWriteArrayList 是如何做到的？](#14-2copyonwritearraylist-是如何做到的)
  - [14-3：BlockingQueue](#14-3blockingqueue)
- [15.快速失败与安全失败](#15快速失败与安全失败)
- [16.什么是上下⽂切换?](#16什么是上下切换)
- [---------------------------------------------------------------------------------------------------------------](#hr-1)
- [1.类加载](#1类加载)
  - [1.1：类的生命周期](#11类的生命周期)
  - [1.2：类的加载过程](#12类的加载过程)
  - [1.3：类加载机制](#13类加载机制)
  - [1.4：知道哪些类加载器?](#14知道哪些类加载器)
- [2.双亲委派模型](#2双亲委派模型)
  - [2-1：双亲委派模型流程](#2-1双亲委派模型流程)
  - [2-2：双亲委派模型带来了什么好处呢？](#2-2双亲委派模型带来了什么好处呢)
  - [2-3：如果我们不想⽤双亲委派模型怎么办？](#2-3如果我们不想双亲委派模型怎么办)
  - [2-4：自己写一个类能不能被加载？](#2-4自己写一个类能不能被加载)
- [3.垃圾回收](#3垃圾回收)
  - [3-1：如何判断对象已经死亡？](#3-1如何判断对象已经死亡)
  - [3-2：不可达的对象是否非死不可](#3-2不可达的对象是否非死不可)
  - [3-2：强、软、弱、虚引用](#3-2强软弱虚引用)
  - [3-3：如何减少 GC 的次数](#3-3如何减少-gc-的次数)
  - [3-4：GC 是什么?为什么要有 GC?](#3-4gc-是什么为什么要有-gc)
  - [3-5：垃圾回收的优点](#3-5垃圾回收的优点)
  - [3-6：垃圾回收器的基本原理是什么？](#3-6垃圾回收器的基本原理是什么)
  - [3-7：什么样的对象需要回收](#3-7什么样的对象需要回收)
  - [3-8：可作为GC Roots的对象？](#3-8可作为gc-roots的对象)
  - [3-9：垃圾回收器可以马上回收内存吗？](#3-9垃圾回收器可以马上回收内存吗)
  - [3-10：有什么办法主动通知虚拟机进行垃圾回收？](#3-10有什么办法主动通知虚拟机进行垃圾回收)
  - [3-11：如何判断一个类是无用的类](#3-11如何判断一个类是无用的类)
  - [3-12：如何判断一个常量是废弃常量？](#3-12如何判断一个常量是废弃常量)
  - [3-11：垃圾回收算法](#3-11垃圾回收算法)
  - [3-12：Minor Gc和Full GC 有什么不同呢？](#3-12minor-gc和full-gc-有什么不同呢)
  - [3-13：何时发生full gc](#3-13何时发生full-gc)
- [4.常⻅的垃圾回收器有那些?](#4常的垃圾回收器有那些)
  - [4-1：Serial收集器](#4-1serial收集器)
  - [4-2：ParNew收集器](#4-2parnew收集器)
  - [4-3：Parallel Scavenge收集器](#4-3parallel-scavenge收集器)
  - [4-4：Serial Old收集器](#4-4serial-old收集器)
  - [4-5：Parallel Old收集器](#4-5parallel-old收集器)
  - [4-6：CMS收集器](#4-6cms收集器)
  - [4-7：G1收集器](#4-7g1收集器)
  - [4-8：吞吐有限和响应有限的垃圾收集器如何选择](#4-8吞吐有限和响应有限的垃圾收集器如何选择)
- [5.Java内存结构（JMM）](#5java内存结构jmm)
  - [5-1：为什么需要Java内存模型？](#5-1为什么需要java内存模型)
  - [5-2：什么是JMM](#5-2什么是jmm)
  - [5-3：什么是Java内存模型？](#5-3什么是java内存模型)
  - [5-4：Java内存模型的两大内存是啥？](#5-4java内存模型的两大内存是啥)
  - [5-5：内存如何工作](#5-5内存如何工作)
  - [5-6：Java内存模型三大特性](#5-6java内存模型三大特性)
  - [5-7：jvm内存结构](#5-7jvm内存结构)
  - [5-8：程序计数器为什么是私有的?](#5-8程序计数器为什么是私有的)
  - [5-9：虚拟机栈和本地⽅法栈为什么是私有的?](#5-9虚拟机栈和本地法栈为什么是私有的)
  - [5-10：堆和栈的区别是什么？](#5-10堆和栈的区别是什么)
  - [5-11：Java中的数组是存储在堆上还是栈上的？](#5-11java中的数组是存储在堆上还是栈上的)
  - [5-12：Java 8的metaspace (元空间)](#5-12java-8的metaspace-元空间)
  - [5-13：为什么要进行元空间代替持久代呢?](#5-13为什么要进行元空间代替持久代呢)
  - [5-14：Java中的对象一定在堆上分配内存吗？](#5-14java中的对象一定在堆上分配内存吗)
  - [5-15：怎么如何获取堆和栈的dump文件？](#5-15怎么如何获取堆和栈的dump文件)
  - [5-16：不同的虚拟机在实现运行时内存的时候有什么区别？](#5-16不同的虚拟机在实现运行时内存的时候有什么区别)
- [6.新生代， 老年代， 持久代](#6新生代-老年代-持久代)
  - [6-1：新生代， 老年代， 持久代？ 各存了什么？](#6-1新生代-老年代-持久代-各存了什么)
- [7. HotSpot虚拟机对象](#7-hotspot虚拟机对象)
  - [7-1：说⼀下Java对象的创建过程](#7-1说下java对象的创建过程)
  - [7-2：内存分配的两种⽅式选择](#7-2内存分配的两种式选择)
  - [7-3：虚拟机如何保证线程安全](#7-3虚拟机如何保证线程安全)
  - [7-4：对象的访问定位有哪两种⽅式?](#7-4对象的访问定位有哪两种式)
  - [7-5：访问定位两种方式的优缺点](#7-5访问定位两种方式的优缺点)
  - [7-6：对象分配规则](#7-6对象分配规则)
- [8.内存泄露与内存溢出](#8内存泄露与内存溢出)
  - [8-1：什么是内存泄漏](#8-1什么是内存泄漏)
  - [8-2：什么是内存溢出](#8-2什么是内存溢出)
  - [8-3：内存溢出， 内存泄漏区别？](#8-3内存溢出-内存泄漏区别)
  - [8-4：如何避免内存泄露、 溢出？](#8-4如何避免内存泄露-溢出)
  - [8-5：如何检测内存泄露？](#8-5如何检测内存泄露)
  - [8-6：java中会存在内存泄露呢？什么时候发生](#8-6java中会存在内存泄露呢什么时候发生)
  - [8-7：什么情况下会发生堆内存溢出，栈内存溢出](#8-7什么情况下会发生堆内存溢出栈内存溢出)
- [9.调优工具](#9调优工具)
  - [9-1：调优工具有哪些？](#9-1调优工具有哪些)
- [10.JVM进程有哪些线程启动? (拼多多)](#10jvm进程有哪些线程启动-拼多多)
- [11.jvm启动模式之client 与server](#11jvm启动模式之client-与server)
- [12.简述JVM中静态分派和动态分派(引申:重载和重写)。](#12简述jvm中静态分派和动态分派引申重载和重写)
- [---------------------------------------------------------------------------------------------------------------](#hr-2)
- [1.计算机网络-HTTP-get与post](#1计算机网络-http-get与post)
  - [1-1：get与post的区别](#1-1get与post的区别)
- [2.计算机网络-HTTP-报文结构与状态码](#2计算机网络-http-报文结构与状态码)
  - [2-1：状态码](#2-1状态码)
  - [2-2：HTTP请求组成](#2-2http请求组成)
- [3.计算机网络-HTTP-HTTP的1.0-3.0](#3计算机网络-http-http的10-30)
  - [3-1：HTTP1.0优缺点](#3-1http10优缺点)
  - [3-2：HTTP/1.1相对于HTTP1.0改善](#3-2http11相对于http10改善)
  - [3-3：HTTP1.1缺点](#3-3http11缺点)
  - [3-4：HTTP⻓连接,短连接(也是TCP连接,短连接)](#3-4http连接短连接也是tcp连接短连接)
  - [3-5：HTTP/2 做了什么优化？](#3-5http2-做了什么优化)
  - [3-6：HTTP/2有哪些缺陷？](#3-6http2有哪些缺陷)
  - [3-7：HTTP/3做了哪些优化？](#3-7http3做了哪些优化)
- [4.计算机网络-HTTP-HTTPs](#4计算机网络-http-https)
  - [4-1：HTTP与HTTPS区别](#4-1http与https区别)
  - [4-2：HTTPS 解决了 HTTP 的哪些问题？](#4-2https-解决了-http-的哪些问题)
  - [4-3：HTTPS 是如何建⽴连接的？其间交互了什么？](#4-3https-是如何建连接的其间交互了什么)
  - [4-4：SSL/TLS握⼿](#4-4ssltls握)
  - [4-5：HTTPS的加密过程](#4-5https的加密过程)
  - [4-6：加密](#4-6加密)
  - [4-7：HTTP拆包粘包](#4-7http拆包粘包)
- [5.计算机网络-HTTP-Cookie与Session](#5计算机网络-http-cookie与session)
  - [5-1：Cookie 和 Session 的区别](#5-1cookie-和-session-的区别)
  - [5-2：Cookie作用](#5-2cookie作用)
  - [5-3：Session用户登录状态过程](#5-3session用户登录状态过程)
  - [5-4：token的验证流程](#5-4token的验证流程)
  - [5-5：token和cookie实现的区别](#5-5token和cookie实现的区别)
  - [5-6：HTTP是不保存状态的协议,如何保存⽤户状态?](#5-6http是不保存状态的协议如何保存户状态)
  - [5-7：如何保存session](#5-7如何保存session)
  - [5-8：如何实现 Session 跟踪呢？](#5-8如何实现-session-跟踪呢)
  - [5-9：Cookie 被禁⽤怎么办?](#5-9cookie-被禁怎么办)
  - [5-10：URI和URL的区别是什么?](#5-10uri和url的区别是什么)
- [6.计算机网络-综合应用-输入网址](#6计算机网络-综合应用-输入网址)
  - [6-1：输入网址过程](#6-1输入网址过程)
  - [6-2：为什么域名要分级设计](#6-2为什么域名要分级设计)
  - [6-3：重定向原因](#6-3重定向原因)
- [7.各层协议](#7各层协议)
  - [7-1：OSI与TCP/IP各层的结构与功能,都有哪些协议?](#7-1osi与tcpip各层的结构与功能都有哪些协议)
  - [7-2：⽹络层与数据链路层有什么关系呢？](#7-2络层与数据链路层有什么关系呢)
- [8.TCP的三次握手](#8tcp的三次握手)
  - [8-1：TCP三次握手流程](#8-1tcp三次握手流程)
  - [8-2：TCP为什么要三次握⼿](#8-2tcp为什么要三次握)
  - [8-3：TCP为什么SYN](#8-3tcp为什么syn)
  - [8-4：TCP除了SYN，为什么还要 ACK](#8-4tcp除了syn为什么还要-ack)
  - [8-5：什么是 SYN 攻击？如何避免 SYN 攻击？](#8-5什么是-syn-攻击如何避免-syn-攻击)
  - [8-5：如何对三次握手进行性能优化](#8-5如何对三次握手进行性能优化)
  - [8-6：如何绕过三次握手发送数据](#8-6如何绕过三次握手发送数据)
  - [8-7：TCP Fast Open的过程](#8-7tcp-fast-open的过程)
  - [8-8：为什么需要 TCP 协议？](#8-8为什么需要-tcp-协议)
  - [8-9：什么是 TCP 连接？](#8-9什么是-tcp-连接)
  - [8-10：如何唯一确定一个 TCP 连接呢？](#8-10如何唯一确定一个-tcp-连接呢)
  - [8-11：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？](#8-11有一个-ip-的服务器监听了一个端口它的-tcp-的最大连接数是多少)
  - [8-12：服务端最大并发 TCP 连接数远不能达到理论上限](#8-12服务端最大并发-tcp-连接数远不能达到理论上限)
  - [8-15：为什么客户端和服务端的初始序列号 ISN 是不相同的？](#8-15为什么客户端和服务端的初始序列号-isn-是不相同的)
  - [8-16：什么是Mss](#8-16什么是mss)
  - [8-17：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？](#8-17既然-ip-层会分片为什么-tcp-层还需要-mss-呢)
- [9.四次挥手](#9四次挥手)
  - [9-1：TCP四次挥手流程](#9-1tcp四次挥手流程)
  - [9-2：TCP为什么要四次挥手](#9-2tcp为什么要四次挥手)
  - [9-3：如何对四次挥手进行优化](#9-3如何对四次挥手进行优化)
  - [9-4：为什么TIME_WAIT 等待的时间是 2MSL？](#9-4为什么time_wait-等待的时间是-2msl)
  - [9-5：为什么需要TIME_WAIT状态？（已经主动关闭连接了为啥还要保持资源一段时间呢？）](#9-5为什么需要time_wait状态已经主动关闭连接了为啥还要保持资源一段时间呢)
  - [9-6：TIME_WAIT 过多有什么危害？](#9-6time_wait-过多有什么危害)
  - [9-7：如何优化 TIME_WAIT？](#9-7如何优化-time_wait)
  - [9-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？](#9-8如果已经建了连接但是客户端突然出现故障了怎么办)
- [10.TCP传输数据优化方案](#10tcp传输数据优化方案)
  - [10-1：TCP传输数据优化](#10-1tcp传输数据优化)
  - [10-2： TCP 应该如何 Socket 编程？](#10-2-tcp-应该如何-socket-编程)
- [11.TCP与UDP](#11tcp与udp)
  - [11-1：TCP与UDP区别](#11-1tcp与udp区别)
  - [11-2：TCP 和 UDP 应用场景](#11-2tcp-和-udp-应用场景)
  - [11-3：TCP的作用](#11-3tcp的作用)
  - [11-4：TCP 数据包的大小](#11-4tcp-数据包的大小)
  - [11-5：TCP 数据包的编号（SEQ）](#11-5tcp-数据包的编号seq)
  - [11-6：TCP 数据包的组装](#11-6tcp-数据包的组装)
  - [11-7：什么是TCP粘包？怎么解决这个问题](#11-7什么是tcp粘包怎么解决这个问题)
  - [11-8：粘包的原因](#11-8粘包的原因)
  - [11-9：粘包解决方案](#11-9粘包解决方案)
  - [11-10：UDP会不会产生粘包问题呢？](#11-10udp会不会产生粘包问题呢)
- [12：协议如何保证可靠传输方式](#12协议如何保证可靠传输方式)
  - [12-1：TCP如何保证稳定传输](#12-1tcp如何保证稳定传输)
  - [12-2：UDP如何做可靠传输](#12-2udp如何做可靠传输)
- [13.重传机制](#13重传机制)
  - [13-1：常见的重传机制](#13-1常见的重传机制)
  - [13-2：超时重传](#13-2超时重传)
  - [13-3：什么时候会发生超时重传](#13-3什么时候会发生超时重传)
  - [13-4：超时重传存在的问题](#13-4超时重传存在的问题)
  - [13-5：快速重传](#13-5快速重传)
  - [13-6：快速重传的问题](#13-6快速重传的问题)
  - [13-7：SACK方法](#13-7sack方法)
  - [13-8：D-SACK](#13-8d-sack)
  - [13-9：D-SACK好处](#13-9d-sack好处)
- [14.滑动窗口与流量控制](#14滑动窗口与流量控制)
  - [14-1：引入窗口概念的原因](#14-1引入窗口概念的原因)
  - [14-2：什么是窗口](#14-2什么是窗口)
  - [14-3：窗口大小由哪一方决定？](#14-3窗口大小由哪一方决定)
  - [14-4：发送方的窗口](#14-4发送方的窗口)
  - [14-5：流量控制](#14-5流量控制)
  - [14-6：流量控制的过程](#14-6流量控制的过程)
  - [14-7：](#14-7)
  - [14-8：](#14-8)
  - [14-9：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？](#14-9tcp-是如何解决窗口关闭时潜在的死锁现象呢)
- [15.拥塞控制](#15拥塞控制)
  - [15-1：为什么要有拥塞控制呀，不是有流量控制了吗？](#15-1为什么要有拥塞控制呀不是有流量控制了吗)
  - [15-2：什么是拥塞控制](#15-2什么是拥塞控制)
  - [15-3：什么是拥塞窗口？和发送窗口有什么关系呢？](#15-3什么是拥塞窗口和发送窗口有什么关系呢)
  - [15-4：那么怎么知道当前网络是否出现了拥塞呢？](#15-4那么怎么知道当前网络是否出现了拥塞呢)
  - [15-5：拥塞控制算法](#15-5拥塞控制算法)
  - [15-6：那慢启动涨到什么时候是个头呢？](#15-6那慢启动涨到什么时候是个头呢)
  - [15-7：重传机制何时结束](#15-7重传机制何时结束)
- [16.ARQ协议](#16arq协议)
  - [16-1：什么是ARQ协议](#16-1什么是arq协议)
  - [16-2：什么是停⽌等待ARQ协议](#16-2什么是停等待arq协议)
  - [16-3: 什么是连续ARQ协议](#16-3-什么是连续arq协议)
- [---------------------------------------------------------------------------------------------------------------](#hr-3)
- [1.mysql理论](#1mysql理论)
  - [1-1：为什么要使用数据库](#1-1为什么要使用数据库)
  - [1-2: 什么是SQL？](#1-2-什么是sql)
  - [1-3：什么是MySQL?](#1-3什么是mysql)
  - [1-4：数据库三大范式是什么](#1-4数据库三大范式是什么)
  - [1-5：mysql有关权限的表都有哪几个](#1-5mysql有关权限的表都有哪几个)
  - [1-6：什么是binlog](#1-6什么是binlog)
  - [1-6：binlog长什么样？](#1-6binlog长什么样)
  - [1-7：binlog一般用来做什么](#1-7binlog一般用来做什么)
  - [1-8：redo log](#1-8redo-log)
  - [1-9：bin log和redo log](#1-9bin-log和redo-log)
  - [1-10：我写其中的某一个log，失败了，那会怎么办？](#1-10我写其中的某一个log失败了那会怎么办)
  - [1-11：MySQL如何保证redo log和binlog的数据是一致的](#1-11mysql如何保证redo-log和binlog的数据是一致的)
  - [1-12：如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？](#1-12如果整个数据库的数据都被删除了那我可以用redo-log的记录来恢复吗)
  - [1-13：MySQL的binlog有有几种录入格式？分别有什么区别？](#1-13mysql的binlog有有几种录入格式分别有什么区别)
  - [1-14：mysql的数据类型](#1-14mysql的数据类型)
  - [1-15：SQL的生命周期](#1-15sql的生命周期)
  - [1-16：字段为什么要求定义为not null?](#1-16字段为什么要求定义为not-null)
  - [1-17：数据库热备份与冷备份](#1-17数据库热备份与冷备份)
- [2.sql的使用](#2sql的使用)
  - [2-1：SQL语句主要分为哪几类](#2-1sql语句主要分为哪几类)
  - [2-2：超键、候选键、主键、外键分别是什么？](#2-2超键候选键主键外键分别是什么)
  - [2-3：为什么用自增列作为主键](#2-3为什么用自增列作为主键)
  - [2-4：truncate、 delete区别](#2-4truncate-delete区别)
  - [2-5：什么是临时表，临时表什么时候删除?](#2-5什么是临时表临时表什么时候删除)
  - [2-6：非关系型数据库和关系型数据库区别，优势比较?](#2-6非关系型数据库和关系型数据库区别优势比较)
  - [2-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?](#2-7什么是-内连接外连接交叉连接笛卡尔积等)
  - [2-8：varchar与char的区别](#2-8varchar与char的区别)
  - [2-9：count(*)、count(1)、count(column)的区别](#2-9countcount1countcolumn的区别)
  - [2-10：SQL 约束有哪几种？](#2-10sql-约束有哪几种)
  - [2-11：六种关联查询](#2-11六种关联查询)
  - [2-12：什么是子查询](#2-12什么是子查询)
  - [2-13：子查询的三种情况](#2-13子查询的三种情况)
  - [2-14：mysql中 in 和 exists 区别](#2-14mysql中-in-和-exists-区别)
  - [2-15：varchar(50)中50的涵义](#2-15varchar50中50的涵义)
  - [2-16：int(20)中20的涵义](#2-16int20中20的涵义)
  - [2-17：FLOAT和DOUBLE的区别是什么？](#2-17float和double的区别是什么)
  - [2-18：UNION与UNION ALL的区别？](#2-18union与union-all的区别)
  - [2-19：为什么要使用视图？什么是视图？那些特点？](#2-19为什么要使用视图什么是视图那些特点)
  - [2-20：什么是存储过程？](#2-20什么是存储过程)
  - [2-21：存储过程有哪些优缺点？](#2-21存储过程有哪些优缺点)
  - [2-22：什么是触发器？](#2-22什么是触发器)
  - [2-23：触发器的使用场景有哪些？](#2-23触发器的使用场景有哪些)
  - [2-24：MySQL中都有哪些触发器？](#2-24mysql中都有哪些触发器)
- [3.索引](#3索引)
  - [3-1：索引是什么](#3-1索引是什么)
  - [3-2：为什么要用索引（优点）](#3-2为什么要用索引优点)
  - [3-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）](#3-3索引这么多优点为什么不对表中的每一个列创建一个索引呢缺点)
  - [3-4：索引的主要原理，常用算法](#3-4索引的主要原理常用算法)
  - [3-5：创建索引原则（使用场景）：](#3-5创建索引原则使用场景)
  - [3-7：创建索引的注意事项](#3-7创建索引的注意事项)
  - [3-8：为什么索引能够提高查询速度](#3-8为什么索引能够提高查询速度)
  - [3-9：创建索引的三种方式](#3-9创建索引的三种方式)
  - [3-10：最左前缀原则](#3-10最左前缀原则)
  - [3-11：最左匹配原则](#3-11最左匹配原则)
- [4.索引的分类](#4索引的分类)
  - [4-1：索引的分类](#4-1索引的分类)
  - [4-2：各种索引定义](#4-2各种索引定义)
- [5.索引的结构](#5索引的结构)
  - [5-1：mysql索引的结构](#5-1mysql索引的结构)
  - [5-2：B+树比B树的优势](#5-2b树比b树的优势)
  - [5-3：B+树与红黑树比较](#5-3b树与红黑树比较)
  - [5-4：B+树与hash索引比较](#5-4b树与hash索引比较)
  - [5-5：聚簇索引与非聚簇索引概念](#5-5聚簇索引与非聚簇索引概念)
  - [5-6：聚簇索引的优缺点](#5-6聚簇索引的优缺点)
  - [5-7：非聚簇索引的优缺点](#5-7非聚簇索引的优缺点)
- [6.数据库优化](#6数据库优化)
  - [6-1：为什么要优化](#6-1为什么要优化)
  - [6-2：索引优化](#6-2索引优化)
  - [6-3：查询优化](#6-3查询优化)
  - [6-4：慢查询优化](#6-4慢查询优化)
- [7.mysql引擎](#7mysql引擎)
  - [7-1：MySQL存储引擎MyISAM与InnoDB区别](#7-1mysql存储引擎myisam与innodb区别)
  - [7-2：能说下myisam 和 innodb的区别吗？](#7-2能说下myisam-和-innodb的区别吗)
  - [7-3：InnoDB引擎的4大特性](#7-3innodb引擎的4大特性)
- [8.事务](#8事务)
  - [8-1：什么是事务](#8-1什么是事务)
  - [8-2：数据库事务特性](#8-2数据库事务特性)
  - [8-3：ACID靠什么保证的](#8-3acid靠什么保证的)
  - [8-4：什么是undo log](#8-4什么是undo-log)
  - [8-5：四大隔离级别](#8-5四大隔离级别)
  - [8-6：隔离级别的原理](#8-6隔离级别的原理)
  - [8-7：MySQL 中RC和RR隔离级别的区别](#8-7mysql-中rc和rr隔离级别的区别)
  - [8-8：隔离级别用来做什么](#8-8隔离级别用来做什么)
  - [8-9：并发事务带来什么问题](#8-9并发事务带来什么问题)
  - [8-10：数据库崩溃时事务的恢复机制](#8-10数据库崩溃时事务的恢复机制)
  - [8-11：Undo Log缺陷如何解决？](#8-11undo-log缺陷如何解决)
- [9.锁](#9锁)
  - [9-1：隔离级别与锁的关系](#9-1隔离级别与锁的关系)
  - [9-2：封锁粒度](#9-2封锁粒度)
  - [9-3：锁的类型](#9-3锁的类型)
  - [9-4：三级封锁协议](#9-4三级封锁协议)
  - [9-5：排它锁](#9-5排它锁)
  - [9-6：排他锁和共享锁的兼容性](#9-6排他锁和共享锁的兼容性)
  - [9-7：InnoDB存储引擎的锁的算法](#9-7innodb存储引擎的锁的算法)
  - [9-8：MyISAM和InnoDB存储引擎使用的锁](#9-8myisam和innodb存储引擎使用的锁)
  - [9-9：表级锁和行级锁对比：](#9-9表级锁和行级锁对比)
  - [9-10：Innodb如何加锁](#9-10innodb如何加锁)
  - [9-11：Innodb解决死锁](#9-11innodb解决死锁)
- [10.阻塞](#10阻塞)
  - [10-1：什么是阻塞](#10-1什么是阻塞)
  - [10-2：阻塞的优化](#10-2阻塞的优化)
- [11.什么是慢查询](#11什么是慢查询)
- [12.主从复制](#12主从复制)
  - [12-1：什么是主从复制](#12-1什么是主从复制)
  - [12-2：主从复制的作用（好处，或者说为什么要做主从）：](#12-2主从复制的作用好处或者说为什么要做主从)
  - [12-3：主从复制的原理（重中之重，面试必问）](#12-3主从复制的原理重中之重面试必问)
  - [12-4：主从复制的几种方式](#12-4主从复制的几种方式)
- [13.JDBC](#13jdbc)
  - [13-1：JDBC数据库连接步骤](#13-1jdbc数据库连接步骤)
  - [13-2：JDBC中的Statement 和PreparedStatement的区别？](#13-2jdbc中的statement-和preparedstatement的区别)
  - [13-3：JDBC中大数据量的分页解决方法?](#13-3jdbc中大数据量的分页解决方法)
  - [13-4：说说数据库连接池工作原理和实现方案？](#13-4说说数据库连接池工作原理和实现方案)
  - [13-5：Java中如何进行事务的处理?](#13-5java中如何进行事务的处理)
  - [13-6：execute，executeQuery，executeUpdate的区别是什么？](#13-6executeexecutequeryexecuteupdate的区别是什么)
  - [13-7：PreparedStatement的缺点是什么，怎么解决这个问题？](#13-7preparedstatement的缺点是什么怎么解决这个问题)
  - [13-8：JDBC的DriverManager是用来做什么的？](#13-8jdbc的drivermanager是用来做什么的)
  - [13-9：JDBC的ResultSet是什么?](#13-9jdbc的resultset是什么)
  - [13-10：有哪些不同的ResultSet？](#13-10有哪些不同的resultset)
  - [13-11：JDBC的DataSource是什么，有什么好处](#13-11jdbc的datasource是什么有什么好处)
  - [13-12：如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？](#13-12如何通过jdbc的datasource和apache-tomcat的jndi来创建连接池)
  - [13-13：常见的JDBC异常有哪些？](#13-13常见的jdbc异常有哪些)
  - [13-14：JDBC中存在哪些不同类型的锁?](#13-14jdbc中存在哪些不同类型的锁)
  - [13-15：java.util.Date和java.sql.Date有什么区别？](#13-15javautildate和javasqldate有什么区别)
  - [13-16：SQLWarning是什么，在程序中如何获取SQLWarning？](#13-16sqlwarning是什么在程序中如何获取sqlwarning)
  - [13-17：如果java.sql.SQLException: No suitable driver found该怎么办？](#13-17如果javasqlsqlexception-no-suitable-driver-found该怎么办)
  - [13-18：JDBC的RowSet是什么，有哪些不同的RowSet？](#13-18jdbc的rowset是什么有哪些不同的rowset)
  - [13-19：什么是JDBC的最佳实践？](#13-19什么是jdbc的最佳实践)
- [14.应用](#14应用)
  - [14.1：一条SQL语句执行得很慢的原因有哪些](#141一条sql语句执行得很慢的原因有哪些)
  - [14.2：为什么数据库会选错了索引](#142为什么数据库会选错了索引)
  - [6-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决](#6-4当mysql单表记录数过大时数据库的crud性能会明显下降如何解决)
  - [6-5：垂直分表](#6-5垂直分表)
  - [6-6：水平分表](#6-6水平分表)
- [15.分库分表的设计](#15分库分表的设计)
  - [4-7：为什么要分库分表？](#4-7为什么要分库分表)
  - [4-8：分库分表，id如何处理](#4-8分库分表id如何处理)
  - [4-9：为什么 MySQL 不推荐使用 uuid 或者雪花 id 作为主键？](#4-9为什么-mysql-不推荐使用-uuid-或者雪花-id-作为主键)
  - [4-10：使用自增id的缺点](#4-10使用自增id的缺点)
  - [4-12：mysql分页，超大分页怎么处理？](#4-12mysql分页超大分页怎么处理)
  - [4-14：为什么要尽量设定一个主键?](#4-14为什么要尽量设定一个主键)
  - [4-15：主键使用自增ID还是UUID?](#4-15主键使用自增id还是uuid)
- [---------------------------------------------------------------------------------------------------------------](#hr-4)
- [1.缓存](#1缓存)
  - [1-1：缓存思想](#1-1缓存思想)
  - [1-2：使用缓存为系统带来了什么问题](#1-2使用缓存为系统带来了什么问题)
  - [1-3：本地缓存解决方案](#1-3本地缓存解决方案)
  - [1-4：为什么要有分布式缓存?/为什么不直接用本地缓存?](#1-4为什么要有分布式缓存为什么不直接用本地缓存)
  - [1-5：缓存读写模式/更新策略](#1-5缓存读写模式更新策略)
  - [1-6：缓存数据的处理流程是怎样的？](#1-6缓存数据的处理流程是怎样的)
- [2.Redis](#2redis)
  - [2-1：为什么要⽤ redis/为什么要⽤缓存](#2-1为什么要-redis为什么要缓存)
  - [2-2：为什么要⽤ redis ⽽不⽤ map/guava 做缓存?](#2-2为什么要-redis-不-mapguava-做缓存)
  - [2-3：说一下 Redis 和 Memcached 的区别和共同点](#2-3说一下-redis-和-memcached-的区别和共同点)
  - [2-4：为什么说Redis快](#2-4为什么说redis快)
  - [2-5：Redis应用场景](#2-5redis应用场景)
- [3.Redis五大数据类型与编码方式](#3redis五大数据类型与编码方式)
  - [3-1：五大数据类型（理解就好）](#3-1五大数据类型理解就好)
  - [3-2：动态字符串与C语言自带字符串的区别](#3-2动态字符串与c语言自带字符串的区别)
  - [3-3：Redis字典底层如何解决冲突](#3-3redis字典底层如何解决冲突)
  - [3-4：hash如何扩容](#3-4hash如何扩容)
  - [3-5：什么是渐进式](#3-5什么是渐进式)
  - [3-6：什么时候使用ziplist而不是hash](#3-6什么时候使用ziplist而不是hash)
  - [3-7：什么时候使用ziplist什么时候使用skiplist？](#3-7什么时候使用ziplist什么时候使用skiplist)
  - [3-8：skiplist原理](#3-8skiplist原理)
  - [3-9：ziplist原理](#3-9ziplist原理)
  - [3-10：为什么选择跳表而不是平衡树或者哈希表](#3-10为什么选择跳表而不是平衡树或者哈希表)
  - [3-11：redis 数据存储过程](#3-11redis-数据存储过程)
  - [3-12：数据淘汰过程](#3-12数据淘汰过程)
- [4.Redis的单线程](#4redis的单线程)
  - [4-1：为什么Redis是单线程](#4-1为什么redis是单线程)
  - [4-2：既然是单线程，那怎么监听大量的客户端连接呢？](#4-2既然是单线程那怎么监听大量的客户端连接呢)
  - [4-3：Redis为什么又采用了多线程](#4-3redis为什么又采用了多线程)
- [5.过期策略](#5过期策略)
  - [5-1：Redis 给缓存数据设置过期时间有啥用？](#5-1redis-给缓存数据设置过期时间有啥用)
  - [5-2：Redis是如何判断数据是否过期的呢？](#5-2redis是如何判断数据是否过期的呢)
  - [5-3：过期策略分类](#5-3过期策略分类)
  - [5-4：缓存淘汰机制](#5-4缓存淘汰机制)
  - [5-5：LRU算法原理](#5-5lru算法原理)
  - [5-6：如何实现LRU](#5-6如何实现lru)
- [6.持久化机制](#6持久化机制)
  - [6-1：什么是Redis持久化？](#6-1什么是redis持久化)
  - [6-2:各自的优缺点？](#6-2各自的优缺点)
  - [6-3：Redis持久化数据和缓存怎么做扩容？](#6-3redis持久化数据和缓存怎么做扩容)
  - [6-4：持久化期间工作流程](#6-4持久化期间工作流程)
  - [6-5：持久化机制](#6-5持久化机制)
- [7.集群主从复制](#7集群主从复制)
- [8.缓存雪崩](#8缓存雪崩)
  - [8-1：什么是缓存穿透](#8-1什么是缓存穿透)
  - [8-2：缓存穿透解决方案](#8-2缓存穿透解决方案)
  - [8-3：什么是缓存雪崩](#8-3什么是缓存雪崩)
  - [8-4：有哪些解决办法？](#8-4有哪些解决办法)
- [9.如何保证缓存和数据库数据的一致性？](#9如何保证缓存和数据库数据的一致性)
- [10.事务](#10事务)
  - [10-1：Redis事务的概念](#10-1redis事务的概念)
  - [10-2：Redis事务的三个阶段](#10-2redis事务的三个阶段)
  - [10-3：Redis事务相关命令](#10-3redis事务相关命令)
  - [10-4：事务管理（ACID）概述](#10-4事务管理acid概述)
  - [10-5：Redis事务支持隔离性吗](#10-5redis事务支持隔离性吗)
  - [10-6：Redis事务保证原子性吗，支持回滚吗](#10-6redis事务保证原子性吗支持回滚吗)
- [11.Redis应用](#11redis应用)
  - [11-1：为什么Redis 变慢了](#11-1为什么redis-变慢了)
- [---------------------------------------------------------------------------------------------------------------](#hr-5)
- [1.Spring概述](#1spring概述)
  - [1-1：什么是spring?](#1-1什么是spring)
  - [1-2：Spring用到的设计模式](#1-2spring用到的设计模式)
  - [1-3：什么是 Spring 的循环依赖](#1-3什么是-spring-的循环依赖)
  - [1-4：什么是三级缓存](#1-4什么是三级缓存)
  - [1-5：什么是早期暴露的对象](#1-5什么是早期暴露的对象)
  - [1-6：如何解决循环依赖](#1-6如何解决循环依赖)
  - [Spring两大特性](#spring两大特性)
  - [Spring和Springboot的区别](#spring和springboot的区别)
- [2.Spring控制反转](#2spring控制反转)
  - [2-1：IOC原理](#2-1ioc原理)
  - [2-2：IOC容器种类](#2-2ioc容器种类)
  - [2-3：BeanFactory与ApplicationContext区别](#2-3beanfactory与applicationcontext区别)
  - [2-4：什么是依赖注入](#2-4什么是依赖注入)
  - [2-5：有哪些不同类型的IOC（依赖注入）方式？](#2-5有哪些不同类型的ioc依赖注入方式)
  - [2-5：IOC与DI的的区别:](#2-5ioc与di的的区别)
  - [2-6：](#2-6)
- [3.Spring面向切面编程(AOP)](#3spring面向切面编程aop)
  - [3-1：什么是aop](#3-1什么是aop)
  - [3-2：AOP的相关概念：](#3-2aop的相关概念)
- [3.Spring Bean](#3spring-bean)
  - [3-1：Bean的五种作用域](#3-1bean的五种作用域)
  - [3-2：Spring 中的单例 bean 的线程安全问题了解吗？](#3-2spring-中的单例-bean-的线程安全问题了解吗)
  - [3-2：Bean的生命周期](#3-2bean的生命周期)
  - [3-3：](#3-3)
- [4.Spring注解](#4spring注解)
- [5.Spring数据访问](#5spring数据访问)
- [6.](#6)
- [7.SpringMVC](#7springmvc)
  - [7-1：SpringMVC流程](#7-1springmvc流程)
- [8.Spring事务](#8spring事务)
  - [8-1：spring事务种类](#8-1spring事务种类)
  - [8-2：Spring两种事务区别](#8-2spring两种事务区别)
  - [8-3：事务管理接口](#8-3事务管理接口)
  - [8-3：事务传播行为](#8-3事务传播行为)
  - [8-4：事务隔离级别](#8-4事务隔离级别)
  - [8-5：Spring的事务和数据库的事务隔离是一个概念么？](#8-5spring的事务和数据库的事务隔离是一个概念么)
  - [8-6：事务属性详解](#8-6事务属性详解)
  - [8-7：事务传播行为](#8-7事务传播行为)
  - [@Transactional 注解使用详解](#transactional-注解使用详解)
  - [注解常用属性](#注解常用属性)
  - [注解原理](#注解原理)
- [9.MyBatis](#9mybatis)
  - [9-1：MyBatis是什么](#9-1mybatis是什么)
  - [9-2：ORM是什么](#9-2orm是什么)
  - [9-3：JPA](#9-3jpa)
  - [9-4：MyBatis优点](#9-4mybatis优点)
  - [9-5：为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？](#9-5为什么说mybatis是半自动orm映射工具它与全自动的区别在哪里)
  - [9-6：传统JDBC开发存在的问题，如何解决的](#9-6传统jdbc开发存在的问题如何解决的)
  - [9-7：Hibernate 和 MyBatis 的区别](#9-7hibernate-和-mybatis-的区别)
  - [9-8：MyBatis的解析和运行原理](#9-8mybatis的解析和运行原理)
  - [9-9：MyBatis编程步骤是什么样的？](#9-9mybatis编程步骤是什么样的)
  - [9-10：MyBatis的工作原理](#9-10mybatis的工作原理)
  - [2.5 为什么需要预编译](#25-为什么需要预编译)
  - [MyBatis是如何做到SQL预编译的呢？](#mybatis是如何做到sql预编译的呢)
  - [如何防止SQL注入](#如何防止sql注入)
  - [Mybatis都有哪些Executor执行器？它们之间的区别是什么？](#mybatis都有哪些executor执行器它们之间的区别是什么)
  - [2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？](#28-mybatis是否支持延迟加载如果支持它的实现原理是什么)
- [10.映射器](#10映射器)
  - [10-1：#{}和${}的区别是什么？](#10-1和的区别是什么)
  - [10-2：Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？](#10-2xml-映射文件中除了常见的-selectinsertupdaedelete-标签之外还有哪些标签)
  - [最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗](#最佳实践中通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗)
  - [3.11 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？](#311-mybatis的xml映射文件中不同的xml映射文件id是否可以重复)
  - [简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？](#简述mybatis的xml映射文件和mybatis内部数据结构之间的映射关系)
  - [Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，3.16 还是说必须定义在A标签的前面？](#mybatis映射文件中如果a标签通过include引用了b标签的内容请问b标签能否定义在a标签的后面316-还是说必须定义在a标签的前面)
- [11.高级查询](#11高级查询)
  - [4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？](#41-mybatis实现一对一一对多有几种方式怎么操作的)
  - [4.2 Mybatis是否可以映射Enum枚举类？](#42-mybatis是否可以映射enum枚举类)
- [12.动态SQL](#12动态sql)
  - [12-1：Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？](#12-1mybatis动态sql是做什么的都有哪些动态sql能简述一下动态sql的执行原理不)
  - [12-2：Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？](#12-2mybatis-是如何将-sql-执行结果封装为目标对象并返回的都有哪些映射形式)
- [13.插件模块](#13插件模块)
  - [6.1 Mybatis是如何进行分页的？分页插件的原理是什么？](#61-mybatis是如何进行分页的分页插件的原理是什么)
  - [6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。](#62-简述mybatis的插件运行原理以及如何编写一个插件)
- [14.缓存](#14缓存)
  - [14-1：Mybatis的一级、二级缓存](#14-1mybatis的一级二级缓存)
- [15.servlet](#15servlet)
  - [15-1：Servlet生命周期?](#15-1servlet生命周期)
  - [forward和redirect的区别](#forward和redirect的区别)
  - [tomcat容器是如何创建servlet类实例？用到了什么原理](#tomcat容器是如何创建servlet类实例用到了什么原理)
  - [Servlet安全性问题](#servlet安全性问题)
  - [servlet写就行了，为什么要有springMVC这个东西呢](#servlet写就行了为什么要有springmvc这个东西呢)
  - [两者区别](#两者区别)
  - [servlet加载顺序](#servlet加载顺序)
  - [filter和Interceptor的区别](#filter和interceptor的区别)
  - [jsp和servlet区别](#jsp和servlet区别)
  - [Servlet是线程安全的吗？](#servlet是线程安全的吗)
- [15.SpringBoot](#15springboot)
  - [什么是 Spring Boot？](#什么是-spring-boot)
  - [SpringBoot自动配置原理](#springboot自动配置原理)
- [-----------------------------------------------------------------------](#hr-6)
- [1.单例模式](#1单例模式)
  - [1.1：什么是单例模式](#11什么是单例模式)
  - [1.2：为什么要用单例模式呢？](#12为什么要用单例模式呢)
  - [1.3：简单来说使用单例模式可以带来下面几个好处:](#13简单来说使用单例模式可以带来下面几个好处)
  - [1.3：什么可以破坏单例模式](#13什么可以破坏单例模式)
  - [1-4：单例有哪几种实现方式](#1-4单例有哪几种实现方式)
  - [1-5：饿汉方式(线程安全)](#1-5饿汉方式线程安全)
  - [1-6：饿汉式（枚举方式）](#1-6饿汉式枚举方式)
  - [1-6：懒汉式（非线程安全和synchronized关键字线程安全版本 ）](#1-6懒汉式非线程安全和synchronized关键字线程安全版本-)
  - [1-7：懒汉式(双重检查加锁版本)](#1-7懒汉式双重检查加锁版本)
  - [1-8：懒汉式（登记式/静态内部类方式）](#1-8懒汉式登记式静态内部类方式)
  - [单例模式里面为什么写了volatile](#单例模式里面为什么写了volatile)
- [2.工厂模式](#2工厂模式)
  - [2-1：工厂模式的定义](#2-1工厂模式的定义)
  - [2-2：工厂模式的分类：](#2-2工厂模式的分类)
  - [2-3：在开源框架中的使用](#2-3在开源框架中的使用)
  - [2-4：为什么要用工厂模式](#2-4为什么要用工厂模式)
  - [2-5：简单工厂例子](#2-5简单工厂例子)
  - [2-6：使用反射机制改善简单工厂](#2-6使用反射机制改善简单工厂)
  - [2-7：工厂方法模式](#2-7工厂方法模式)
  - [2-8：抽象工厂模式](#2-8抽象工厂模式)
- [3.建造者模式](#3建造者模式)
  - [3-1：什么是建造者模式](#3-1什么是建造者模式)
- [4.原型模式](#4原型模式)
- [5.代理模式](#5代理模式)

<!-- /TOC -->
# 1.java基础-java特性

## 1-1：java特点

1. 简单易学；
2. <font color=red size='5'>⾯向对象（封装，继承，多态）；</font>
3. <font color=red size='5'>平台⽆关性（ Java 虚拟机实现平台⽆关性）；</font>
4. 可靠性；
5. 安全性；
6. <font color=red size='5'>⽀持多线程；</font>
7. <font color=red size='5'>⽀持⽹络编程并且很⽅便；</font>
8. 编译与解释并存；

# 2.java基础-面对对象-综述

## 2-1：面对对象三大特征(特点)

1. 封装
2. 继承
3. 多态

## 2-2：面对对象的五大原则

1. 单一职责原则
   * 一个类，最好只做一件事，只有一个引起它的变化
2. 开放封闭原则
   * 对抽象编程，而不对具体编程
3. 里式替换原则
   * 子类必须能够替换其基类（这个是继承的关键）
4. 依赖倒置原则
   * 抽象不依赖于具体，具体依赖于抽象
5. 接口隔离原则
   * 使用多个小的专门的接口，而不要使用一个大的总接口

## 2-3：Java创建对象方式

1. 使用new关键字
2. 使用反射的机制创建对象
   * 使用Class类的newInstance方法
   * 使用Constructor类的newInstance方法
3. 使用clone方法
   * 需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。
4. 反序列化
   * 调用ObjectInputStream类的readObject（）方法

注：使用构造器的三种(new和反射的两种newInstance)，没用构造器的两种(clone和反序列化)


## 2-4：new abc是在堆里面呢？

放在堆里，栈里面放着引用

## 2-4：⾯向过程性能⽐⾯向对象⾼

Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可
以直接被 CPU 执⾏的⼆进制机械码。

# 3.java基础-面对对象-多态

## 3-1：多态的必要条件（实现方式、机制）

1. 有类继承或者接口实现
2. 子类要重写父类的方法
3. 父类的引用指向子类的对象


## 3-3：多态的好处

1. 应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用
   性。 
2. 派生类的功能可以被基类的方法或引用变量所调用，可以提高可扩充性和可维护性。 

## 3-4：多态的例子



# 4.java基础-面对对象-重载与重写 

## 4-1：重载与重写

1. 重载——函数或者方法有同样的名称，但是参数列表不相同的情形
2. 重写——Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以
   子类中的新方法将覆盖父类中原有的方法

## 4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？

1. Java中static方法不能被覆盖， 因为方法覆盖是基于运行时动态绑定的， 而static方法是编译时静态
   绑定的。 

2. Java中也不可以覆盖private的方法， 因为private修饰的变量和方法只能在当前类中使用，如果是其他
   的类继承当前类是不能访问到 private 变量或方法的， 当然也不能覆盖。

# 5.java基础-面对对象-接口与抽象类

## 5-1：接⼝和抽象类的区别是什么？

1. 所有⽅法在接⼝中不能有实现，⽽抽象类可以有⾮抽象的⽅法。

2. 接⼝中除了final变量，不能有其他变量，⽽抽象类中则不⼀定。

3. ⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。

4. 从设计层⾯来说，抽象类作为很多子类的父类，是一种模板式设计，接口是一种行为规范

## 5-2：Java 抽象类可以有构造函数吗？作用是什么

可以有， 抽象类可以声明并定义构造函数。 

它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。

## 5-3: Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗？

可以， 抽象类可以通过使用关键字implements来实现接口。 

## 5-4：Java 抽象类可以是 final 的吗？

不可以， Java 抽象类不能是 final 的。 将它们声明为final的将会阻止它们被继承， 而这正是使用抽象类唯一的方法。 

## 5-5：Java 抽象类可以有 static 方法吗？

可以， 抽象类可以声明并定义 static 方法， 没什么阻止这样做。

## 5-6：可以创建抽象类的实例吗？

不可以， 

1. 对象实例化的时候，关键字new向JVM申请内存，这个类的成员会被保存到内存中。而抽象类，没有具体的成
   员，没办法准确分配内存。

2. 可能也是设计层面上的解释，不希望实例化
   
## 5-7：抽象类必须有抽象方法吗？

不需要， 抽象类有抽象方法不是强制性的。 但是一般在抽象类中设置抽象方法

## 5-8：何时选用抽象类而不是接口？

1. 当关心升级时， 因为不可能在一个发布的接口中添加一个新方法， 用抽象类会更好。
2. 如果你的接口中有很多方法， 你对它们的实现感到很头疼， 考虑提供一个抽象类作为默认实现。

## 5-9：Java中的抽象方法是什么？

1. 抽象方法是一个没有方法体的方法。 你仅需要声明一个方法， 
2. 不需要定义它并使用关键字abstract 声明。 

## 5-10：Java抽象类中可以包含main方法吗？

是的， 抽象类可以包含 main 方法， 它只是一个静态方法， 你可以使用 main 方法执行抽象类， 但不可以创建任何实例。

## 5-11：创建⼀个对象⽤什么运算符?对象实体与对象引⽤有何不同?

new 运算符，new创建对象实例，对象引⽤指向对象实例。⼀个对象引⽤可以指向0个或1个对象;⼀个对象可以有n个引⽤指向它。

## 5-12：interface实现方法



# 6.java基础-值传递与引用传递

1. 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本的值不影响原变量的值

2. 引用传递一般是对于引用类型变量而言的,传递的是该对象地址的一个副本，是一个地址。
   * 如果说改变了原地址的值（注意是  值  ），那么会影响
   * 如果改变了副本地址，如new 一个原地址不会改变  

一般认为,java传递都是值传递.

# 7.java基础-深拷贝与浅拷贝

## 7-1：深拷贝与浅拷贝

1. 浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递的拷⻉。

2. 深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其成员变量。

## 7-2：浅拷贝方法

1. 通过拷贝<font color=red>构造方法</font>实现浅拷贝：

   * 拷贝构造方法指的是该类的构造方法参数为该类的对象。

2. 通过重写clone()方法进行浅拷贝
   
   * 使用clone方法的类必须实现Cloneable接口

## 7-3：深拷贝方法

[参考文献](https://www.cnblogs.com/coderzhw/archive/2019/06/26/11094284.html)

1. 序列化
   * 序列化为数据流，在反序列化回来，就可以得到这个对象
2. 利用Kryo框架，这是一个快速高效的Java序列化框架
3. 利用json转化方式
   * 对象转化为JSON，再序列化为对象
4. 人工构建对象

# 8.java基础-面对对象-构造器

## 8-1：⼀个类的构造⽅法的作⽤是什么? 若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? 为什么?

主要作⽤是完成对类对象的初始化⼯作。可以执⾏。因为⼀个类即使没有声明构造⽅法也会有默认的不带参数的构造⽅法。

## 8-2：构造⽅法有哪些特性？

1. 名字与类名相同。
2. 没有返回值，但不能⽤ void 声明构造函数。
3. ⽣成类的对象时⾃动执⾏，⽆需调⽤。

# 9.java基础-面对对象-静态与非静态

## 9-1：静态⽅法和实例⽅法有何不同

1. 调⽤静态⽅法可以⽆需创建对象。而实例方法需要用类名.方法名访问

2. 静态⽅法在访问本类的成员时，只允许访问静态成员，⽽不允许访问实例成员变量和实例⽅法；实例⽅法则⽆此限制。

## 9-2：静态变量和实例变量的区别？

1. 语法区别： 静态变量前要加 static 关键字，而实例变量前则不加。

2. 程序运行的区别：实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

# 10.java基础-运算符-相等问题

## 10-1： == 与 equals

1. == : 它的作⽤是判断两个对象的地址是不是相等。
   基本数据类型⽐较的是值，引⽤数据类型⽐较的是内存地址

2. equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：

   * 情况 1：类没有覆盖equals()⽅法。则通过equals()⽐较该类的两个对象时，等价于通过“==”⽐ 较这两个对象。
   * 情况 2：类覆盖了equals()⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回true。

## 10-2：为什么要重写hashcode与equals

如果只重写了equals方法而没有重写hashCode方法的话，那么就会违背，相等的对象必须具有相等的散列码（hashCode）。
     
同时对于HashSet和HashMap这些基于散列值（hash）实现的类。

HashMap的底层处理机制是以数组的方法保存放入的数据的，关键就是数组下标的处理。

数组的下标是根据传入的元素hashCode方法的返回值再和特定的值异或决定的。

如果该数组位置上已经有放入的值了，且传入的键值相等则不处理，

若不相等则覆盖原来的值，如果数组位置没有条目，则插入，并加入到相应的链表中。

检查键是否存在也是根据hashCode值来确定的。所以如果不重写hashCode的话，

可能导致HashSet、HashMap不能正常的运作、

如果我们将某个自定义对象存到HashMap或者HashSet及其类似实现类中的时候，

如果该对象的属性参与了hashCode的计算，那么就不能修改该对象参数hashCode计算的属性了。有可能会移除不
了元素，导致内存泄漏。

## 10-3：重写equals不重写hashcode会出现什么问题

在集合中将会存储两个值相同的对象,从而导致混淆。

## 10-4：为什么两个对象有相同的hashcode值，它们也不一定是相等的？

hashCode方法实际上返回的就是对象存储的物理地址，也就是说 hashcode 只是用来缩小查找成本。

## 10-5：hashcode和equals源码写一下

equals()方法在object类中定义如下： 

```java
public boolean equals(Object obj) {  
    return (this == obj);  //用来比较其他对象是否等于此对象
} 
```


比如说在String类中重写

```java
public boolean equals(Object anObject) {
		//使用==操作符检查“参数是否为这个对象的引用”(比较对象地址)
        if (this == anObject) {
            return true;
        }
        //用instanceof检查“参数是否为正确的类型(是否为String的实例)”
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
           	//判断两个字符串的长度是否相同
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                //一个字符一个字符的进行比较
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

```java
public int hashCode() {
      int h = hash;
      if (h == 0 && value.length > 0) {
          char val[] = value;
  
          for (int i = 0; i < value.length; i++) {
              h = 31 * h + val[i];
          }
          hash = h;
     }
     return h;
 }
```


## 10-5：说说&和&&的区别。

1. &和&&都可以表示逻辑与，当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。
2. &&还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，所以不会出现 NullPointerException 
3. &还可以用作位运算符，当&操作符两边的表达式不是 boolean 类型时， &表示按位与操作

## 10-6：用最有效率的方法算出 2 乘以 8 等于几?

用移位运算符

2<<3

* 因为将一个数左移 n 位，就相当于乘以了2的 n 次方

## 10-7：i++和++i的区别，及其线程安全问题

i++：先赋值再自加。

++i：先自加再赋值。

1. 如果i是局部变量（在方法里定义的），那么是线程安全的。因为局部变量是线程私有的，别的线程访问不
   到

2. 如果i是全局变量（类的成员变量），那么是线程不安全的。因为如果是全局变量的话，同一进程中的不同
   线程都有可能访问到。

如果有大量线程同时执行i++操作，i变量的副本拷贝到每个线程的线程栈，当同时有两个线程栈以上的线程读取
线程变量，假如此时是1的话，那么同时执行i++操作，再写入到全局变量，最后两个线程执行完，i会等于3而不
会是2，所以，出现不安全性。


# 11.java基础-数据类型-8种常见类型
##  11-1：八种数据类型是什么？-中兴

1. 字符型   char
2. 布尔型  boolean
3. 数值型
   1. 整型：byte、short、int、long
   2. 浮点型：float、double

<font?color=red>特别注意</font>：String不是基本数据类型，是引用类型。

## 11-2：数据类型的范围

byte：-2^7 ~ 2^7-1，

short：-2^15 ~ 2^15-1

int：-2^31 ~ 2^31-1

long：-2^63 ~ 2^63-1，

浮点型：

float：4字节。

double：8字节。

字符型：

char：2字节。
                                                          
##  11-3：为什么byte类型是-128~+127

使用原码或反码表示的范围为[-127, +127], -0并没有反码补码表示，而使用补码表示的范围为[-128, 127]

##  11-4：java为什么除了基本数据类型还要有引用数据类型

引用类型在堆里，基本类型在栈里。
栈空间小且连续，往往会被放在缓存。引用类型cache miss（缓存未命中）率高且要多一次解引用。对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高

## 11-5：String为什么不是基本数据类型-字节

1. 基本类型仅表示简单的数据类型，引用类型可以表示复杂的数据类型，还可以操作这种数据类型的行为 

2. java虚拟机处理基础类型与引用类型的方式是不一样的，对于基本类型，java虚拟机会为其分配数据类型实际占用的内存空间，而对于引用类型变量，他仅仅是一个指向堆区中某个实例的指针。


# 12.java基础-数据类型-自动拆装箱
## 12-1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 12-2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候该数据的时候，那么就可以直接从本地内存进行调用，就不需要再次创建对象来解决

1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
   * 如果说有，那么直接从内存进行读取
   * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置，但是只有Integer源码可以对高值、低值进行改变。

## 12-3：自动拆装箱的原理

    * 自动装箱：调用valueOf（）方法将原始类型值转换成对象
    * 自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。

## 12-4：自动拆装箱使用场景

1. 场景一、将基本数据类型放入集合类
2. 场景二、包装类型和基本类型的大小比较
3. 场景三、包装类型的运算 
4. 场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
5. 场景五、函数参数与返回值

## 12-5：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，~~虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较~~。（笔试选择较为频繁，跟谁学考过）

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE（NullPointException）。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。

## 12-6：String转出int型， 判断能不能转？ 如何转？

可以转， 得处理异常 Integer.parseInt(s) 主要为 NumberFormatException： 

## 12-7：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?

对于 short s1 = 1; s1 = s1 + 1;由于 s1+1运算时会自动提升表达式的类型，所以结果是 int型，再赋值给 short 类型 s1时， 编译器将报告需要强制转换类型的错误。

对于 short s1 = 1; s1 += 1;由于 +=是 java 语言规定的运算符， java 编译器会对它进行特殊处理，因此可以正确编译

## 12-8：int与Integer区别

1. Integer是int的包装类 ，int则是java的一种基本数据类型
2. Integer变量必须实例化后才能使用，而int变量不需要
3. Integer的默认值是null, int的默认值是0

注：

1. 非new生成的Integer变量和new Integer生成的变量比较时， 结果为false。( 因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer0生成的变量指向堆中新建的对象，两者在内存中的地址不同)
```java
Integer i = new Integer(100);
Integer j = 100;
Syatem.out.print(i == J); //false
```

2. Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true


# 13.java基础-关键字-访问权限关键字

## 13-1：访问控制关键字级别

![avatar](./../../1.basics/1.java-basic/assets/3-2.jpg)

## 13-2: 通过反射访问private成员和方法，既然能访问为什么要private？

1. private并不是解决安全问题的，如果想让解决代码的安全问题，请用别的办法。
2. private的意义是OOP（面向对象编程）的封装概念。

# 14.java基础-关键字-static

## 14-1：static使用场景

1. 修饰成员变量和成员方法 
     
2. 静态代码块: 
   
3. 静态内部类（static修饰类的话只能修饰内部类）： 
   
4. 静态导包: 
   
# 15.java基础-关键字-final关键字

## 15-1：final关键字使用特点

1. final修饰的类不能被继承

2. final修饰的方法不能被重写；

3. final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

4. 想通过使用final提升程序性能
   * 因为编译器能从final中获取额外的信息，因此可以对类或者方法调用进行额外的优化处理。但这中优化对程序性能的提升极其
     有限。

## 15-2：final, finally, finalize 的区别。

1. final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

2. finally 是异常处理语句结构的一部分，表示总是执行。
   
3. finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可
以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。


## 15-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。


# 16.java基础-关键字-this关键字和super关键字

1. this程序
```java
class Manager {
    Employees[] employees;
     
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
     
    void report() { }
}
```

主要是访问本类（自己）的成员变量和方法（可写可不写）
super主要是通过子类去访问父类的成员变量和方法，必须写
2. super程序

```java
public class Super {
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

1. 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。
2. this 调用本类中的其他构造方法时，也要放在首行。
3. this、super不能用在static方法中。

# 17.java基础-关键字-transient

阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 transient 只能修饰变量，不能修饰类和⽅法。


# 18.java基础-集合map-hashmap的数据结构

## 18-1：hashmap的数据结构

1. JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，JDK1.7采用头插法虽然能够提高插入的效率，
   
   但是为了安全,防止环化，因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，
   
   在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。所以使用头插会改变链表的上的顺序，
   
   但是如果使用尾插，在扩容时会保持链表元素原本的顺序，保持之前节点的引用关系，就不会出现逆序且链表死循环的问题

2. 扩容存储位置的计算方式也不一样：
   1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&
   2. 在JDK1.8的时候是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，
   
      但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的存储方式。

3. （插入元素）JDK1.7的时候使用的是数组+ 单链表的数据结构。HashMap通过key的hashCode经过扰动函数处理过后得到hash
   值，然后通过(n-1)&hash判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及
   key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的
   数据结构,当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构，以减少搜索时间。

## 18-2：扩容死循环问题

比如说若当前线程在扩容并发的时候，此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer 函数，并把函数顺利执行，

此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发 transfer，所以两者都是扩容的同一个链表，

当线程一执行到new table[i]的时候，由于线程二之前数据迁移的原困导致此时new table[i]上就有ertry存在，

所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。

但是在JDK 8用head 和 tail 来保证链表的顺序和之前一样。

## 18-2；为什么JDK8时候引入了红黑树？

因为当数组中每个元素，都是一个Entry，每一个Entry是一个单链表。

当链表长度过长的时候，查询链表中的一个元素就比较耗时，这时就引入了红黑树。

首先红黑树是一棵二叉树，红黑树有一条特性就是

从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

这一特性，确保没有一条路径会比其他路径长出两倍，因而，红黑树是接近平衡的二叉树。这就使得红黑树的时间复杂度大大降低。

所以，用红黑树替代单链表会降低集合中元素的访问速度。

## 18-3：为什么不把链表全部换为红黑树

1. 链表的结构比红黑树简单，构造红黑树要比构造链表复杂，所以在链表的节点不多的情况下，从整体的性能看来，如果把链表全部换为红黑树，效率反而更低。
2. HashMap频繁的resize（扩容），扩容的时候需要重新计算节点的索引位置，也就是会将红黑树进行拆分和重组，其实这是很复杂的，这里涉及到红黑树的着色和旋转，所以为链表树化设置一个阀值是非常有必要的。

## 18-4：为什么是使用红黑树而不是AVL树？

在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长。同时因为AVL树需要更高的旋转次数才能在修改时正确地重新平衡数据结构，所以红黑树相对AVL树他的插入更快！

## 18-5：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？

在JDK1.7中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用

## 18-6：为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）

1. 中间有个差值7可以有效防止链表和树频繁转换，降低效率

2. 由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。

## 18-7：扰动函数以及作用

HashMap的hash方法。

为了防止一些实现比较差的hashCode()方法，使用扰动函数之后可以减少碰撞。


## 18-8：哈希冲突的解决方法

1. 拉链法
   
创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

2. 开发地址法

所有输入的元素全部存放在哈希表里，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。

## 18-9：HashMap的put操作

HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过计算判断当前元素存放的位置

1. 如果数组的这个位置是空的，把key放进去，put操作就完成了。

2. 如果数组位置不为空，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖

3. 若果不相等，这个元素必然是个链表。遍历链表逐一比对value，如果value在链表中不存在，就把新建节点，将value放进去，put操作完成。

4. 如果链表中value存在，则替换原节点的value，put操作完成。

5. 如果链表节点数已经达到8个，首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，如果达到64就将冲突的链表为红黑树。

## 18-10：HashMap的get操作

1. 查找位置。

2. 如果访问的节点是bucket里的第一个节点，则直接命中；

3. 如果有冲突，则通过key.equals(k)去树或链表中查找对应的entry。

## 18-11：hashmap的get和put操作的时间复杂度

如果说一个entry数组下标最多只对应了一个entry，此时get方法的时间复杂度可以达到O(1)。

但是如果所有的hash都一样，那么退化为线性查找，变成了O（n）

## 18-12：hashmap的String类型如何计算hashcode的

就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。

选择值31是因为它是素数。如果是偶数并且乘法运算溢出，则信息将丢失，因为乘以2等于移位。

31的一个不错的特性是乘法可以用移位和减法来代替，以获得更好的性能

哈希分布比较均匀。偶数的冲突率很高，只有少数例外。小乘数（1-20）的冲突率也很高

## 18-13：reHash过程

1. 首先创建一个比现有哈希表更大的新哈希表（expand）
2. 然后将旧哈希表的所有元素都迁移到新哈希表去（rehash）

## 18-14：hash函数以及常用方法

1. 直接定址法：直接以key或者key上加上某个常数作为哈希地址
2. 数字分析法：提取key中取值比较均匀的数字作为哈希地址
3. 除留余数法：用key除以某个不大于哈希表长度m的数，将所得余数作为哈希地址
4. 分段叠加法：按照哈希表地址位数将关键字分成了位数相等的几部分，其中最后一部分可以比较短，然后将这几部分相加，舍弃最
   高位仅为后的结果就是该关键字的哈希地址
5. 平方取中法：如果key的各部分分部都不均匀，可以先求出他的平方值，然后按照需求求取中间的几位作为哈希地址
6. 伪随机数法：采用一个伪随机数作为哈希函数


## 18-15：HashMap为什么要树化?

安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶中，则会形成一个链表。而链表查询时线性的，会
严重影响存取的性能。

## 18-16：hashmap树化门槛及作用

* 链表长度大于8
* 数组长度大于64

作用：
这个本质上，是一个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶中，则会形成一个链表。而链
表查询是线性的，会严重影响存取的性能。

## 18-17：hashmap的特性

1. 允许空键和空值（但空键只有一个，且放在第一位）
2. 元素是无序的，而且顺序会不定时改变
3. key不允许重复。

## 18-18：HashMap为什么可以插入空值?

HashMap在put的时候会调用hash()方法来计算key的hashcode值，可以从hash算法中看出当key==null时返回的值为0。因此key为
null时，hash算法返回值为0，不会调用key的hashcode方法。

## 18-19：JDK的hashmap与Redis的hashmap的区别

1. HashMap由于对链表size超过8采用二叉树结构，使得get操作随着激烈冲突导致变成一个类二叉树，时间复杂度为O(log(n))较
   redis的字典表O(n)，性能提升明显。
2. Redis的rehash由于采用渐进式的方式，对于大数据量下的rehash操作性能提升明显。这也是由于HashMap大部分用于临时且数
   据量不是特别大的数据，redis的hash用于存储避免大数据情况导致异常，双方的侧重点不一样。
3. Redis的单链表在冲突的情况下是从表头插入，时间复杂度为O(1)，而HashMap则为O(n)。

## 18-20：为什么要两次hash

两个不同的键值，在对数组长度进行按位与操作后得到的结果相同，就会发生冲突


# 19.java基础-集合map-hashmap源码数值分析

## 19-1：HashMap中(tab.length - 1) & hash作用

1. 保证不会发生数组越界

2. 保证元素尽可能的均匀分布

## 19-2：请解释一下HashMap的参数loadFactor，它的作用是什么？

loadFactor表示HashMap的拥挤程度

作用：影响hash操作到同一个数组位置的概率。

## 19-3：HashMap的扩容因子为什么是0.75

1. 如果设置过大，如0.85，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，
   性能下降。
   
2. 如果设置过小，如0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。

## 19-4：为什么默认初始化桶数组大小为16

如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小，既不会像1，2，3那样放几个元素就扩容，也不会像几千几
万那样可以只会利用一点点空间从而造成大量的浪费。

## 19-5：hashmap为什么是2的次幂

取模运算可以变成位与运算，效率显著提高！但是要浪费一些空间。

# 20.java基础-集合map-hashmap线程问题

## 20-1：hashMap是否线程安全

在JDK1.7的时候没有加入同步锁保护，同时由于JDK1.7在并发执行put造作导致扩容行为从而导致环形链表，在获取数据遍历链表形
成死循环，同时hashmap迭代器的fail-fast策略，一旦在使用地带器过程中出现并发操作，就会跑出异常。

那么JDK1.8虽然解决了死循环问题，但是还是没有同步锁保护机制，所以依然线程不安全

所以多线程情况下，首选线程安全的ConcurrentHashMap

## 20-2：为什么hashmap中String、integer包装类适合作为key

1. 包装类重写了equals\hashcode方法，不容易出现hash值计算错误
2. 由于String类型是final的，保证了key的不可更改性

## 20-3：线程安全的Map

* Hashtable
* ConcurrentHashMap
* SynchronizedMap

1. Hashtable、SynchronizedMap源码中是使用synchronized来保证线程安全的
   
2. ConcurrentHashMap沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想，但是
   ConcurrentHashMap没有对整个hash表进行锁定，而是采用了分离锁（segment）的方式进行局部锁定。具体体现在，它在代码
   中维护着一个segment数组。
   
## 20-4：设计线程安全的map

1. 使用synchronized来进行约束：

2. 使用JDK1.5版本所提供的lock机制
   
3. 使用JDK提供的读写锁

4. 使用JDK1.5提供的ConcurrentHashMap,该类将Map的存储空间分为若干块,每块拥有自己的锁,减少了多个线程争夺同一个锁的情
   况


# 21.java基础-集合map-ConcurrentHashMap

## 21-1：ConcurrentHashMap的底层实现

从JDK1.7版本的数组+Segment+分段锁的方式实现，分段锁Segment，它类似于HashMap的结构，内部拥有一个Entry数组，数组中的
每个元素又是一个链表,同时又是一个ReentrantLock。ConcurrentHashMap内部使用分段锁技术，将数据分成一段一段的存储，然
后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发
访问。虽然在写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment这一种结构，但是带来的副作用是
Hash的过程要比普通的HashMap要长

到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。数据结构上取消了Segment分段锁的数据结构，取而代之的是数组+链表
+红黑树的结构。为了保证线程安全，JDK1.8采用CAS+Synchronized保证线程安全。JDK1.8现调整为对每个数组元素加锁。由于定
位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样查询时间复
杂度会得到改善

## 21-2：为何会出现ConcurrenHashMap?

1. 线程安全，读写还快，以空间换时间

2. 改善了hashmap迭代器出现的ConcurrentModificationException

* 由于ConcurrentHashMap对于会产生并发操作的node都会有加锁同步处理,且迭代器获取tab[index]开头node时都会从主存来获
  
  得,保证获取的数据是最新的，从而保证了迭代器在迭代过程中即使有put , remove 等操作同时发生也可以保证迭代的安全性,不会
  
  出现ConcurrentModificationException

## 21-3：为什么ConcurrentHashMap（hashtable）为何不支持null键和null值

ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null
时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains
(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。

## 21-4：ConcurrentHashMap的put操作

1. 首先判断是否初始化，如果没有初始化则进入initTable()方法进行初始化工作
2. 如果已经初始化了，进入无限循环，判断key对应的数组下标是否有值了
3. 如果key对应的下标没有值，通过CAS原理插入，插入成功则退出循环，插入失败则继续循环
4. 如果key对应的下标已经存在值,判断此时hash==MOVED(-1),则进入帮助扩容。
5. 如果key对应的下标已经存在值，但是hash!=MOVED,则需要对数组的这个下标进行加锁了，以保证线程的安全。
6. 如果数组的这个下标是一个链表，则对操作链表（判断链表用hash>=0）
7. 如果数组的这个下标是一个红黑树，则操作红黑树。
8. 插入成功后，如果链表的长度已经达到了红黑树的阀门8，则首先判断此时数组的长度是否大于64，如果小于64则进行扩容，如果
   大于等于64则链表变成红黑树
9. 判断容器是否扩容

## 21-5：分段锁原理

它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在
ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，
并完成 put 操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。

ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保
证每个 Segment 是线程安全的，也就实现了全局的线程安全

## 21-6：hashmap与ConcurrentHashMap中put的区别

## 21-7：扩容机制

1. 通过计算 CPU 核心数和 Map 数组的长度得到每个线程要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每
   个线程处理 16 个桶。因此，如果长度是 16 的时候，扩容的时候只会有一个线程扩容。

2. 初始化临时变量,将其在原有基础上扩容两倍。

3.死循环开始转移。多线程并发转移就是在这个死循环中，根据一个 finishing 变量来判断，该变量为 true 表示扩容结束，否则
继续扩容。
3.1 进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16. 从大到小进行分配。当拿到分配值后，进行 i-- 递减。
这个 i 就是数组下标。（其中有一个 bound 参数，这个参数指的是该线程此次可以处理的区间的最小下标，超过这个下标，就需要
重新领取区间或者结束扩容，还有一个 advance 参数，该参数指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后
推进，反之，说明还没有处理好当前桶，不能推进)
3.2 出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临死变量，更新 table 变量，更新库容阈值。如果没
完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，
sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（这里主要是判断扩容任务是否结束，如果结束
了就让线程退出该方法，并更新相关变量）。然后检查所有的桶，防止遗漏。
3.3 如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让 putVal 方法的线程感知。
3.4 如果 i 对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。
3.5 如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个桶。
3.6 到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据
或已经被占位了，就跳过了。

处理每个桶的行为都是同步的。防止 putVal 的时候向链表插入数据。
4.1 如果这个桶是链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新
表的高位。
4.2 如果这个桶是红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，
改造成链表。反之，继续使用红黑树结构。
4.3 到这里，就完成了一个桶从旧表转移到新表的过程。

## 21-8：什么时候会发生扩容机制

1. put操作（插入键值对）

2. putAll操作（批量插入键值对）

3. remove操作（移除元素，底层实现是用null空值代替原位元素）

4. replace操作（对已存在的键值对替换值）

5. computeIfAbsent操作（若key对应的value为空，会将第二个参数的返回值存入并返回）

# 22.java基础-集合map-TreeMap

## 22-1：TreeMap底层原理：

TreeMap是桶+红黑树的实现方式.TreeMap的底层结构就是一个数组,数组中每一个元素又是一个红黑树.当添加一个元素
(key-value)的时候,根据key的hash值来确定插入到哪一个桶中(确定插入数组中的位置),当桶中有多个元素时,使用红黑树进行保
存;当一个桶中存放的数据过多,那么根据key查找的效率就会降低

## 22-2：使用场景

1. 需要基于排序的统计功能：

2. 需要快速增删改查的存储功能：

3. 需要快速增删改查而且需要保证遍历和插入顺序一致的存储功能：

# 23.java基础-集合map-LinkedHashmap

## 23-1：linkedhashmap的底层原理

linkedhashmap继承HashMap，他比hashmap多维护了一个双向链表

# 24.java基础-集合map-HashTable

## 24-1：HashTable的底层原理

HashTable的与HashMap中相似，有一点重大区别就是所有的操作都是通过synchronized锁保护的。只有获得了对应的锁，才能进行后续的读写等操作。

# 25.java基础-集合list-ArrayList

## 25-1：数组(Array)和列表(ArrayList)有什么区别？ 什么时候应该使用 Array 而不是ArrayList？
1. 定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 
2. 容量上： Array 大小固定， ArrayList 的大小是动态变化的。 
3. 操作上： ArrayList 提供更多的方法和特性， 
   
使用基本数据类型或者知道数据元素数量的时候可以考虑 Array;ArrayList 处理固定数量的基本类型数据类型时会自动装箱来减少
编码工作量，但是相对较慢。

## 25-2：扩容机制

1. 当前数组是由默认构造方法生成的空数组并且第一次添加数据。此时minCapacity等于默认的容量（10）那么根据下面逻辑可以看
   到最后数组的容量会从0扩容成10。而后的数组扩容才是按照当前容量的1.5倍进行扩容；
2. 当前数组是由自定义初始容量构造方法创建并且指定初始容量为0。此时minCapacity等于1那么根据下面逻辑可以看到最后数组的
   容量会从0变成1。这边可以看到一个严重的问题，一旦我们执行了初始容量为0，那么根据下面的算法前四次扩容每次都 +1，在
   第5次添加数据进行扩容的时候才是按照当前容量的1.5倍进行扩容。
3. 当扩容量（newCapacity）大于ArrayList数组定义的最大值后会调用hugeCapacity来进行判断。如果minCapacity已经大于
   Integer的最大值（溢出为负数）那么抛出OutOfMemoryError（内存溢出）否则的话根据与MAX_ARRAY_SIZE的比较情况确定是
   返回Integer最大值还是MAX_ARRAY_SIZE。这边也可以看到ArrayList允许的最大容量就是Integer的最大值（-2的31次方~2的
   31次方减1）。

## 25-3：ArrayList的add操作

不是原子操作，原因主要是elementData[size++] = e可以继续进行拆分

## 25-4：Arraylist初始大小以及扩容大小

ArrayList添加第一个元素时，数组的容量设置为10

4.当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），第一次扩容后，容量为15，第二次扩容至22

## 25-5：那如何解决ArrayList线程不安全问题呢？

1. 用Vector代替ArrayList
2. 用Collections.synchronized(new ArrayList<>())
   *  因为Collections.synchronizedList封装后的list，list的所有操作方法都是带synchronized关键字的，相当于所有操作
      都会进行加锁，所以使用它是线程安全的但是除迭代数组之外
3. CopyOnWriteArrayList
   * 写操作：添加元素时，不直接往当前容器添加，而是先拷贝一份数组，在新的数组中添加元素后，在将原容器的引用指向新的容
     器。因为数组时用volatile关键字修饰的，所以当array重新赋值后，其他线程可以立即知道（volatile的可见性）
   * 读操作：读取数组时，读老的数组，不需要加锁。
   * 读写分离：写操作是copy了一份新的数组进行写，读操作是读老的数组，所以是读写分离。
# 26.java基础-集合list-vector

由于vector中Add方法加了synchronized，来保证add操作是线程安全的

## 26-1：Vector是保证线程安全的

# 27.java基础-集合list-linkedlist


# 28.java基础-集合set-HashSet

## 28-1：hashset原理

HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符
的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查
hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。

## 28-2：hashSet的内存泄漏

当一个对象被存储进HashSet集合中以后，就不能修改该对象的参与计算哈希值的属性值了，否则对象修改后的哈希值与最初存储进

HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对
象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。

## 28-3：为什么HashSet不安全

底层add操作不保证可见性、原子性。所以不是线程安全的

## 28-4：如何保证线程安全

1. 使用Collections.synchronizedSet

2. 使用CopyOnWriteArraySet

# 29.java基础-集合set-TreeSet

## 29-1：TreeSet原理

# 30.java基础-集合set-LinkedSet

## 30-1：LinkedSet原理

# 31.java基础-集合-集合大比较（区别和使用场景）

主要从一下几方面分析

1. 线程
2. 底层
3. 时间复杂度
4. 内存
5. 其他

## 31-1：set和list、map的区别

1. List(对付顺序的好帮手)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象

2. Set(注重独一无二的性质):不允许重复的集合。不会有多个元素引用相同的对象。

3. Map(用Key来搜索的专家):使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

## 31-2：arraylist、linkedlist区别和适用场景

1. 是否保证线程安全： ArrayList在单线程下是线程安全的，多线程下由于多个线程不断抢夺资源，所以会出现不安全
                     -------和 LinkedList 都是不同步的，也就是不保证线程安全；
2. 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构
3. 插入和删除是否受元素位置的影响： 
   ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 
   ② LinkedList 采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。
4. 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。<br>
5. 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）

<font color="#986078">使用场景：</font>

当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。

## 31-3：vector、Arraylist区别和适用场景

1. 线程：Vector是多线程安全的，
2. 底层：两个都是数组实现，
3. 时间复杂度：Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比
4. 内存：但是当空间不足的时候，两个类的增加方式是不同。vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的41%
5. 其他：Vector可以设置增长因子，而ArrayList不可以
   
<font color="#986078">使用场景：</font>

1. 安全因素
2. 在集合中使用数据量比较大的数据


## 31-4：HashMap、Treemap、linkedHashMap区别和适用场景

1. 线程安全：都不是线程安全的
2. 底层：TreeMap的底层是红黑树，能够按照键值进行升序排列，而HashMap与linkedHashMap是基于哈希表实现，
3. 时间复杂度：Treemap由于是红黑树，hashmap要更快一些，
4. 内存，由于Treemap使用的是红黑树，内存要大于另外两个， 又因为linkedhashmap多维护了一个双向链表，也要大约hashmap
5. 其他：hashmap排序是无序的。另外两种排序有序
   
<font color="#986078">使用场景：</font>

## 31-5：HashTable、Hashmap区别和适用场景

1. 线程安全，hashtable更加安全
2. 底层，hashtable底层加入了锁保护
3. 时间复杂度，由于加入了锁保护，hashtable时间复杂度要低于hashmap
4. 内存，
5. 其他

<font color="#986078">使用场景：</font>

1. 若在单线程中，我们往往会选择HashMap；
2. 而在多线程中，则会选择Hashtable。(02)，
3. 若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。


## 31-6： ConcurrentHashMap、Hashmap区别和适用场景

1. ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。
2. ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制。所以，前者线程安全的，后者不是线程安全的。
   
<font color="#986078">使用场景：</font>

1.安全因素

## 31-7： Hashset、Hashmap区别和适用场景

待定
1. 接口：实现了Map接⼝ 实现Set接⼝
2. 存储：存储键值对 仅存储对象
3. 添加元素：调⽤ put（）向map中添加元素       调⽤ add（） ⽅法向Set中添加元素
4. 计算：HashMap使⽤键（Key）计算Hashcode     HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性，
   
<font color="#986078">使用场景：</font>

## 31-8：treeset、hashset区别和适用场景

1. TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值
   HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束

2. HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例	

<font color="#986078">使用场景：</font>

在我们需要排序的功能时，我们才使用TreeSet。

## 31-9：JAVA集合类

集合框架有Map和Collection两大类

1. Collection
   1. List
        * Arraylist： Object数组
        * Vector： Object数组
        * LinkedList： 双向链表(JDK1.6之前为循环链表， JDK1.7取消了循环)
    2. Set
        * HashSet（⽆序，唯⼀） : 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素
        * LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的
        * TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)
    3. Queue


2. Map
    1. HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。 JDK1.8以后在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间
    2. LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问顺序相关逻辑。详细可以查看： 
    3. Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的
    4. TreeMap： 红⿊树（⾃平衡的排序⼆叉树）

## 31-10：并发集合

1. Queue
  * ConcurrentLinkedQueue
  * BlockingQueue
    * ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制
    * LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue
  * Deque
2. CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayList
3. CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素
4. ConcurrentMap：线程安全的HashMap的实现
   * ConcurrentHashMap
   * ConcurrentNavigableMap


## 31-11：并发集合出现的原因

书本p41  ---1

## 31-11：collection与collections的区别

java.util.Collection 是一个集合接口
Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法

## 31-12：Collections有哪些静态方法

1. 排序(Sort)

2. 混排（Shuffling）

3. 反转(Reverse)

4. 替换所有的元素(Fill)

5. 拷贝(Copy)

6. 返回Collections中最小元素(min)

7. 返回Collections中最小元素(max)

## 31-13：Comparable和Comparator区别

1. 实现Comparable的类，该类就具有自身比较的功能；Comparator的实现，是一个外部比较工具器 

# 32.java基础-设计类问题

## 32-1：如果想要一个key对应多个Value的话，怎么设计Map

https://blog.csdn.net/yanzhenjie1003/article/details/42541264?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase


## 32-2：插入一万个元素之后会不会扩容，扩容扩多少

HashMap 是否扩容，由 threshold 决定，而 threshold 又由初始容量和 loadFactor 决定。

1. HashMap 构造方法传递的 initialCapacity，它实际表示 table 的容量。
   
   * 只是代表了 table 数组容量为 1000

2. 构造方法传递的initialCapacity，最终会被tableSizeFor()方法动态调整为2的N次幂，以方便在扩容的时候，计算数据在
   newTable中的位置。

  * 虽然你传入了10000，但是实际传入的是10000/loadFactor，但是呢会调整为最接近的2 的 N 次幂
  
    * 如：实际传入了10000/0.75=13333，最接近的是2^13=16384，那么就采用16384
  
3. 如果设置了table的初始容量，会在初始化 table 时，将扩容阈值 threshold 重新调整为 table.size * loadFactor。

  * 那么可以储存的最大容量就是：16384*0.75=12288

## 32-3：创建一个对象HashMap<Integer,Integer> map=new HashMap<>先put(10),然后get(new Long(10))结果是多少？

为空，原因是

1. hashmap在存入的时候，先对key做一遍hash，以hash值作为数组下标，如果发现下标已有值，判断存的key跟传入的key是不是
   相同，如果相同覆盖，显然Integer 和 Long 肯定不是一个类型，所以 Long 123 和 Integer 123 hashmap会认为是 hash冲
   突

2. hashmap 在 get的时候，也是先做hash处理，根据hash值查找对应的数组下标查找,虽然存入Integer 123  根据 Long 123 
   来获取返回的 是 NULL

## 32-4：两个线程同时操作一个集合，一个线程读，一个线程写。有可能会产生并发问题吗？

多线程编程的时候往往用到互斥锁与信号量使得线程同步，如果不按此方法进行安全编程，很有可能使得线程对境界资源访问的时候
出现竞态。注意:我们需要达到的是线
程同步，需要避免的是竞态


# 33.java基础-IO-各种流

## 33-1：为何还要有字符流

因为我们不知道编码类型很容易出现乱码，所以IO就提供了一个直接操作字符的接口

## 33-2：字节流和字符流区别

1. 字节流不会用到缓冲区(内存)的，而字符流在操作的时候是使用到缓冲区的
2. 字节流在操作文件时，即使不关闭资源，文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，只有在使
   用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容
3. 字节流:处理字节和字节数组或二进制对象;字符流:处理字符、字符数组或字符串。

## 33-3：同步、异步与阻塞、非阻塞

同步：执行一个操作之后， 等待结果，然后执行其他后续的操作

异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没有执行完的操作

阻塞：进程给CPU传达一个任务后，一直等待CPU处理完成，然后执行后面的操作

非阻塞：进程给CPU传达一个任务后，继续处理其他的操作，隔段时间来询问之前的操作是否完成

## 33-4：BIO\NIO\AIO区别

BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。

（NIO与IO区别）NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的I/O模型，

1. IO流是阻塞的，NIO流是不阻塞的。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到
   buffer中后，线程再继续处理数据。Java IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程
   被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了

2. IO面向流(Stream oriented)，而NIO面向缓冲区(Buffer oriented)。在面向流的I/O中,可以将数据直接写入或者将数据直接
   读到Stream对象中。在从流读到缓冲区，因为Buffer是一个对象，它包含一些要写入或者要读出的数据。NIO是直接读到Buffer
   中进行操作。

3. NIO通过Channel（通道）进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因
   为 Buffer，通道可以异步地读写。

4. NIO有选择器，而IO没有。线程之间的切换对于操作系统来说是昂贵的，因此选择器用于使用单个线程处理多个通道提高系统效率
   选择器是有用的。

AIO: AIO 也就是NIO2。在引入了NIO的改进版,它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之
后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

## 33-5：linux的5种IO模型

1. 阻塞式IO模型

2. 非阻塞IO模型

3. IO复用模型

4. 信号驱动IO模型

5. 异步IO模型

## 33-6：IO多路复用

如果有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流，这样会造成CPU占有率会多高，这个实现方式
及其的不合理。

所以人们提出了I/O多路复用这个模型，一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力

## 33-7：三种常用的实现方式-select

a. 从用户空间将fd_set拷贝到内核空间
　　b. 注册回调函数
　　c. 调用其对应的poll方法
　　d. poll方法会返回一个描述读写是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。
　　e. 如果遍历完所有的fd都没有返回一个可读写的mask掩码，就会让select的进程进入休眠模式，直到发现可读写的资源后，重
新唤醒等待队列上休眠的进程。如果在规定时间内都没有唤醒休眠进程，那么进程会被唤醒重新获得CPU，再去遍历一次fd。
　　f. 将fd_set从内核空间拷贝到用户空间

select函数优缺点
　　缺点：两次拷贝耗时、轮询所有fd耗时，支持的文件描述符太小
　　优点：跨平台支持


## 33-8：三种常用的实现方式-poll

poll函数的调用过程（与select完全一致）

　　优点：连接数（也就是���件描述符）没有限制（链表存储）
　　缺点：大量拷贝，水平触发（当报告了fd没有被处理，会重复报告，很耗性能）

## 33-9：三种常用的实现方式-epoll

epoll的优点

没有最大并发连接的限制
只有活跃可用的fd才会调用callback函数
内存拷贝是利用mmap()文件映射内存的方式加速与内核空间的消息传递，减少复制开销。（内核与用户空间共享一块内存）
只有存在大量的空闲连接和不活跃的连接的时候，使用epoll的效率才会比select/poll高

## 33-10：三种常用的实现方式区别

(1)select==>时间复杂度O(n)

只是知道有I/O事件发生了，却并不知道是哪那几个流，我们只能无差别轮询所有流，找出能读出数据，同时处理的流越多，无差别轮
询时间就越长。

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的
限制，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实
际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。

例子：

1. select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 
   最多一次帮你监视1024个妹子
2. poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神
3. epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一
   个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.


# 34.java基础-反射

## 34-1：什么是反射

JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一
个方法和属性

## 34-2：反射会导致性能问题呢？

反射会造成性能问题

由于反射的时候调用了native方法，可能暂时无法准确判断

可能造成的原因也是可能是

在程序运行时操作class有关，比如需要判断是否安全？是否允许这样操作？入参是否正确？

是否能够在虚拟机中找到需要反射的类？主要是这一系列判断条件导致了反射耗时；

也有可能是因为调用natvie方法，需要使用JNI接口，导致了性能问题

在四种访问方式当中，直接访问实例的方式效率最高；

其次是直接调用方法的方式；

接着是通过反射访问实例的方式；

最慢的是通过反射访问方法的方式


## 34-3：如果避免反射导致的性能问题？

不要过于频繁地使用反射，大量地使用反射会带来性能问题；

通过反射直接访问实例会比访问方法快很多，所以应该优先采用访问实例的方式。

## 34-2：获取class对象方法

1. Object类的getClass();
2. 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
3. 通过Class类的静态方法：forName(常用)

## 34-3：Class.forName和classloader.loadClass的区别

1. 初始化不同:
   * Class.forName()会对类初始化，而loadClass()只会装载或链接。
   * foranme在类加载的时候会执行静态代码块，loadclass只有在调用newInstance方法的时候才会执行静态代码块
2. 类加载器不同:
   * Class.forName(String)方法(只有一个参数)，哪个调用了forname就用那个类加载器
   * ClassLoader.loadClass()方法是一个实例方法，调用时需要自己指定类加载器

## 34-4：哪些类不能反射

枚举，因为枚举类类的修饰abstract，所以没法实例化，反射也无能为力

## 34-5：反射优缺点

优点： 动态编译可以最大程度地支持多态，而多态最大的意义在于降低类的耦合性，因此反射的优点就很明显了:解耦以及提高代码
的
       灵活性。

缺点： 1、性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
        
      2、安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。

## 34-6：反射的应用场景

1. 使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；
2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；
3. 动态配置实例的属性；

# 35.java基础-注解

## 35-1：元注解以及分类

定义其他注解的注解 ，共四个

1. @Target（表示该注解可以用于什么地方）

2. @Retention（表示再什么级别保存该注解信息）

3. @Documented（将此注解包含再javadoc中）

4. @Inherited（允许子类继承父类中的注解）
 
## 35-2：Java常用注解

1. @Override 表示当前方法覆盖了父类的方法

2. @Deprecation 表示方法已经过时,方法上有横线，使用时会有警告。

3. @SuppressWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)

4. SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。

5. @FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。

扩展[Spring常用注解]()

# 36.java基础-泛型

## 36-1：什么是泛型

1. 允许在定义类和接口的时候使⽤类型

2. 泛型可以提⾼代码的复⽤性

## 36-2：编译器如何处理泛型

1. Code specialization：在实例化一个泛型类或泛型方法时都产生一份新的字节码or二进制代码。

2. Code sharing：对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类
   型检查和类型转换。

## 36-3：为什么Java要用这种编译器

1. C++和C#是使用Code specialization的处理机制，他有几个缺点:
   * 导致代码膨胀。
   * 在引用类型系统中，浪费空间

2. Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码
   表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。

## 36-4: 什么是类型擦除

Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参
数，在编译器编译的时候会去掉，这个过程成为类型擦除。

## 36-5：类型擦除过程

1. 将所有的泛型参数用最顶级的父类型进行替换。 

2. 移除所有的类型参数

## 36-6：泛型带来的问题

1. 虚拟机中没有泛型，只有普通类和普通方法,所有泛型类的类型参数在编译时都会被擦除,泛型类并没有自己独有的Class类对象。
   比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。 

2. 创建泛型对象时需要指明类型，让编译器尽早的做参数检查

3. 不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。 

4. 静态变量是被泛型类的所有实例所共享的。
    
5. 泛型的类型参数不能用在Java异常处理的catch语句中。

## 36-7：List泛型和原始类型List之间的区别?

 List<Object>和原始类型List之间的区别?
1. 在编译时编译器不会对原始类型进行类型安全检查，会对带参数的类进行检查
2. 你可以把任何带参数的类型传递给原始类型List，但是list会产生编译错误

## 36-8：List泛型和原始类型List泛型之间的区别?

List<?>和原始类型List<Object>之间的区别?

List<?>是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给
List<?>，却不能把List<String>赋值给 List<Object>。

## 36-9:子类继承父类的public可以写成private吗

可以写，但是变为private之后，需要对方法重写写get/set方法

## 36-10：多态时是否会出现类型擦除

会出现类型擦除

编译器在编译一个继承自泛型类的子类时，为了方法覆盖的签名匹配，保留泛型类型的多态性，会生成一个桥接方法

# 37-java基础-异常

## 37-1：异常的分类

1. Error表⽰系统级的错误，是java运⾏环境内部错误或者硬件问题，不能指望程序来处理这样的问题

2. Exception 表⽰程序需要捕捉、 需要处理的常， 是由与程序设计的不完善⽽出现的问题， 程序必须处理的问题。

## 37-2：Java 中的两种异常类型是什么？ 他们有什么区别？

Java 中有两种异常： 受检查的(checked)异常和不受检查的(unchecked)异常。

1. 不受检查的异常不需要在方法或者是构造函数上声明 
2. 受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。

## 37-3：异常类型

0. Java中的异常， 主要可以分为两⼤类——受检异常（ checked exception） 和 ⾮受检异常（ unchecked exception）

1. 受检异常

这种异常在IO操作中⽐较多。 ⽬的就是告诉这个⽅法的调⽤者，我这个⽅法不保证⼀定可以成功， 是有可能找不到对应的⽂件 
的， 你要明确的对这种情况做特殊处理哦。

2. 非受检异常

这种异常⼀般可以理解为是代码原因导致的。⽐如发⽣空指针、数组越界等。

## 37-4：什么是OOM？常见有哪些OOM？

1. Java堆溢出——OutOfMemoryError

原因：由于不断创建对象实例，当对象数量达到了最大堆的容量限制后产生内存溢出异常。

解决方法：

1)首先确认是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）；

2)如果是内存泄漏引起的，查看GC Roots引用链，找出为什么无法被垃圾回收的原因；

3)如果是内存溢出，检查虚拟机的堆参数（-Xmx最大值和-Xms最小值），对比物理内存看是否可以调大；

2. 虚拟机栈和本地方法栈溢出——StackOverflowError

原因：在单线程下，虚拟机栈容量太小或者定义了大量的本地变量

解决方法：增大虚拟机栈容量

原因：在多线程下，大量创建新线程，会抛出OOM，每个线程的栈分配的内存越大，越容易产生；

解决方法：减少线程产生、降低最大堆、减少栈容量；

3. 运行时常量池溢出

原因：代码在运行时创建了大量的常量，超出了常量池上限；

解决方法：通过修改-XX:PermSize和-XX:MaxPermSize参数来修改方法区大小，从而修改常量池大小；

4.方法区溢出

原因：在运行时，ClassLoader动态加载了大量的Class信息，超出方法区上限；

解决方法：通过修改参数来修改方法区大小；


## 37-3：异常链

是指在进⾏⼀个异常处理时抛出了另外⼀个异常， 由此产⽣了⼀个异常链条。

该技术⼤多⽤于将“ 受检查异常” （ checked exception） 封装成为“⾮受检查异常”（ unchecked exception)或者
RuntimeException。


# 38.java基础-常用类-String

## 38-1：String为什么是final的？

1. 它创建的时候HashCode就被缓存了，不需要重新计算，这样在键值对就运行很快
2. 为了线程安全，可以被多个线程调用
3. 只有字符串不变，才能实现字符串池，提高效率

## 38-2：拼接方式

1. 使用+
2. 使用concat
3. 使用StringBuilder
4. 使用StringBuffer
5. 使用StringUtils.join

## 38-3: String、StringBuffer和StringBuilder区别

1. 运行速度上：StringBuilder>StringBuffer>String(因为String每次都要生成新对象)

2. 线程安全：StringBuffer，String 

3. 是否可变：只有String不可变

4. 底层实现：StringBuffer用了同步块synchronized

## 38-4：StringBuffer如何实现线程安全

直接通过synchronized 关键字来实现同步操作

## 38-5：String 和 char[] 数组谁更适合存密码

相对来说是String更合适，原因是底层有final关键字进行了修饰

## 38-6：String str = new String("abc");创建了几个对象-百度，京东

分情况讨论：
1. 如果常量池中没有abc，会创建两个
   * 一个是new  String 创建的一个新的对象
   * 一个是常量“abc”对象的内容创建出的一个新的String对象

2. 如果常量池有，会创建一个

[详情1](https://blog.csdn.net/qq_36380686/article/details/83354393)
[详情2](https://www.cnblogs.com/zhaideyou/p/5874275.html)

## 38-7：处理数据量较大的字符串用string还是stringbuilder，为什么

Stringbuilder，操作字符串效率更高

注：StringBuffer虽然也可以处理字符而且线程安全，但是处理字符相对Stringbuilder慢

## 38-8：为什么StringBuffer和StringBuilder比String更快（不变性）

1. string类设计成final类型，每次有修改操作时，都会赋值给新的对象。

2. 因为赋值给新的对象，原来的对象就不再引用，就会进行回收。

3. 因为string拼接的扩容机制，当在某个点上，会发生oom(内存用完了)

## 38-9：如何把一段逗号分割的字符串转换成一个数组?

1 用正则表达式，代码大概为： String [] result = orgStr.split(“,”);
2 用 StingTokenizer 

## 38-10：String的内部属性

1. 创建一个能够容纳两个数组长度的数组

2. 使用getChars方法，将对象数组中赋值到新的数组中，偏移量为0；
	 
3. 使用getChars()方法将，参数数组赋值到新的数组中，偏移量对象数组的长度。
	 
4. 通过String构造器将数组转换成为新的字符串。

## 38-11：String的常用方法

1. 求字符串长度----length方法

2. 求字符串某一位置字符----charAt方法

3. 提取子串-----substring方法

4. 字符串比较-----compareTo方法

5. 字符串连接-----concat方法

6. 用于查找当前字符串中字符或子串----indexOf方法

7. 字符串中字符的大小写转换-----toLowerCase方法/toUpperCase方法

8. 字符串中字符的替换-----replace方法

# 39.java基础-常用类-枚举

## 39-1：enum线程安全

## 39-2: switch 是否可用于String类型的判断，Java哪个版本之后有此功能的

JDK1.7开始支持

# 40.Java基础-常用类-时间类

## 40-1：SimpDateFormat是线程不安全的类，不要定义为static变量，如果定义，必须加锁或工具类

1. SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。

2. 由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，
   SimpleDateFormat中的calendar也就可以被多个线程访问到。

解决方案：
1. SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。
2. 通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。
3. ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象


# 41.java基础-常用类-Object类

## 41-1：Object类有哪些方法

1. clone方法
2. getClass方法
3. toString方法
4. finalize方法
5. equals方法
6. hashcode方法
7. wait方法
8. notify方法
9. notifyAll方法

## 41-2：为什么操作线程方法会在Object对象中

1. 这些方法存在于同步中；
2. 使用这些方法必须标识同步所属的锁；
3. 锁可以是任意对象，所以任意对象调用方法一定定义在Object类中。

# 42.java基础-序列化

## 42-1：什么是序列化和饭序列化

1. 序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。

2. 反序列化是序列化的逆操作。

## 42-2：序列化的作用

1. Java远程方法调用
2. 对JavaBean进行序列化

## 42-3：java对象如何实现序列化

  * 实现Serializable接口
  * 实现ExternalSeri alizable方法

## 42-4：java对象如何实现反序列化

  * 实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法。
  * 实现externalSerializable接口的方法在反序列化时会调用构造方法。

## 42-5：哪些不会被序列化

1. 被static修饰的属性不会被序列化
2. 对象的类名、属性都会被序列化,方法不会被序列化


## 42-6：序列化协议有哪些

1. COM,COM的序列化的原理利用了编译器中虚表,使得其学习成本巨大.
2. CORBA，COBRA的主要问题是版本之间兼容性较差,以及使用复杂晦涩.
3. XML&5OAP，无论是性能还是间接性比较差
4. Thrift在时空开销上不太理想
5. JSON，序列化后数据更加简洁，而且解析速度较快
6. protobuf、avro不仅兼容json格式，解析速度更快

## 42-7：该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？

这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。

## 42-8: 什么是serialVersionUID

1. 这样做是为了serialVersionUID是用来验证版本一致性的，保证安全的，因为⽂件存储中的内容可能被篡改。
2. 在进⾏反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进⾏⽐较， 如果相
   同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常




# ---------------------------------------------------------------------------------------------------------------

# 1.线程与进程

## 1-1：什么是进程

系统运行一个程序，从创建，运行到消亡的过程这个是一个进程

## 1-2：何为线程?

线程是进程内的一个执行单元

## 1-3：线程与进程的区别

1. 拥有资源
   进程是资源分配的基本单位，虽然线程不拥有资源，线程可以访问隶属进程的资源

2. 调度
   线程是独立调度的基本单位

3. 系统开销
   创建或者撤销进程的开销大于线程的开销

4. 通信方面
   线程间可以通过读写进行通信，进程通信需要PIC

## 1-4：进程的通信方式

1. 管道

管道分为有名管道和无名管道,无名管道数据只能单向流动,而且只能在具有亲缘关系的进程间使用;有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。

2. 信号量

信号量是一个计数器,可以用来控 制多个线程对共享资源的访问.它常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.

3. 信号

信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.

4. 消息队列

消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.

5. 共享内存

共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.

6. 套接字：可用于不同及其间的进程通信

# 2.进程调度

## 2-1：什么时候会发生CPU调度

1. 当进程从运行状态转到等待状态；

2. 当进程从运行状态转到就绪状态；

3. 当进程从等待状态转到就绪状态；

4. 当进程从运行状态转到终止状态；

## 2-2：抢占式与非抢占式

非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。

抢占式调度，进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。

抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。

## 2-3：进程调度任务过程

1. 首先保存当前进程的处理机的现场信息

2. 按照算法选取进程

3. 把处理器分配给进程


## 2-4：进程的调度算法

1. 先来先服务调度算法

2. 最短作业优先调度算法

3. 高响应比优先调度算法

4. 时间片轮转调度算法

5. 最高优先级调度算法

6. 多级反馈队列调度算法


1. 非抢占式的先来先服务（First Come First Severd, FCFS）算法

先来后到，每次从就绪队列选择最先进入队列的进程，

然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。

FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

2. 最短作业优先（Shortest Job First, SJF）调度算法 
   
     它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。

      这显然对长作业不利，很容易造成一种极端现象。

     比如，一个长作业在就绪队列等待运行，
     
     而这个就绪队列有非常多的短作业，
     
     那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

3. 高响应比优先 （Highest Response Ratio Next, HRRN）调度算法
   
   主要是权衡了短作业和长作业。

   每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，
   
   「响应比优先级」的计算公式：
    
    优先权=（等待时间+要求服务时间）/要求服务时间

    - 如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；
    - 如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，
      这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，
      当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；

4. 时间片轮转（Round Robin, RR）调度算法。

每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。

如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；

如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

另外，时间片的长度就是一个很关键的点：

- 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；
- 如果设得太长又可能引起对短作业进程的响应时间变长；

注：通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。

5. 最高优先级调度算法

希望调度程序能从就绪队列中选择最高优先级的进程进行运行，

进程的优先级可以分为，静态优先级或动态优先级：

- 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
- 动态优先级：根据进程的动态变化调整优先级，
  
  比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，
  
  则升高其优先级，也就是随着时间的推移增加等待进程的优先级。该算法也有两种处理优先级高的方法，非抢占式和抢占式：

非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。

抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。但是依然有缺点，可能会导致低优先级的进程永远不会运行。

6. 多级反馈队列（Multilevel Feedback Queue）调度算法

「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。

「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；

设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；

新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，

如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；

当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。

如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，

接着让较高优先级的进程运行；可以发现，对于短作业可能可以在第一级队列很快被处理完。

对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，

虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。

# 3.并发级别

1. 阻塞

一个线程是阻塞的，那么在其他线程释放资源之前，

当前线程无法继续执行。比如：使用synchronize关键字或者其他重入锁，

我们得到的就是阻塞的线程。无论是synchronized或者重入锁，

都会在试图执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。

2. 无饥饿（Starvation-Free）

如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。

也就是说，对于同一个资源的分配，是不公平的。

锁也分公平锁和非公平锁，对于非公平锁来说，系统允许高优先级的线程插队。

这样就有可能导致低优先级的线程产生饥饿。

但是如果是公平锁，满足先来后到，那么饥饿就不会产生，

不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。

这样所有的线程都有机会执行。

3. 无障碍（Obstruction-Free）

无障碍是一种最弱的非阻塞调度。

两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。

换言之，大家都可以大摇大摆的进入临界区了。

那么如果大家一起修改共享区数据，把数据修改坏了怎么办呢？对于无障碍的线程来说，

一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。

但是如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。

从这个策略可以看出，无障碍的多线程程序不一定能顺畅的运行。

因为当临界区中存在严重的冲突时，所有的线程可能都会不断的回滚自己的操作，

导致没有一个线程能顺利走出临界区。这种情况会影响系统的正常执行。

一种可行的无障碍实现可以依赖一个“一致性标记”来实现：

线程在操作之前，先读取并保存这个标记，在操作完成之后，再次读取，

检查这个标记是否更改过，如果两者是一致的，则说明资源访问没有冲突。

如果不一致，则说明资源可能在操作过程中与其他线程存在冲突，

需要重新操作。而任何对资源有修改操作的线程，在修改数据前，

都需要更新这个一致性的标记，表示数据不再安全。

4. 无锁（Lock-Free）

无锁的并行都是无障碍的。

在无锁的情况下，所有的线程都能尝试对临界区进行访问，

但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作走出临界区。

在无锁的调用中，一个典型的特点是可能会包含一个无线循环。

在这个循环中，线程会不断尝试修改共享变量，如果没有冲突，修改成功，那么程序退出。

否则继续尝试修改，但无论如何，无锁的并行总能保证一个线程胜出，不会全军覆没。

至于临界区中竞争失败的线程，它们则必须不断重试，直到自己获胜，

如果运气不好，总是不成功，则会出现饥饿的现象，线程会停止不前。

5. 无等待（Wait-Free）

无锁只要求一个线程可以在有限步数内完成操作，

而无等待则是在无锁的基础上更进一步进行扩展，

它要求所有的线程都必须在有限步数内完成，这样就不会引起线程饥饿问题。

一种典型的无等待结构是RCU（Read-Copy-Update）。

它的基本思想是，对数据的读可以不加控制。

因此，所有的读操作是无等待的，他们既不会被锁定等待也不会引起任何冲突。

但是在写数据的时候，先取得原始数据的副本，

接着只修改副本数据（这就是为什么读可不加控制），修改完成后，在合适的时机回写数据。

# 4.并行与并发

## 4-1：并行与并发概念

1. 并发： 同⼀时间段，多个任务都在执⾏；
2. 并⾏： 单位时间内，多个任务同时执⾏。

## 4-2：并发特性

1. 原子性 : 要么所有的操作都执行，要么都不执行。
2. 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
3. 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。
            volatile 关键字可以禁止指令进行重排序优化。

# 5.多线程

## 5-1：为什么要使⽤多线程呢?

1. 线程间的切换和调度的成本远远⼩于进程。减少了线程上下⽂切换的开销。
2. 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能 
   ⼒以及性能。
3. 发挥多核 CPU 的优势
4. 防止阻塞

## 5-2：使⽤多线程可能带来什么问题?

并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，

但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多题，

⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。

## 5-3：多线程公共用一个数据注意什么

1. 当我们在线程对象( Runnable )中定义了全局变量, run方法会修改该变量时,如果有多个线程同时使用刻线程对象, 那么就会造成全局变量的值被同时修改,造成错误

2. ThreadLocal是JDK引入的一种机制,它用于解决线程间共享变量,使用ThreadLocal声明的变量，即使在线程中属于全局变量,针对每个线程来讲,这个变量也是独立的。

3. volatile变量每次被线程访问时,都强迫线程从主内存中重读该变量的最新值,而当该变量发生修改变化时,也会强迫线程将最新的值刷新回主内存中。这样一来 ,不同的线程都能及时的看到该变量的最新值。

## 5-4：如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？

1. 加锁顺序（线程按照一定的顺序加锁）
2. 加锁时限（线程尝试获取锁的时候加上一定的时限， 超过时限则放弃对该锁的请求，并释放自己占有的锁）
3. 死锁检测


## 5-5：单cpu上多线程效率和单线程比如何

单CPU来说（没有开启超线程），在同一时间只能执行一个线程，所以如果想实现多任务，那么就只能每个进程或线程获得一个时间片，在某个时间片内，只能一个线程执行，然后按照某种策略换其他线程执行。由于时间片很短，这样给用户的感觉是同时有好多线程在执行。但是线程切换是有代价的，因此如果采用多进程，那么就需要将线程所隶属的该进程所需要的内存进行切换，这时间代价是很多的。而线程切换代价就很少，线程是可以共享内存的。所以采用多线程在切换上花费的比多进程少得多。

# 6.线程的基本操作

## 6-1：线程的生命周期和状态

运行状态（Runing）：该时刻进程占用 CPU；

就绪状态（Ready）：可运行，但因为其他进程正在运行而暂停停止；

阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

创建状态（new）：进程正在被创建时的状态；

结束状态（Exit）：进程正在从系统中消失时的状态；

----------------------------------------------------------------------------------------------------------------------------------

NULL -> 创建状态：一个新进程被创建时的第一个状态；

创建状态 -> 就绪状态：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；

就绪态 -> 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；

运行状态 -> 结束状态：当进程已经运行完成或出错时，会被操作系统作结束状态处理；

运行状态 -> 就绪状态：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；

运行状态 -> 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；

阻塞状态 -> 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；


## 6-2：说说 sleep() ⽅法和 wait() ⽅法区别和共同点?

1. sleep ⽅法没有释放锁，⽽ wait ⽅法释放了锁 。
2. 两者都可以暂停线程的执⾏。
3. Wait 通常被⽤于线程间交互/通信， sleep 通常被⽤于暂停执⾏。
4. wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或notifyAll() ⽅法。 sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。

## 6-3：yield join notify notifyAll

1. yield()方法是停止当前线程， 让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话， 那么 yield()方法将不会起作用， 并且由可执行状态后马上又被执行。

2. join 方法是用于在某一个线程的执行过程中调用另一个线程执行， 等到被调用的线程执行结束后， 再继续执行当前线程。 如： t.join();//主要用于等待 t 线程运行结束， 若无此句，main 则会执行完毕， 导致结果不可预测。

3. notify 方法只唤醒一个等待（对象的） 线程并使该线程开始执行。 所以如果有多个线程等待一个对象， 这个方法只会唤醒其中一个线程， 选择哪个线程取决于操作系统对多线程管理的实现。

4. notifyAll 会唤醒所有等待(对象的)线程， 尽管哪一个线程将会第一个处理取决于操作系统的实现


## 6-4：为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？

new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开
始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅
法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

## 6-5：中断线程方法 

1. 使用退出标志， 使线程正常退出， 也就是当 run 方法完成后线程终止。 
2. 通过 return 退出 run 方法
3. 通过对有些状态中断抛异常退出thread.interrupt() 中断。 
4. 使用 stop 方法强行终止线程（过期）

## 6-6：一般线程和守护线程以及两者区别

所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程， 比如垃圾回收线程就是一个很称职的守护者， 并且这种线程并不属于程序中不可或缺的部分。 因 此，当所有的非守护线程结束时， 程序也就终止了， 同时会杀死进程中的所有守护线程。 反过来说， 只要任何非守护线程还在运行， 程序就不会终止。

区别：
为守护线程是 JVM 自动创建的线程， 用户线程是程序创建的线程； 比如 JVM的垃圾回收线程是一个守护线程， 当所有线程已经撤离， 不再产生垃圾， 守护线程自然就没事可干了， 当垃圾回收线程是 Java 虚拟机上仅剩的线程时， Java 虚拟机会自动离开。

# 7.创建线程

## 7-1：创建线程的方式

1. 继承 Thread类创建线程
  
  1）定义Thread类的子类，并重写该类的run方法，代表了线程要完成的任务
  
  2）创建了线程对象。
  
  3）调用线程对象的start()方法来启动该线程

2. 实现Runnable接口创建线程

1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

2）创建 Runnable实现类的实例，并以此实例作为Thread的 target来创建Thread对象，该Thread对象才是真正的线程对象。

3）调用线程对象的start()方法来启动该线程。

3. 使用Callable和Future创建线程，

1）创建Callable接口的实现类，并实现call方法，call方法作为线程执行体国

2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call（）方法

3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

4）调用FutureTask对象的get方法获得子线程执行结束后的返回值

4. 使用线程池

比如说用Executor框架


## 7-2：创建线程的对比

创建线程的方式的对比

1)采用实现Runnable、Callable接口的方式创建多线程时，线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
  
  在这种方式下，多个线程可以共享同一个 target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开。
  
  但是，缺点是编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread)方法。

2）使用继承Thread类的方式创建多线程时，

   如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
   
   缺点是线程类已经继承了Thread类，所以不能再继承其他父类。

3）Runnable和Callable的区别
  
  1) Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
  
  2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
  
  3)call方法可以抛出异常，run方法不可以。
  
  4)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，并检索计算的结果。
  
    通过Future对象可以了解任务执行情况，可取准任务的执行，还可获取执行结果。


## 7-3：实现Runnable接⼝和Callable接⼝的区别

Runnable ⾃Java 1.0以来⼀直存在，但 Callable 仅在Java 1.5中引⼊,⽬的就是为了来处理 Runnable
不⽀持的⽤例。 Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。所以，如果
任务不需要返回结果或抛出异常推荐使⽤ Runnable 接⼝，这样代码看起来会更加简洁。

## 7-4：实现 Runnable 接口比继承 Thread 类所具有的优势
1. 适合多个相同的程序代码的线程去处理同一个资源 
2. 可以避免 java 中的单继承的限制 
3. 增加程序的健壮性， 代码可以被多个线程共享， 代码和数据独立
4. 线程池只能放入实现 Runable 或 callable 类线程， 不能直接放入继承 Thread 的类 
5. runnable 实现线程可以对线程进行复用， 因为 runnable 是轻量级的对象， 重复 new 不会耗费太大资源， 而 Thread 则不然， 它是重量级对象， 而且线程执行完就完了， 无法再次利用

# 8.线程安全与线程同步

## 8-1：线程安全方式

1. synchronized关键字
2. volatile实现同步

 　　1）使用volatile关键字会强制将修改的缓存值立即写入主存。

　　 2）使用volatile关键字，当线程2进行修改时，会导致线程1的工作内存中变量缓存无效，然后线程1读取时发现自己的缓存无效他会等待缓存行对应的主存地址被更新之后，然后去主存读取最新信息。

　　 3）禁止指令重排序

　　　　　　（1）当程序执行到volatile变量的读操作或者写操作时，其前面的操作的更改肯定全部已经进　　　　行，且结果已经对后面的操作可见，在其后面的操作还没有进行。

　　　　　　（2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把　　　　　　volatile变量后面的语句放在其前面执行。
3. ThreadLocal管理变量
   
   ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。

4. 原子类

  原子类是基本类的原子化版本，通过线程安全的方式操作，等同于自动加synchronized

5. 使用Lock，读写锁

   lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）
   
   提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。
   
   本质上和监视器锁（即synchronized）是一样的

6. 容器类（BlockingQueue、ConcurrentHashMap）
   

## 8-2：线程同步方式

1. 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

# 9.synchronized关键字

## 9-1：synchronized关键字理解

1. 解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。
2. 在Java早期版本中， synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的， Java 的线程是映射到操
   作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，但是在JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

## 9-2：JDK1.6优化有哪些？

JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

1. 偏向锁

引入偏向锁的目是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替
使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。

2. 轻量级锁

轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。

如果没有竞争，轻量级锁使用CAS操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

3. 自旋锁和自适应自旋

一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋）也就是自旋。

另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。

4. 锁消除

就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。

5. 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能
损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。
   
## 9-3：底层原理

每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。

## 9-4：谈谈 synchronized和ReentrantLock 的区别

1. 两者都是可重入锁

自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的。

2. synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

3. ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

4. ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。

5. synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类借助于
   Condition接口与newCondition() 方法。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，

## 9-5：Lock和synchronized的区别

1. Lock需要手动获取锁和释放锁。
2. Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。
3. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死
   锁现象，因此使用 Lock 时需要在 finally 块中释放锁。
4. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。
5. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
6. Lock 可以通过实现读写锁提高多个线程进行读操作的效率。

## 9-6：synchronized的优势

1. 只需要基础的同步功能时，用synchronized。

2. Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。

3. 使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。

## 9-7：synchronized锁的膨胀过程（升级过程）

1. 整个膨胀过程在自旋下完成；

2. mark->has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行步骤（3），否则执行步骤（4）；

3. mark->monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；

4. 如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资
   源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；

5. 如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：

    通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；
    通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为
    markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；
    如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；

6. 如果是无锁，重置监视器值；

## 9-8：那如何判断共享数据不会被线程竞争？

利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。

在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。

# 10.volatile关键字

## 10-1：为什么要是用volatile关键字

目前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。

要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。

volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。

## 10-2：为什么其他线程能感知到变量更新

当多个CPU持有的缓存都来自同一个主内存的拷贝，当有其他CPU偷偷改了这个主内存数据后，其他CPU并不知道，那拷贝的内存将会和主内存不一致，那我们为了保证缓存一致，这里就需要操作系统来共同制定一个同步规则来保证，而这个规则就有MESI协议。

当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，系统会发出信号通知其它CPU将该内存变量的缓存行设置为无效。

当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。

为了让其他CPU是怎么知道要将缓存更新为失效的，这里是用到了总线嗅探技术。

每个CPU不断嗅探总线上传播的数据来检查自己缓存值是否过期了，如果处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。

## 10-3：volatile为什么不保证原子性吗？

比如说，当20个线程同时给number自增1，执行1000次以后，单线程情况下，肯定是20000，但是在多线程情况下，执行了某个指令number的值取到操作栈顶时，volatile关
键字保证了number的值在此时是正确的，但是在执行压栈等指令的时候，其他线程可能已经把number的值改变了，而操作栈顶的值就变成了过期的数据，就可能把较小的
number值同步回主内存之中。

## 10-4：怎么保证输出结果是20000呢？

1. synchronized同步代码块

我们可以通过使用synchronized同步代码块来保证原子性。

但是使用synchronized太重了，会造成阻塞，只有一个线程能进入到这个方法。

我们可以使用Java并发包（JUC）中的AtomicInterger工具包。

2. AtomicInterger原子性操作

两个线程，线程1和线程2都有主内存中变量的拷贝，值都等于10

线程1想要将值更新为20，先要将工作内存中的变量值与主内存中的变量进行比较，值都等于10，所以可以将主内存中的值替换成20

线程1将主内存中的值替换成20，并将线程1中的工作内存中的副本更新为20

线程2想要将变量更新为30，先要将线程2的工作内存中的值与主内存进行比较10不等于20，所以不能更新

线程2将工作内存的副本更新为与主内存一致：20

## 10-5：为什么要重排

计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。

## 10-6： 有哪几种重排

1. 编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2. 指令级的并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3. 内存系统的重排：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

## 10-7：举例说一下指令重排

定义了变量num=0和变量flag=false，线程1调用初始化函数init()执行后，线程调用add()方法，当另外线程判断flag=true后，执行num+100操作，那么我们预期的结果是num会等于101，但因为有指令重排的可能，num=1和flag=true执行顺序可能会颠倒，以至于num可能等于100

## 10-8： volatile怎么实现禁止指令重排？

在volatile生成的指令序列前后插入内存屏障来禁止处理器重排序。

volatile写的场景

在每个volatile写操作的前面插入一个StoreStore屏障（写-写 屏障）。

在每个volatile写操作的后面插入一个StoreLoad屏障（写-读 屏障）。

volatile读场景

在每个volatile读操作的后面插入一个LoadLoad屏障（读-读 屏障）。

在每个volatile读操作的后面插入一个LoadStore屏障（读-写 屏障）。

## 10-9：happen-before原则是什么

定义了哪些指令不能重排。
八大原则:
1. 单线程happen-before原则:在同一个线程中，书写在前面的操作happen-before后面的操作。
2. 锁的happen-before原则:同一个锁的unlock操作happen-before此锁的lock操作。
3. volatile的happen-before原则:对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包
   括写操作了)。
4. happen-before的传递性原则:如果A操作happen-before B 操作，B操作 happen-before C操作，那么A操作
   happen-beforeC操作。
5. 线程启动的happen-before原则:同一个线程的start方法 happen-before此线程的其它方法。
6. 线程中断的happen-before原则:对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的
   代码。
7. 线程终结的happen-before原则:线程中的所有操作都 happen-before线程的终止检测。
8. 对象创建的happen-before原则:一个对象的初始化完成先于他的finalize方法调用。


## 10-10：volatile都不保证原子性，为啥我们还要用它？

1. volatile是轻量级的同步机制，对性能的影响比synchronized小。

  * 比如线程试图通过类似于数绵羊的传统方法进入休眠状态，为了使这个示例能正确执行，asleep必须为volatile变量。否则，当asleep被另一个线程修改时，执行判断
  的线程却发现不了。

2. 因为synchorized和lock是排他锁（悲观锁），如果有多个线程需要访问这个变量，将会发生竞争，只有一个线程可以访问这个变量，其他线程被阻塞了，会影响程序的
   性能。


## 10-11：synchronized 关键字和 volatile 关键字的区别

1. volatile关键字是线程同步的轻量级实现，但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。
   synchronized关键字在1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。

2. 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞

3. volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。

4. volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。

# 11.线程池

## 10-1：使⽤线程池的好处

1. 降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。
2. 提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。
3. 提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监
   控。

## 10-2：常规实现线程池方法

（1） newFixedThreadPool定长线程池

它是一种固定大小的线程池;corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads:
keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉;但这里keepAliveTime无效;
阻塞队列采用了LinkedBlockingQueue，它是一个无界队列;由于阻塞队列是一个无界队列，因此永远不可能拒绝任务;由于采用了无界队列，实际线程数量将永远维持在 nThreads，因此 maximumPoolSize和keepAliveTime将无效。

(2） newCachedThreadPool可缓存

它是一个可以无限扩大的线程池;它比较适合处理执行时间比较小的任务;corePoolSize为O，maximumPoolSize为无限大，意味着线程数量可以无限大;

keepAliveTime为 60S，意味着线程空闲时间超过 60S就会被杀死;采用SynchronousOueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。

(3） newSingleThreadExecutor单一线程池它只会创建一条工作线程处理任务;采用的阻塞队列为LinkedBlockingQueue

(4）ScheduledThreadPool可调度的线程池实现周期性线程调度，比较常用。

## 10-3：线程池增长策略

当一个任务通过execute(Runnable)方法欲添加到线程池时:
1、如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处 
   理被添加的任务。
2、如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。
3、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于
    maximumPoolSize，建新的线程来处理被添加的任务。
4、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于     
   maximumPoolSize，那么通过handler所指定的策略来处理此任务。也就是:处理任务的优先级为:核心线程
   corePooSize、最大线程maximumPoolSize、任务队列workQueue
   如果三者都满了，使用handler处理被拒绝的任务。当线程池中的线程数大于corePooSize，如果某线程空闲
   时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。且体增长策略要看你
   使用什么workQueue。

## 10-4：线程池拒绝策略

1、AbortPolicy:这种策略直接抛出异常，丢弃任务（当都满了）
2、CallerRunsPolicy:策略显然个想放弁执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该
                    execute 的线程本身来执行。很有可能造成当前线程也被阻塞。
3、DiscardPolicy:不能执行的任务将被删除，这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不
                  抛出异常。
4、DiscardOldestPolicy:如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序
                      （如果再次失败，则重复此过程）


# 12.锁

## 12-1：锁

| 序号 | 锁名称  | 应用                                                              |
|----|------|-----------------------------------------------------------------|
| 1  | 乐观锁  | CAS                                                             |
| 2  | 悲观锁  | synchronized、vector、hashtable                                   |
| 3  | 自旋锁  | CAS                                                             |
| 4  | 可重入锁 | synchronized、Reentrantlock、Lock                                 |
| 5  | 读写锁  | ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet |
| 6  | 公平锁  | Reentrantlock(true)                                           |
| 7  | 非公平锁 | synchronized、reentrantlock(false)                             |
| 8  | 共享锁  | ReentrantReadWriteLock中读锁                                       |
| 9  | 独占锁  | synchronized、vector、hashtable、ReentrantReadWriteLock中写锁         |
| 10 | 重量级锁 | synchronized                                                    |
| 11 | 轻量级锁 | 锁优化技术                                                           |
| 12 | 偏向锁  | 锁优化技术                                                           |
| 13 | 分段锁  | concurrentHashMap                                               |
| 14 | 互斥锁  | synchronized                                                    |
| 15 | 同步锁  | synchronized                                                    |
| 16 | 死锁   | 相互请求对方的资源                                                       |
| 17 | 锁粗化  | 锁优化技术                                                           |
| 18 | 锁消除  | 锁优化技术                                                           |

## 12-2：乐观锁与悲观锁

1. 乐观锁

假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改也因此没有上锁。写数据时，判断当前与期望值是否相同，如果相同则进行
更新，更新期间加锁，保证是原子性的。

可以同时进行读操作，读的时候其他线程不能进行写操作。

2. 悲观锁

认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。

只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。

## 12-3：两种锁的使用场景

Java中的乐观锁：

CAS---比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。

Java中的悲观锁： 

synchronized修饰的方法和方法块、ReentrantLock。

## 12-4：乐观锁常见的两种实现方式

乐观锁一般会使用版本号机制或CAS算法实现。

1. 版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取
version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

2. CAS算法

## 12-5：乐观锁的缺点

1. ABA 问题

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标
志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2. 循环时间长开销大

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，
pause指令有两个作用，第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避
免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。

3. 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量
放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

## 12-6：自旋锁

## 12-7：自旋锁的优缺点

1. 自旋锁的优点： 避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。

2. 自旋锁的缺点： 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的
   限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。

## 12-8：自旋锁的升级——自适应自旋

自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息
的不断完善，虚拟机对程序锁的状态预测就会越来越精准。

## 12-9：自旋锁使用场景

Java中的自旋锁： CAS操作中的比较操作失败后的自旋等待。

## 12-10：可重入锁（递归锁）

任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。可重入锁的作用是避免死锁。

通过组合自定义同步器来实现锁的获取与释放。

- 再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。获取锁后，进行计数自增，
- 释放锁：释放锁时，进行计数自减。

## 12-11：可重入锁使用场景

ReentrantLock、synchronized修饰的方法或代码段。

## 12-12：可重入锁如果加了两把，但是只释放了一把会出现什么问题？

程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。

## 12-13：如果只加了一把锁，释放两次会出现什么问题？

会报错，java.lang.IllegalMonitorStateException。


## 12-14：读写锁

通过ReentrantReadWriteLock类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。

读锁： 允许多个线程获取读锁，同时访问同一个资源。

写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。

## 12-15：公平锁

多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队
列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。

也就是如果一个线程组里，能保证每个线程都能拿到锁


## 12-16：非公平锁

线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。

## 12-17：公平锁与非公平锁优缺点

优点： 非公平锁的性能高于公平锁。

缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）

## 12-18：公平锁与非公平锁使用场景

synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。

## 12-19：共享锁

a.当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁。
b.持有共享锁时间：从事务得到共享锁到读操作完成。
c.多个事务可以在同一阶段用共享锁作用于同一数据资源。
d.在读取数据时，可以对如何处理锁定进行控制。后面隔离级别会讲到如何对锁定进行控制。

## 12-20：共享锁使用场景

ReentrantReadWriteLock

## 12-21：独占锁

只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。

## 12-22：独占锁使用场景

synchronized，ReentrantLock

## 12-23：重量级锁

同上

## 12-24：重量级锁使用场景

synchronized

## 12-25：轻量级锁



## 12-26：轻量级锁优缺点

优点： 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。

缺点： 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。

## 12-27：偏向锁

## 12-28：偏向锁优缺点

优点： 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。

缺点： 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。

## 12-29：分段锁

它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在
ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，
并完成 put 操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。

ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保
证每个 Segment 是线程安全的，也就实现了全局的线程安全

## 12-30：互斥锁

也是x锁，该锁每一次只能被一个线程锁持有，加锁后任何线程试图再次加锁的线程会被阻塞，直到当前线程解锁，例子：如果 线程A 对deta1加上排它锁后，则其他线程不能再对data1 加任何类型的锁，获得互斥锁的线既能读取数据又能修改数据

## 12-31：同步锁

表示并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。

## 12-32：死锁

如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就
会造成死锁。

Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁。

## 12-33：锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能
损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。

## 12-34：锁消除

## 12-35：提高锁性能的方法
1. 减少锁持有时间
2. 减少锁粒度
3. 读写分离锁来替换独占锁
4. 锁分离
5. 锁粗话

# 13.ThreadLocal

## 13-1：什么是ThreadLocal


## 13-2：ThreadLocal的实现原理

## 13-3：ThreadLocal的优势

## 13-4：ThreadLocal内存泄露问题

ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。所以，如ThreadLocal 没有被外部强引⽤的情况下，在垃圾回收的时候， key 会被清理掉，⽽ value 不会被清理掉。这样⼀来， ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远⽆法被GC 回收，这个时候就可能会产⽣内存泄露。 ThreadLocalMap实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null 的记录。使⽤完ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法

# 14.无锁

## 14-1：CAS

CAS是比较并交换。比较变量的现在值与之前的值是否一致，若一致则替换，否则不替换。

CAS的作用：原子性更新变量值，保证线程安全。

需要有三个操作数，变量的当前值（V），旧的预期值（A），准备设置的新值（B）。

CAS指令执行条件：当且仅当V=A时，处理器才会设置V=B，否则不执行更新。

CAS的返回值：V的之前值。

CAS处理过程：原子操作，执行期间不会被其他线程中断，线程安全。

## 14-2：CAS的ABA问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说它值没有被其
他线程改变过吗?如果在这段期间它的值曾经改成了B，后来又改成了A，那么CAS操作就会误认为它没有改变过，
这个漏洞称为“ABA”问题。解决的核心思想是加上时间戳来标识不同阶段的数值。比如:J.U.C包为了解决这个问
题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证
CAS的正确性，如果需要解决ABA问题，改用传统的互斥同步（典型的就是synchronized和Lock）可能会比原子
类更高效。

# 11.Atomic原子类

## 11-1：为什么要使用原子类

为了让Java程序员能够受益于CAS等CPU指令，JDK并发包有一个atomic包，里面实现了一些直接使用CAS操作的线程安全的类型

## 11-2：什么是原子类

原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。

原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。

## 11-3：原子类的作用？

提供一种简单、性能高效、线程安全地更新一个变量的方式。

## 11-4：i++自增操作不是原子性的，如何决绝原子性问题

Atomic原子类就是来解决这个问题的，

## 11-5：基本数据类型原子类的优势

多线程环境使用原子类保证线程安全（基本数据类型）

## 11-6：为什么是unsafe


# 12. 死锁

## 12-1：什么是线程死锁

多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。

## 12-2：产生死锁的条件

1. 该资源任意⼀个时刻只由⼀个线程占⽤。
2. ⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
3. 线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。
4. 若⼲进程之间形成⼀种头尾相接的循环等待资源关系。

## 12-3：如何解决线程死锁问题

1. ⼀次性申请所有的资源。
2. 占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. 靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。

# 13.AQS

## 13-1：对AQS原理分析

如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。

## 13-2：AQS 对资源的共享⽅式

1. Exclusive（独占）：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁：
   * 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
   * ⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的
2. Share（共享）：多个线程可同时执⾏，如Semaphore/CountDownLatch。 Semaphore、
CountDownLatch、 CyclicBarrier、 ReadWriteLock 我们都会在后⾯讲到。

## 13-3：AQS 组件

Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

# 14.并发容器

## 14-1：JDK 提供的并发容器总结

ConcurrentHashMap: 线程安全的 HashMap
CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.
ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

## 14-2：CopyOnWriteArrayList 是如何做到的？
CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。

从 CopyOnWriteArrayList 的名字就能看出CopyOnWriteArrayList 是满足CopyOnWrite 的 ArrayList，所谓CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。

## 14-3：BlockingQueue

直接提交队列、有界队列、无界队列、优先级任务队列。

# 15.快速失败与安全失败

一:快速失败（fail-fast）

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加.删除、修改），则会抛出 Concurrent Modification Exception。

场景:java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改)。

二:安全失败（failsafe）

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

原理:由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

缺点:基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即:迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

场景:java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

# 16.什么是上下⽂切换?

当前任务在执⾏完 CPU时间⽚ 切换到另⼀个任务 之前 会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。 任务从保存到再加载的过程就是⼀次上下⽂切换。


# ---------------------------------------------------------------------------------------------------------------

# 1.类加载

## 1.1：类的生命周期

类的生命周期包括：加载、连接、初始化、使用和卸载

## 1.2：类的加载过程

类的加载过程分为：加载->连接->初始化。连接过程又可分为三步:验证->准备->解析

1. 加载，

      1. 通过全类名获取定义此类的二进制字节流
      2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

2. 连接，连接又包含三块内容：验证、准备、初始化。
   * 1）验证，文件格式验证、元数据验证、字节码验证、符号引用验证；
   * 2）准备，为类的静态变量分配内存，并将其初始化为默认值；
   * 3）解析，虚拟机将常量池内的符号引用转换为直接引用

3. 初始化，开始执行java代码

4. 使用，new出对象程序中使用

5. 卸载，执行垃圾回收
   
    卸载类需要满足3个要求:
         1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
         2. 该类没有在其他任何地方被引用
         3. 该类的类加载器的实例已被GC

* 理解：在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 1.3：类加载机制

1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用
   另外一个类加载器来载入

2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要���用某个Class时，类加载器先从缓存区寻找该Class，
   只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，
   必须重启JVM，程序的修改才会生效

## 1.4：知道哪些类加载器?



# 2.双亲委派模型

## 2-1：双亲委派模型流程

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即
在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载
的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启
动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null
时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

## 2-2：双亲委派模型带来了什么好处呢？

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。

## 2-3：如果我们不想⽤双亲委派模型怎么办？

自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法

## 2-4：自己写一个类能不能被加载？

不能，因为双亲委派机制可以打破，但是不会实现成功的原因在于针对java开头的类，jvm实现中已经保证了必须由bootatrp来加载

但是如果非要加载的话，可以放在用户目录下进行加载


# 3.垃圾回收

## 3-1：如何判断对象已经死亡？

1. 引用计数法
给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，比如说对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

2. 可达性分析算法
这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

## 3-2：不可达的对象是否非死不可

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一
个对象死亡，至少要经历两次标记过程;可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的
条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调
用过时，虚拟机将这两种情况初为沿右必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标
记，除非这个对象与引用链上的任何一个对象简历关联，否则就会真的回收。

## 3-2：强、软、弱、虚引用

1．强引用（StrongReference）

如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

2．软引用（SoftReference）

如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

3．弱引用（WeakReference）

如果一个对象只具有弱引用，弱引用关联的对象只能生存到下一次垃圾回收之前。

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4．虚引用（PhantomReference）

虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

虚引用主要用来跟踪对象被垃圾回收的活动。

虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

## 3-3：如何减少 GC 的次数

1. 对象不用时最好显示置为 NULL

2. 尽量少使用 System,gc()

3. 尽量少使用静态变量

4. 尽量使用 StringBuffer,而不使用 String 来累加字符串
5. 分散对象创建或删除的时间

6. 尽量少用 finaliza 函数

7. 如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory

8. 能用基本类型入 INT 就不用对象 Integer

9. 增大-Xmx 的值

## 3-4：GC 是什么?为什么要有 GC?

GC是垃圾收集的意思

内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， Java 语言没有提供释放已分配内存的显示操作方法

## 3-5：垃圾回收的优点

1. 可以有效的防止内存泄露
2. 有效的使用可以使用的内存。

## 3-6：垃圾回收器的基本原理是什么？

对于 GC 来说，当程序员创建对象时， GC 就开始监控这个对象的地址、大小以及使用情况。
通常， GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当 GC 确定一些对象为"不可达"时， GC 就有责任回收这些内存空间。

## 3-7：什么样的对象需要回收

对象到GC Roots没有引用链， 那么这个对象不可用， 需要回收

## 3-8：可作为GC Roots的对象？

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法引用的对象

## 3-9：垃圾回收器可以马上回收内存吗？

不可以？？？？？？

## 3-10：有什么办法主动通知虚拟机进行垃圾回收？

可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。

## 3-11：如何判断一个类是无用的类

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 3-12：如何判断一个常量是废弃常量？

假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

## 3-11：垃圾回收算法

1. 标记-清除算法
   
算法分为“标记”和“清除”阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到。

这种垃圾收集算法会带来两个明显的问题：

1. 效率问题
2. 空间问题（标记清除后会产⽣⼤量不连续的碎⽚）

2. 复制算法

为了解决效率问题， 它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就
将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的
⼀半进⾏回收。

3. 标记-整理算法

根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收
对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。

4. 分代收集算法

根据对象存活周期的不同将内存分为⼏块。⼀般将java堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的
特点选择合适的垃圾收集算法。

## 3-12：Minor Gc和Full GC 有什么不同呢？

⼤多数情况下，对象在新⽣代中eden 区分配。当 eden 区没有⾜够空间进⾏分配时，虚拟机将发起⼀次Minor GC。

1. 新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， Minor GC⾮常频繁，回收速度⼀般也⽐较快。

2. ⽼年代GC（Major GC/Full GC） :指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的Minor GC
   （并⾮绝对），Major GC的速度⼀般会⽐Minor GC的慢10倍以上。


## 3-13：何时发生full gc

1. System.gc()方法的调用 ，system.gc(), 此方法的调用是建议JVM进行Full GC, 可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。 

2. old/Tenured 空间不足 

3. perm/metaspace 空间不足

4. CMS GC时出现promotion failed和concurrent mode failure 

5. 判断当前新生代的对象是否能够全部顺利的晋升到老年代，如果不能，就提早触发一次老年代的收集

# 4.常⻅的垃圾回收器有那些?

## 4-1：Serial收集器

不仅只会使⽤⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程，直到它收集结束。

优势：

1. 简单⽽⾼效
2. 由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。 

## 4-2：ParNew收集器

除了使⽤多线程进⾏垃圾收集外，其余⾏为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。

## 4-3：Parallel Scavenge收集器

Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

新生代采用复制算法，老年代采用标记-整理算法。 

## 4-4：Serial Old收集器

Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

## 4-5：Parallel Old收集器

Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

## 4-6：CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 并发收集器，

它第一次基本上实现了让垃圾收集线程与用户线程同时工作。

整个过程分为四个步骤：

1. 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
2. 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构
              并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
3. 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分
              对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
4. 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

主要优点：并发收集、低停顿。

但是它有下面三个明显的缺点：

对 CPU 资源敏感；
无法处理浮动垃圾；
它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

## 4-7：G1收集器

G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

它具备一下特点：

特点:并发性强、分代收集、标记整理进行空间整合，可以预测停顿时间。

1. 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 
   Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
2. 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
3. 空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部
   上来看是基于“复制”算法实现的。
4. 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 
   除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

1. 初始标记
2. 并发标记
3. 最终标记
           将并发阶段对象变化记录在线程Remenbered Set Logs里面，最终把Remembered Set Logs的数据合
           并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。
4. 筛选回收
           筛选回收，对每一个region的价值和成本进行筛选，根据用户期望的GC停顿时间，得到最好的回收方案并回收。


G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

## 4-8：吞吐有限和响应有限的垃圾收集器如何选择

1. 吞吐量优先
新生代采用Paralle Scavenge,老年代采用Parallel Old.并配置 多个线程进行回收。设置参数来调整最大垃圾收集停顿时间和吞吐量的大小。
2. 响应时间优先
设置老年代的收集器是CMS (最短时间，spark streaming采用这个)。年轻代是ParnNiew(多线程)。


# 5.Java内存结构（JMM）

## 5-1：为什么需要Java内存模型？

屏蔽各种硬件和操作系统的内存访问差异

## 5-2：什么是JMM

JMM是Java内存模型，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

## 5-3：什么是Java内存模型？

1. 定义程序中各种变量的访问规则

2. 把变量值存储到内存的底层细节

3. 从内存中取出变量值的底层细节

## 5-4：Java内存模型的两大内存是啥？

1. 主内存
  * Java堆中对象实例数据部分
  * 对应于物理硬件的内存
2. 工作内存
  * Java栈中的部分区域
  * 优先存储于寄存器和高速缓存

## 5-5：内存如何工作

线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存

## 5-6：Java内存模型三大特性

可见性（当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改）
原子性（一个操作或一系列操作是不可分割的，要么同时成功，要么同时失败）
有序性（变量赋值操作的顺序与程序代码中的执行顺序一致）

## 5-7：jvm内存结构

1. 堆
Java堆是用来存放实例对象和数组对象的，由于存在逃逸分析找术(分析这个对象不会被其他方法或者线程调用)，也可以分布在栽上，随着出栈而销毁，同时，java堆也是垃圾回收的主要区域，由于现在垃圾收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为:新生代和老年代

Java堆在物理上可以不连续，只要逻辑连续就好。在堆上分配对象的方法有:指针碰撞和空闲列表，前者是在堆内存规整的情景下，所有用过和空闲的内存中间有明确的分界线，而后者用空闲列表来记录内存的使用情况，规整是由垃圾回收器是否压缩整理决定。空间不足抛出OutOfMemoryError.

堆上对象的访问方式:通过栈上的 reference数据来操作堆上的具体对象。目前主流的访问了式有使用句柄和直接指针两种。句柄的话，Java堆中将会划分出一块内存来作为句柄池reference中存储的就是对像的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，直接指针的话，reference中存储的直接就是对象的地址，前者稳定后者效率高

2. 方法区

方法区与Java堆一样，是各个线程共享的内存区域，特用于存储已被虚拟机加载的类信息，常量、静态变量，其中运行时常量池、用于存放编译器生成的各类字面量和符号引用(字面量：1.文本字符串，2.八种基本数据类型的值，3.被声明为final的常量，符号引用：1.类和方法的权限定名，2.字段的名称和描述符3.方法的名称和描述符)运行时常量池相对于Class常量池具有动态性，可以在运行期间利用intern方法将常量池放入池中，空间不足抛出OOMError


3. 虚拟机栈
虚拟机栈是java方法执行的内存模型，线程私有，每个方法执行都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接(运行时将方法区的符号引用转化为直接引用，表示真的可以调用了)和方法出口等信息围每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

StackOverflowError:线程请求的栈深度大于虚拟机所允许的深度。

OutofMemoryError:如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

4. 本地方法栈
jvm调用本地方法（可以为其他语言提供接口）。

5. 程序计数器
记录当前线程所执行到的字节码的行号。每个线程都有一个程序计数器，唯一没有OutOfMemoryError情况的内存
区域。

运行时内存区域外规定的堆外内存:直接使用 Native函数库直接分配堆外内存，然后通过一个存储在java堆中的
DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java
堆和Native堆之间来回复制数据。

## 5-8：程序计数器为什么是私有的?

程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。

## 5-9：虚拟机栈和本地⽅法栈为什么是私有的?

为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地⽅法栈是线程私有的。

## 5-10：堆和栈的区别是什么？

一个是线程独享的，一个是线程共享的

堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。

## 5-11：Java中的数组是存储在堆上还是栈上的？

所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。

## 5-12：Java 8的metaspace (元空间)

方法区是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区是JVM的规范，

永久代(PermGen space )是HotSpot对这种规范的实现。在JDK1.8中，HotSpot已经没有永久代，取而代之的是Metaspace( 元空间)。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。

## 5-13：为什么要进行元空间代替持久代呢?

1. 字符串存在永久代中，容易出现性能问题和内存溢出。

2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。

## 5-14：Java中的对象一定在堆上分配内存吗？

前面我们说过，Java堆中主要保存了对象实例，但是，

在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。

如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。

## 5-15：怎么如何获取堆和栈的dump文件？

是一个Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。

可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。

## 5-16：不同的虚拟机在实现运行时内存的时候有什么区别？

前面提到过《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：
方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。
这一规定，可以说是给了虚拟机厂商很大的自由。
虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。
实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。
在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）

# 6.新生代， 老年代， 持久代

## 6-1：新生代， 老年代， 持久代？ 各存了什么？

1. 新生代
   
   * 存放存活率低的对象， 比如说新创建的对象一般放新生代（Eden区）

2. 老年代
   
   * 存放存活率较高的对象，新生代的对象经过minor gc（年轻代收集）后存活且survivor区可容纳则进入survivor区， 年龄为1，在survivor区每安全度过一次minor gc， 年龄加一， 一般年龄为15就进入老年代

3. 持久代
   * 就是方法区

# 7. HotSpot虚拟机对象

## 7-1：说⼀下Java对象的创建过程

Step1:类加载检查
虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

Step2:分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

内存分配的两种方式：（补充内容，需要掌握）

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

内存分配的两种方式

内存分配并发问题（补充内容，需要掌握）

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

Step3:初始化零值
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

Step4:设置对象头
初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

Step5:执行 init 方法
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 7-2：内存分配的两种⽅式选择

分配⽅式有 “指针碰撞” 和 “空闲列表” 两种

选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC收集器的算法是"标记-清除"，还是"标记-整理"，

## 7-3：虚拟机如何保证线程安全

1. CAS+失败重试： 虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
2. TLAB： 为每⼀个线程预先在Eden区分配⼀块内存， JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分配

## 7-4：对象的访问定位有哪两种⽅式?

①使⽤句柄

   * 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池， reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
②直接指针

  * 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址


## 7-5：访问定位两种方式的优缺点

1. 使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。
2. 使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。

## 7-6：对象分配规则

1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。

2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。

3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。

4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 


# 8.内存泄露与内存溢出

## 8-1：什么是内存泄漏

指一个不再被程序使用的对象或变量一直被占据在内存中。 

## 8-2：什么是内存溢出

指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，

## 8-3：内存溢出， 内存泄漏区别？

1. 内存泄露积累起来将导致内存溢出。

2. 内存泄露可以通过完善代码来避免； 内存溢出可以通过调整配置来减少发生频率， 但无法彻底避免。

## 8-4：如何避免内存泄露、 溢出？

1. 尽早释放无用对象的引用。
2. 使用临时变量的时候， 让引用变量在退出活动域后自动设置为null， 暗示垃圾收集器来收集该对象， 防止发生内存泄露。
3. 程序进行字符串处理时， 尽量避免使用String， 而应使用StringBuffer， 因为每一个String对象都会独立占用内存一块区域

## 8-5：如何检测内存泄露？

可以通过一些性能监测分析工具， 如 JProfiler、 Optimizeit Profiler。

## 8-6：java中会存在内存泄露呢？什么时候发生

会存在内存泄露

但是也有几种情况会造成内存泄漏：

1. 静态集合类，容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。

2. 各种连接，如数据库连接、网络连接和IO连接等。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，将会造成大量的对象无法被回收，从而引起内存泄漏。

3. 变量不合理的作用域。一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。

4. 内部类持有外部类，由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

5. 改变哈希值，造成内存泄露

## 8-7：什么情况下会发生堆内存溢出，栈内存溢出

栈溢出(StackOverflowError)

栈是线程私有的，他的生命周期与线程相同，

每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。

局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）

栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。

堆溢出(OutOfMemoryError:java heap space)

堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出


# 9.调优工具

## 9-1：调优工具有哪些？

常用调优工具分为两类

1. jdk自带监控工具：jconsole和jvisualvm，
2. 第三方监控工具：MAT(Memory Analyzer Tool)、GChisto。

jconsole，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控

jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。

MAT，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

GChisto，一款专业分析gc日志的工具


# 10.JVM进程有哪些线程启动? (拼多多)

1. main主线程，执行我们指定的启动类的main方法
2. Reference Handler处理引 用的线程，用于处理引用对象本身(软引用、弱引用、虚引用)的垃圾回收问题
3. Finalizer调用对象的finalize方法的线程，就是垃圾回收的线程
4. Signal Dispatcher分发处理发送给JVM信号的线程
5. Attach Listener负责接收外部的命令的线程

# 11.jvm启动模式之client 与server

jvm启动时，通过-server 或-client参数指定启动模式。

(1)编译器方面:
当虚拟机运行在client 模式时，使用的是一一个代号为 c1的轻量级编译器，而server模式启动时，虚拟机采用的是相对重量级，代号为c2的编译器: c2编译器比cl编译器编译的相对彻底，服务起来之后，性能高。

(2)gc方面:
cilent模式下的新生代(Serial 收集器)和老年代(Serial Old)选择的是串行gc server模式下的新生代选择并行回收ge,老年代选择并行ge

(3)启动方面:
client模式启动快，编译快，内存占用少，针对桌面应用程序设计，优化客户端环境的启动时间。server模式启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用设计，优化服务器环境的最大化程序执行速度

# 12.简述JVM中静态分派和动态分派(引申:重载和重写)。

1.静态分派:依赖静态类型定位方法的分派，发生在编译时期，奥型应用为方法的秋.
(重载的参数是通过静态类型确定的，直接调用父类)
2、动态分配:在运行时期根据实际类型来确定方法的分派，发生在程序运行时，
典型应用
是方法的重写，也是多态的一种体现。 根据转型来确定是否调用父类还是子类的方法。
虚方法和非虚方法:
(1)非虚方法(所有statie方法+final/private方法)通过invokespecial指令调用，对这个
非虚方法的符号引用将转为对应的直接引用，即转为直接引用方法，在编译完成时就确定唯
一的调用方法。
(2)虚方法是通过invokevirtual 指令调用，且会有静态或者动态分派分派。具体先根据编
译期时方法接收者和方法参数的静态类型来分派，再在运行期根据只根据方法接收者的实际
类型来分派。
 

# ---------------------------------------------------------------------------------------------------------------

# 1.计算机网络-HTTP-get与post

## 1-1：get与post的区别

1. Get是请求从服务器获取资源，Post用于传输实体本体
2. get和post请求都能使用额外的参数，get参数是以查询字符串出现在URL中，post参数存储在实体主体中
3. Http方法不会改变服务器状态，get方法是安全的，而post由于是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功后，服务器可能把这个数据存储到
   数据库中，因此状态也就发生了变化
4. get在调用多次时，客户端收到的结果是一样的， 所以是幕等；post调用多次，会增加多行记录，不是幕等
5. get可缓存，post不可缓存
6. 对于get请求，浏览器会把http 头和数据一并发送出去，服务器响应200；post请求，浏览器先发送header，服务器响应之后，浏览器在发送数据，服务器响应200

# 2.计算机网络-HTTP-报文结构与状态码

## 2-1：状态码

2xx （3种）

200 OK：表示从客户端发送给服务器的请求被正常处理并返回；

204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；

206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。

3xx （5种）

301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；

302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；

       301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）

303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；

      302与303的区别：后者明确表示客户端应当采用GET方式获取资源

304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；

307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；

4xx （4种）

400 Bad Request：表示请求报文中存在语法错误；

401 Unauthorized：未经许可，需要通过HTTP认证；

403 Forbidden：服务器拒绝该次访问（访问权限出现问题）

404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；

5xx （2种）

500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；

503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；

## 2-2：HTTP请求组成

一个HTTP请求报文由四个部分组成：请求行、请求头、空行、请求数据。

1. 请求行

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1

2. 请求头部

HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，。

常见的请求头字段含义：

Accept： 浏览器可接受的MIME类型。

Accept-Charset：浏览器可接受的字符集。

Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。

Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。

Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。

Content-Length：表示请求消息正文的长度。

Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。

If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间。只有当所请求的内容在指定的时间后又经过修改才返回它，否则返回304“Not Modified”应答。

Referer：客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的(防盗链)。包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。

User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。

Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。

Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。

From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。

Connection：处理完这次请求后是否断开连接还是继续保持连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含
多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容
之前计算它的大小。

Range：Range头域可以请求实体的一个或者多个子范围。例如，

表示头500个字节：bytes=0-499

表示第二个500字节：bytes=500-999

表示最后500个字节：bytes=-500

表示500字节以后的范围：bytes=500-

第一个和最后一个字节：bytes=0-0,-1

同时指定几个范围：bytes=500-600,601-999
  
但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206(PartialContent)返回而不是以200 (OK)。

UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。

3. 空行

它的作用是通过一个空行，告诉服务器请求头部到此为止。

4. 请求数据
若方法字段是POST,则通常来说此处放置的就是要提交的数据


# 3.计算机网络-HTTP-HTTP的1.0-3.0

## 3-1：HTTP1.0优缺点

<font color=red size='5'>I.优点</font>

1. HTTP基本的报⽂格式就是header + body，头部信息也是key-value简单⽂本的形式。

2. HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。

3. HTTP由于是⼯作在应⽤层，则它下层可以随意变化。

4. 应⽤⼴泛和跨平台

<font color=red size='5'>II.缺点</font>

1. ⽆状态
由于⽆状态，它在完成有关联性的操作时会⾮常麻烦。例如登录->添加购物⻋->下单->结算->⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。

2. 明⽂传输

明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的控制台或抓包软件都可以直接⾁眼查看，信息的内容都毫⽆隐私可⾔，很容易就能被窃取。

## 3-2：HTTP/1.1相对于HTTP1.0改善

1. ⻓连接，早期HTTP/1.0，那就是每发起⼀个请求需要三次握手四次挥手等等操作，增加了通信开销。为了解决这些问题，HTTP/1.1提出了⻓连接的通信⽅式只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。
   
2. HTTP/1.1 采⽤了⻓连接的⽅式，可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

3. 错误状态响应码，HTTP1.1新增了很多错误装填响应码，让开发者更加了解错误根源

4. 在HTTP1.0中主要使⽤header⾥的If-Modified-Since,Expires来做为缓存判断的标准，在HTTP1.1中引⼊了更多的缓存控制策略

5. HTTP1.0中，存在⼀些浪费带宽的现象，例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，并且不⽀持断点续传功能，HTTP1.1则在请求头引⼊了range头域，它允许只请求资源的某个部分

## 3-3：HTTP1.1缺点
1. 请求 / 响应头部未经压缩就发送，⾸部信息越多延迟越⼤。
2. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
3. 请求只能从客户端开始，服务器只能被动响应。


## 3-4：HTTP⻓连接,短连接(也是TCP连接,短连接)

1. 在HTTP/1.0中默认使⽤短连接。也就是说，客户端和服务器每进⾏⼀次HTTP操作，就建⽴⼀次连接，任务结束就中断连接。
2. 从HTTP/1.1起，默认使⽤⻓连接。客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接

## 3-5：HTTP/2 做了什么优化？

1. HTTP/2 会压缩头如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。
  
  这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。

2. HTTP/2全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，计算机收到报⽂后，直接解析⼆进制报⽂，这增加了数据传输的效率。

3. HTTP/2的数据包不是按顺序发送的

4. HTTP/2是可以在⼀个连接中并发多个请求或回应。

5. HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。

## 3-6：HTTP/2有哪些缺陷？ 

多个HTTP请求在复⽤⼀个TCP连接，下层的TCP协议是不知道有多少个HTTP请求的。所以⼀旦发⽣了丢包现象，就会触发TCP的重传机制，这样在⼀个TCP连接中的所有的 HTTP请求都必须等待这个丢了的包被重传回来。

## 3-7：HTTP/3做了哪些优化？

HTTP/3把HTTP下层的TCP协议改成了UDP

因为UDP发⽣是不管顺序，也不管丢包的，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的⼀个丢包全部重传问题。

但是由于UDP是不可靠传输的，而基于UDP的QUIC协议可以实现类似TCP的可靠性传输。主要是依赖

1. 当某个流发⽣丢包时，只会阻塞这个流， 其他流不会受到影响。
2. 更改了头部压缩算法，升级成了 QPack 。
3. QUIC 直接把以往的TCP和TLS/1.3的6次交互合并成了3次，减少了交互次数。

# 4.计算机网络-HTTP-HTTPs

## 4-1：HTTP与HTTPS区别

1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。 HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。

2. HTTP 连接建⽴相对简单，TCP 三次握⼿之后便可进⾏HTTP的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏SSL/TLS的握⼿过程，才可进⼊加密报⽂传输。

3. HTTP 的端⼝号是 80， HTTPS 的端⼝号是 443。

4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 4-2：HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：

1. 窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。

2. 篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。

3. 冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。

HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：

1. 混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

在通信建立 前 采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密；在 通信过程中 全部使用对称加密的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

2. 摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

3. 将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。

## 4-3：HTTPS 是如何建⽴连接的？其间交互了什么？

1. 客户端向服务器索要并验证服务器的公钥。
2. 双⽅协商⽣产「会话秘钥」。
3. 双⽅采⽤「会话秘钥」进⾏加密通信。


## 4-4：SSL/TLS握⼿

1. ClientHello

⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这⼀步，客户端主要向服务器发送以下信息：

（1）客户端⽀持的 SSL/TLS 协议版本。

（2）客户端⽣产用于「会话秘钥」的随机数。

（3）客户端⽀持的密码套件列表。

2. SeverHello

服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：

（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。

（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

3. 客户端回应

客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：

（1）⼀个随机数（ pre-master key ）

（2）加密通信算法改变通知

（3）客户端握⼿结束通知

4. 服务器的最后回应

服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：

（1）加密通信算法改变通知。

（2）服务器握⼿结束通知。

## 4-5：HTTPS的加密过程

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；

2. HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；

3. 服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；

4. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效
   （递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；

5. 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；

6. 服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；

7. 服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；

8. 客户端使用随机Key对称解密密文，得到HTTP数据明文；

9.  后续HTTPS请求使用之前交换好的随机Key进行对称加解密。

## 4-6：加密

1. 对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密，算法有DES、 AES等；

优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。
缺点：
交易双方需要使用相同的密钥，也就无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。

每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，密钥管理成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。

2. ⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等。

优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。
缺点：计算量比较大，加密和解密速度相比对称加密慢很多。

## 4-7：HTTP拆包粘包

一个有报文的请求到服务器时，请求头里都会有content_length，这个指定了报文的大小，

报文如果很大的时候，会通过一部分一部分的发送请求，直到结束，

当这个过程中，出现多个请求，第一个请求会带有请求头信息，前面一个请求的如果发送的报文如果没有满时，

会把后面一个请求的内容填上，这个操作就叫粘包。

这样粘包后，它会通过content_length字段的大小，来做拆包。

# 5.计算机网络-HTTP-Cookie与Session

## 5-1：Cookie 和 Session 的区别

1. 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。

2. 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

3. 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

4. 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

## 5-2：Cookie作用

cookie是服务路发送到用户浏览器并保存在本地的小快数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器

## 5-3：Session用户登录状态过程

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中，
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis中，它在Redis中Key称为Session ID:
3. 服务器返回的响应报文的Se-Coeo首部字段包含了这个Session ID.客户端收到响应报文之后将该Cookie值存入浏览器中:
4. 客户编之后对间一 个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID.从Redis中取出用户信息，维续之前的业务操作。

## 5-4：token的验证流程

1. 客户端使用用户名跟密码请求登录

2. 服务端收到请求，去验证用户名与密码

3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端

4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里

5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token

6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

## 5-5：token和cookie实现的区别

1. Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

2. Token每一个请求都有签名还能防止监听以及重放攻击，而Session就必须依赖链路层来保障通讯安全了。

3. 如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。


## 5-6：HTTP是不保存状态的协议,如何保存⽤户状态?

通过Session机制解决，Session的主要作⽤就是通过服务端记录⽤户的状态。

如应用场景购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为HTTP协议是⽆状态的。服务端给特定的⽤户创建特定Session之后就可以标
识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个Session，过了时间限制，就会销毁这个Session）

## 5-7：如何保存session

在服务端保存Session的⽅法很多，最常⽤的就是内存和数据库(⽐如是使⽤内存数据库redis保存)。

## 5-8：如何实现 Session 跟踪呢？

⼤部分情况下，我们都是通过在Cookie 中附加⼀个 Session ID 来⽅式来跟踪。

## 5-9：Cookie 被禁⽤怎么办?

最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯。

## 5-10：URI和URL的区别是什么?

URI的作⽤像身份证号⼀样， URL的作⽤更像家庭住址⼀样。

# 6.计算机网络-综合应用-输入网址

## 6-1：输入网址过程

1. 输入地址,对URL进⾏解析，从⽽⽣成发送给Web服务器的请求信息。
 
2. 浏览器查找域名的IP地址,因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。　

1) 浏览器会首先查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使
   用hosts文件里面的ip地址。

2) 如果在本地的hosts文件没有能够找到对应的ip地址，浏览器会发出一个DNS请求到本地DNS服务器

3) 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓
   存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。

4) 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去
   继续查询，并给出域服务器的地址。这种过程是迭代的过程。

5) 本地DNS服务器继续向域服务器发出请求，比如说请求的对象是.com域服务器。.com域服务器收到请求之
   后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址

6) 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS
   服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

3. 浏览器向web服务器发送一个HTTP请求

通过DNS获取到IP后，就可以把HTTP的传输⼯作交给操作系统中的协议栈。

协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委
托⼯作，下⾯的部分收到委托的⼯作并执⾏。

应⽤程序也就是浏览器通过调⽤ Socket 库，来委托协议栈⼯作。

协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。

协议栈的下⼀半是⽤IP协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。

IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线
中的信号执⾏发送和接收操作。

拿到域名对应的IP地址之后，浏览器会以一个随机端口向服务器的WEB程序80端口发起TCP的连接请求。这个连接请求到达服务器端后，进入到网卡，然后是进入到内核的TCP/IP协议栈，还有可能要经过防火墙的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。


4. 服务器的永久重定向响应

服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问3w了。

5. 浏览器跟踪重定向地址，因为现在浏览器知道了 "http://www.google.com/"才是要访问的正确地址，所以它会发送另一个http请求

6. 服务器处理请求

http请求发送到了服务器，后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。

 
7. 服务器返回一个HTTP响应　

服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。

8. 浏览器显示 HTML,并请求获取嵌入在HTML的资源

## 6-2：为什么域名要分级设计

DNS 中的域名都是⽤句点来分隔的，代表了不同层次之间的界限。

域名的层级关系类似⼀个树状结构：
根 DNS 服务器
顶级域 DNS 服务器（com）
权威 DNS 服务器（server.com）

因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺
藤摸⽠找到位于下层的某台⽬标 DNS 服务器。

## 6-3：重定向原因

1. 网站调整（如改变网页目录结构）；

2. 网页被移到一个新地址；

3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。


# 7.各层协议

## 7-1：OSI与TCP/IP各层的结构与功能,都有哪些协议?

1. 应用层

为应用程序提供服务并且规定通信的规范和细节

常见的协议:
* HTTP(超文本传输协议)
* FTP(文件传输协议)
* TELNET(远程登录协议)
* SMTP(简单邮件传输协议)
* DNS(域名解析协议)

6. 表示层

主要负责数据格式的转换

5. 会话层

负责建立和断开通信连接

4.传输层

是唯一负责总体的数据传输和数据控制的一层。

* TCP: ~~面向连接 ,可靠性强, 传输效率低~~
* UDP: ~~无连接,可靠性弱,传输效率快~~

3.网络层

将数据传输到目标地址；主要负责寻找地址和路由选择，网络层还可以实现拥塞控制、网际互连等功能

* IP
* IPX
* RIP
* OSPF等

2.数据链路层

物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

* ARP
* RARP
* SDLC
* HDLC
* PPP
* STP
* 帧中继等

1. 物理层

负责0、1比特流(0/1序列)与电压的高低、光的闪灭之间的转换


## 7-2：⽹络层与数据链路层有什么关系呢？

1. IP 的作⽤是主机之间通信⽤的，负责在「没有直连」的两个⽹络之间进⾏通信传输
2. MAC 的作⽤则是实现「直连」的两个设备之间通信。

理解一下：

就比如说，你想从xx村到海南市，你不得做公交车、汽车、火车、轮船到海南

那么你这整个的一个路线图，就是一个网络层，行程开端就是xx村---->>>源IP，目的IP---->行程结束就是海南

那么我从xx村到xx镇相当于是在这个区间内移动路线，也就是数据链路层，其中，xx村好⽐源 MAC 地址，xx镇好⽐⽬的 MAC 地址。
（只要是在线路（网络层包含的都是））

这个xx村、海南不会发生变化，但是中间的位置会一直在变，也就是说

IP源、目的不会变， Mac源、目的会变化



# 8.TCP的三次握手

## 8-1：TCP三次握手流程

0. 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态

1. 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，

   同时把 SYN 标志位置为 1 ，表示 SYN 报文。

   接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。

2. 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），
   
   将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 
   
   接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。

3. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，
   
   首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，
   
   最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。

   服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。


## 8-2：TCP为什么要三次握⼿

1. 三次握⼿才可以 阻⽌ 重复 历史连接的初始化（主要原因）
   
  * 比如说，客户端连续发送多次SYN建⽴连接的报⽂，在⽹络拥堵情况下：

    * ⼀个「旧 SYN 报⽂」⽐「最新的 SYN报⽂」早到达了服务端；
    * 那么此时服务端就会回⼀个SYN+ACK报⽂给客户端；
    * 客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接，比如说序列号过期或超时，那么客户端就会发送 RST 报
      ⽂给服务端，表示中⽌这⼀次连接。

  * 如果是两次握⼿连接，就不能判断当前连接是否是历史连接

2. 三次握⼿才可以 同步 双⽅的 初始 序列号
   
   序列号是作为TCP可靠传输的⼀个关键因素，它的作⽤其实是：

   * 接收⽅可以去除重复的数据；
   * 接收⽅可以根据数据包的序列号按序接收；
   * 可以标识发送出去的数据包中，哪些是已经被对⽅收到的；

   - 四次握⼿其实也能够同步双⽅的初始化序号，但由于客户端传输ACK和SYN可以优化成⼀步，所以就成了「三次握⼿」
   - 两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。

3. 三次握⼿才可以避免资源浪费
  
  如果只有「两次握⼿」，当客户端的 SYN 请求连接在⽹络中阻塞，客户端没有接收到 ACK 报⽂，重复发送多次 SYN 报⽂，
  那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费。
  
## 8-3：TCP为什么SYN

![avatar](http://qd6kny79g.bkt.clouddn.com/02-TCP%E9%9D%A2%E7%BB%8F.jpg)

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

## 8-4：TCP除了SYN，为什么还要 ACK

双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问题，但是
接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证。

## 8-5：什么是 SYN 攻击？如何避免 SYN 攻击？

TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，

服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，

但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，

久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。



1. 避免 SYN 攻击方式一

通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。

当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值


2. 避免 SYN 攻击方式二

正常流程下,

当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；

接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；

服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；

应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。

但是

如果应用程序过慢时，就会导致「 Accept 队列」被占满。

如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。

当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；

计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，

服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。

最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。



## 8-5：如何对三次握手进行性能优化

1. 三次握⼿建⽴连接的⾸要⽬的是「同步序列号」。只有同步了序列号才有可靠传输，所以当客户端发起 SYN 包时，可以通
   过tcp_syn_retries 控制其重传的次数，⽐如内⽹通讯不畅时，就可以适当调低重试次数，尽快把错误暴露给应⽤程序

2. 当服务端SYN半连接队列溢出后，会导致后续连接被丢弃，可以通过backlog等参数来调整 SYN 半连接队列的⼤⼩。

3. TCP Fast Open 功能可以绕过三次握⼿，使得 HTTP 请求减少了 1 个 RTT 的时间，所以也是一种性能优化方案

## 8-6：如何绕过三次握手发送数据

TCP Fast Open 功能可以绕过三次握⼿，使得 HTTP 请求减少了1个RTT的时间， 

第⼀次发起 HTTP GET请求的时候，还是需要正常的三次握⼿流程。

之后发起 HTTP GET请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。

## 8-7：TCP Fast Open的过程

I、客户端⾸次建⽴连接时的过程：
1. 客户端发送SYN报⽂，该报⽂包含Fast Open选项，且该选项的Cookie为空；

2. ⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；

3. 客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。


II、如果客户端再次向服务器建⽴连接时的过程：

1. 客户端发送 SYN 报⽂，该报⽂包含「数据」以及此前记录的 Cookie；
2. ⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYNACK 报⽂中对 SYN 和
   「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的
   「数据」，且其随后发出的 SYN-ACK 报⽂将只确认 SYN 的对应序列号；
3. 如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」， 这就减少了握⼿带来的 1 个 RTT 的
   时间消耗；
4. 客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发送的「数据」没有被确
   认，则客户端将重新发送「数据」；

## 8-8：为什么需要 TCP 协议？

IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。

因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

## 8-9：什么是 TCP 连接？

这个我还真不太清楚，但是我看到过关于传输控制协议的定义

简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，

## 8-10：如何唯一确定一个 TCP 连接呢？

TCP 四元组可以唯一的确定一个连接，四元组包括：

源地址

源端口

目的地址

目的端口

源地址和目的地址的字段是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

## 8-11：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。

因此，客户端 IP 和 端口是可变的，其理论值计算公式应该是:

客户端的IP数X客户端的端口数

## 8-12：服务端最大并发 TCP 连接数远不能达到理论上限

首先主要是文件描述符限制，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；

另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统是有限的。

## 8-15：为什么客户端和服务端的初始序列号 ISN 是不相同的？

因为网络中的报文会延迟、会复制重发、也有可能丢失，

这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。

## 8-16：什么是Mss

除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

MTU：一个网络包的最大长度，以太网中一般为 1500 字节；

## 8-17：既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，

把数据分片成若干片，保证每一个分片都小于 MTU。

把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。

但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。

因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。

所以 IP 层进行分片传输，是非常没有效率的。

所以，为了达到最佳的传输效率， TCP 协议在建立连接的时候通常要协商双方的 MSS 值，

当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。



# 9.四次挥手

## 9-1：TCP四次挥手流程

客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。

服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。

客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。

等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。

客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态

服务器收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。

客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。

## 9-2：TCP为什么要四次挥手

四次挥手主要是从FIN过程进行分析：

1. 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

2. 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数
   据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次

## 9-3：如何对四次挥手进行优化

1. 主动发起FIN报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传的次数由 
   tcp_orphan_retries 参数决定。

当主动⽅收到 ACK 报⽂后，连接就进⼊ FIN_WAIT2 状态，根据关闭的⽅式不同，优化的⽅式也不同：

* 如果是 close 函数关闭的连接，那么它就是孤⼉连接。如果在系统设置的时间内 （tcp_fin_timeout） 没有收到对⽅的 
  FIN 报⽂，连接就直接关闭。同时，为了应对孤⼉连接占⽤太多的资源， tcp_max_orphans定义了最⼤孤⼉连接的数量，超
  过时连接就会直接释放。

* 反之是 shutdown 函数关闭的连接，则不受此参数限制；
  
2. 当主动⽅接收到 FIN 报⽂，并返回 ACK 后，主动⽅的连接进⼊ TIME_WAIT 状态。为了防⽌ TIME_WAIT 状态占⽤太多的
   资源， tcp_max_tw_buckets 定义了最⼤数量，超过时连接也会直接释放。

3. 被动��闭的连接，它在回复 ACK 后就进⼊了 CLOSE_WAIT 状态，等待进程调⽤ close函数关闭连接。因此，出现⼤量 
   CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。
   
4. 当被动⽅发送 FIN 报⽂后，连接就进⼊ LAST_ACK 状态，在未等到 ACK 时，会在tcp_orphan_retries 参数的控制下重
   发 FIN 报⽂。

## 9-4：为什么TIME_WAIT 等待的时间是 2MSL？

⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待2 
倍的时间。

## 9-5：为什么需要TIME_WAIT状态？（已经主动关闭连接了为啥还要保持资源一段时间呢？）

1. 防⽌具有相同端口的的「旧」数据包被收到；
   
   比如说服务端在关闭连接之前发送一个报⽂，但是被⽹络延迟了。这时有相同端⼝的TCP连接被复⽤后，被延迟的报文抵达
   了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。而使用TIME_WAIT这个时
   间，⾜以让两个⽅向上的数据包都被丢弃

2. 保证连接正确关闭

  比如客户端四次挥⼿的最后⼀个ACK报⽂如果在⽹络中被丢失了，此时如果客户端TIME-WAIT 过短或没有，则就直接进⼊
  了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK状态。当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 
  RST 报⽂给客户端，连接建⽴的过程就会被终⽌。如果有这个时间，就会正常关闭，即使没有收到ACK报文，我也有时间重发
  并关闭

## 9-6：TIME_WAIT 过多有什么危害？

1. 内存资源占⽤；

2. 对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；被占满就会导致⽆法创建新的连接。

## 9-7：如何优化 TIME_WAIT？

p146页

## 9-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？

TCP 有⼀个机制是保活机制。

定义在一个时间段内，如果没有任何连接相关的活动， TCP 保活机制会开始作⽤，每隔⼀个时间间隔，发送⼀个探测报⽂，该

探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息

通知给上层应⽤程序。

# 10.TCP传输数据优化方案

## 10-1：TCP传输数据优化

TCP 会保证每⼀个报⽂都能够抵达对⽅，报⽂发出去后，必须接收到对⽅返回的确认报⽂ ACK，如果迟迟未收到，就会超时重发该报⽂，直到收到对⽅的 ACK 为⽌。所以， TCP 报⽂发出去后，并不会⽴⻢从内存中删除，
因为重传时还需要⽤到它。这种⽅式的缺点是效率⽐较低的

可以采用并⾏批量发送报⽂，再批量确认报⽂即可，但是当接收⽅硬件不如发送⽅，或者系统繁忙、资源紧张时，是⽆法瞬间处理这么多报⽂的。于是，这些报⽂只能被丢掉，使得⽹络效率⾮常低。

为了解决这种现象发⽣， TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送的数据量

因为⽹络的传输能⼒是有限的，当发送⽅依据发送窗⼝，发送超过⽹络处理能⼒的报⽂时，路由器会直接丢弃这些报⽂。影响了传输速度，发送缓冲区的⼤⼩最好是往带宽时延积靠近


## 10-2： TCP 应该如何 Socket 编程？

服务端和客户端初始化 socket，得到文件描述符；

服务端调用 bind，将绑定在 IP 地址和端口;

服务端调用 listen，进行监听；

服务端调用 accept，等待客户端连接；

客户端调用 connect，向服务器端的地址和端口发起连接请求；

服务端 accept 返回用于传输的 socket 的文件描述符；

客户端调用 write 写入数据；服务端调用 read 读取数据；

客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。

# 11.TCP与UDP

## 11-1：TCP与UDP区别

![avatar](http://qd6kny79g.bkt.clouddn.com/03-TCP.jpg)

1. 连接方面来看

TCP 是面向连接的传输层协议，传输数据前先要建立连接。

UDP 是不需要连接，即刻传输数据。

2. 服务对象

TCP 是一对一的两点服务，即一条连接只有两个端点。

UDP 支持一对一、一对多、多对多的交互通信

3. 可靠性

TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。

UDP 是尽最大努力交付，不保证可靠交付数据。

4. 拥塞控制、流量控制

TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。

UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

5. 首部开销

TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。

UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

## 11-2：TCP 和 UDP 应用场景

由于TCP是面向连接，能保证数据的可靠性交付，因此经常用于：

  * FTP 文件传输

  * HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

  * 包总量较少的通信，如 DNS 、SNMP 等

  * 视频、音频等多媒体通信

  * 广播通信


## 11-3：TCP的作用

TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包

因为IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），

就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。


## 11-4：TCP 数据包的大小

TCP 负载实际为1400字节左右。

以太网数据包（packet）的大小是固定的，1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。

IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。

TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，

因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。

由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。

   * 注：可不可以压缩加快速度---》HTTP/2进行了优化


## 11-5：TCP 数据包的编号（SEQ）

一个包1400字节，那么一次性发送大量数据，就必须分成多个包

发送的时候，TCP 协议为每个包编号，以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。

第一个包的编号是一个随机数。假设为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。

每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。

## 11-6：TCP 数据包的组装

收到TCP数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。

对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。

应用程序需要的数据放在TCP数据包里面，有自己的格式（比如HTTP协议）。

TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。
操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。

## 11-7：什么是TCP粘包？怎么解决这个问题

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，

从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，

例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，

在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束

所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

## 11-8：粘包的原因

1. 发送方原因

TCP默认使用Nagle算法（主要作用：会将数据量小的，且时间间隔较短的数据一次性发给对方），

而Nagle算法主要做两件事：

只有上一个分组得到确认，才会发送下一个分组

收集多个小分组，在一个确认到来时一起发送

Nagle算法造成了发送方可能会出现粘包问题

2. 接收方原因
   
TCP接收到数据包时，并不会马上交到应用层进行处理，

或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，

然后应用程序主动从缓存读取收到的分组。

这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，

多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

## 11-9：粘包解决方案

（1）发送方

对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。

（2）接收方

接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。

（2）应用层

解决办法：循环处理，应用程序从接收缓存中读取分组时，

读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，之后开始处理每条数据的长度

因为每条数据有固定的格式（开始符，结束符），但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。

发送每条数据时，将数据的长度一并发送，

例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

## 11-10：UDP会不会产生粘包问题呢？

UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息

举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。

# 12：协议如何保证可靠传输方式

## 12-1：TCP如何保证稳定传输

1. 确认应答+序列号：TCP给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。

2. 校验和：TCP 将保持它⾸部和数据的检验和。⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报⽂段和不确认收到此
   报⽂段。

3. 流量控制：TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间， TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能
   提示发送⽅降低发送的速率，防⽌包丢失。 TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量控制）

4. 拥塞控制：当⽹络拥塞时，减少数据的发送。

5. ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅确认。在收到确认后再发下⼀个分组。

6. 超时重传： 当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段。

## 12-2：UDP如何做可靠传输

1、超时重传

2、有序接受

3、应答确认

4、滑动窗口流量控制

# 13.重传机制

## 13-1：常见的重传机制

      1. 超时重传
      2. 快速重传
      3. SACK
      4. D-SACK

## 13-2：超时重传

在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。

## 13-3：什么时候会发生超时重传

- 数据包丢失
- 确认应答丢失

## 13-4：超时重传存在的问题

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。这样超时周期可能相对较长

## 13-5：快速重传

它不以时间为驱动，而是以数据驱动重传

比如说，发送方发出了 1，2，3，4，5 份数据：

第一份 Seq1 先送到了，于是就 Ack 回 2；
结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

所以说，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段

## 13-6：快速重传的问题

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。

## 13-7：SACK方法

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知
道了这些信息，就可以只重传丢失的数据。

比如说发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有某段数据丢失，则重发时，就只选择了这个 TCP 段进行重
复。

## 13-8：D-SACK

主要是使用了 SACK 来告诉「发送方」有哪些数据被重复接收了

例子看p157

## 13-9：D-SACK好处

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

# 14.滑动窗口与流量控制

## 14-1：引入窗口概念的原因

TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个，效率比较低，如果数据包的往返时间越长，通信的效率就越低

## 14-2：什么是窗口

在往返时间较长的情况下，它也不会降低网络通信的效率，这个就是窗口

窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据
就可以从缓存区清除。

比如说ACK 100 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 200 确认应答，就意味着 200 之前的所有数据「接收方」都收到了。

## 14-3：窗口大小由哪一方决定？

通常窗口的大小是由接收方的窗口大小Window来决定的

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

## 14-4：发送方的窗口

一共分为了四部分

1. 是已发送并收到 ACK确认的数据
2. 是已发送但未收到 ACK确认的数据
3. 是未发送但总大小在接收方处理范围内（接收方还有空间）
4. 是未发送但总大小超过接收方处理范围（接收方没有空间）

p160-163未整理

## 14-5：流量控制

如果一直发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以「发
送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

## 14-6：流量控制的过程

p165

## 14-7：

## 14-8：


## 14-9：TCP 是如何解决窗口关闭时，潜在的死锁现象呢？

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；

如果接收窗口不是 0，那么死锁的局面就可以被打破了。

# 15.拥塞控制

## 15-1：为什么要有拥塞控制呀，不是有流量控制了吗？

流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更
大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大

为了避免「发送方」的数据填满整个网络，有了拥塞控制


## 15-2：什么是拥塞控制

在某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。拥塞控制所要做的都有⼀个前提，就是⽹络能够承受现有的⽹络负荷。

## 15-3：什么是拥塞窗口？和发送窗口有什么关系呢？

拥塞窗口是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。

发送窗口和接收窗口是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是是拥塞窗口和接收窗口中的最小值。

拥塞窗口 cwnd 变化的规则：

只要网络中没有出现拥塞， cwnd 就会增大；

但网络中出现了拥塞， cwnd 就减少；

## 15-4：那么怎么知道当前网络是否出现了拥塞呢？

只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。

## 15-5：拥塞控制算法

TCP的拥塞控制采⽤了四种算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

1. 慢开始： 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1
2. 拥塞避免： 每当收到一个 ACK 时，cwnd 增加 1/cwnd.
3. 拥塞发生算法：
4. 快重传与快恢复： 它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了， TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复
                   制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重
                   复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 　当有单
                   独的数据包丢失时，快速重传和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效地⼯作。

## 15-6：那慢启动涨到什么时候是个头呢？

有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。

- 当 cwnd < ssthresh 时，使用慢启动算法。
- 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。

## 15-7：重传机制何时结束

当触发了重传机制，也就进入了「拥塞发生算法」。

# 16.ARQ协议

## 16-1：什么是ARQ协议

ARQ协议是⾃动重传请求，他是OSI模型中数据链路层和传输层的错误纠正协议之⼀。它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。 ARQ包括停⽌等待ARQ协议和连续ARQ协议。

## 16-2：什么是停⽌等待ARQ协议
停⽌等待协议是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅确认（回复ACK）。如果过了⼀段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下⼀个分组；在停⽌等待协议中，若接收⽅收到重复分组，就丢弃该分组，但同时还要发送确认；

1. 优点： 简单
2. 缺点： 信道利⽤率低，等待时间⻓

## 16-3: 什么是连续ARQ协议

连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗⼝，凡位于发送窗⼝内的分组可以连续发送出去，⽽不需要等待对⽅确认。接收⽅⼀般采⽤累计确认，对按序到达的最后⼀个分组发送确认，表明到这个分组为⽌的所有分组都已经正确收到了。

1. 优点： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传。
2. 缺点： 不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息。 
   * ⽐如：发送⽅发送了5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，⽽只好把后三个全部重传⼀次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的N 个消息。

# ---------------------------------------------------------------------------------------------------------------

# 1.mysql理论

## 1-1：为什么要使用数据库


## 1-2: 什么是SQL？


## 1-3：什么是MySQL?


## 1-4：数据库三大范式是什么

第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主
键.

## 1-5：mysql有关权限的表都有哪几个

user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
db权限表：记录各个帐号在各个数据库上的操作权限。
table_priv权限表：记录数据表级的操作权限。
columns_priv权限表：记录数据列级的操作权限。
host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。


## 1-6：什么是binlog

binlog其实就是记录了数据库表结构和表数据变更

我们的数据是保存在数据库里边的嘛，

现在我们对某个商品的某个字段的内容改了（数据库变更），

而用户检索的出来数据是走搜索引擎的。

为了让用户能搜到最新的数据，我们需要把引擎的数据也改掉。

数据库的变更，搜索引擎的数据也需要变更。


## 1-6：binlog长什么样？

binlog：存储着每条变更的SQL语句

## 1-7：binlog一般用来做什么

主要有两个作用：复制和恢复数据

MySQL一般都是一主多从结构的，从服务器需要与主服务器的数据保持一致，这就是通过binlog来实现的

数据库的数据消失了，我们可以通过binlog来对数据进行恢复。

因为binlog他记录了数据库的变更，所以用binlog进行赋值和恢复数据


## 1-8：redo log

Mysql的基本存储结构是页(记录都存在页里边)，所以MySQL是先把这条记录所在的页找到，然后把该页加载到内存中，将对应记录进行修改。

      当我们修改的时候，写完内存了，但数据还没真正写到磁盘的时候。
      
      此时我们的数据库挂了，我们可以根据redo log来对数据进行恢复。
      
      因为redo log是顺序IO，所以写入的速度很快，并且redo log记载的是物理变化（xxxx页做了xxx修改），文件的体积很小，恢复速度很快。


## 1-9：bin log和redo log

1. 存储内容来说
   
binlog记载的是update/delete/insert这样的SQL语句，而redo log记载的是物理修改的内容（xxxx页修改了xxx）。

2. 功能

redo log的作用是为持久化而生的。写完内存，如果数据库挂了，那我们可以通过redo log来恢复内存还没来得及刷到磁盘的数据，

将redo log加载到内存里边，那内存就能恢复到挂掉之前的数据了。

binlog的作用是复制和恢复而生的。

主从服务器需要保持数据的一致性，通过binlog来同步数据。

如果整个数据库的数据都被删除了，binlog存储着所有的数据变更情况，那么可以通过binlog来对数据进行恢复。

3. 第三方面来说，写入内容来说
   
redo log事务开始的时候，就开始记录每次的变更信息，而binlog是在事务提交的时候才记录。

## 1-10：我写其中的某一个log，失败了，那会怎么办？

如果说是先写redo log，再写binlog，

如果写redo log失败了，那我们就认为这次事务有问题，回滚，不再写binlog。

如果写redo log成功了，写binlog，写binlog写一半了，但失败了

我们还是会对这次的事务回滚，将无效的binlog给删除（因为binlog会影响从库的数据，所以需要做删除操作）

如果写redo log和binlog都成功了，那这次算是事务才会真正成功。

## 1-11：MySQL如何保证redo log和binlog的数据是一致的

MySQL通过两阶段提交来保证redo log和binlog的数据是一致的。

阶段1：InnoDBredo log 写盘，InnoDB 事务进入 prepare 状态

阶段2：binlog 写盘，InooDB 事务进入 commit 状态

每个事务binlog的末尾，会记录一个 XID event，标志着事务是否提交成功，也就是说，恢复过程中，binlog 最后一个 XID event 之后的内容都应该被 purge。


## 1-12：如果整个数据库的数据都被删除了，那我可以用redo log的记录来恢复吗？

不能

因为功能的不同，redo log 存储的是物理数据的变更，

如果我们内存的数据已经刷到了磁盘了，那redo log的数据就无效了。

所以redo log不会存储着历史所有数据的变更，文件的内容会被覆盖的。

## 1-13：MySQL的binlog有有几种录入格式？分别有什么区别？

有三种格式,statement,row和mixed.

statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.

row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.

mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

## 1-14：mysql的数据类型

整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

浮点数类型：FLOAT、DOUBLE、DECIMAL

字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

日期类型：Date、DateTime、TimeStamp、Time、Year

## 1-15：SQL的生命周期

1. 建立服务器与数据库连接
2. 数据库拿到SQL
3. 解析执行
4. 读取数据到内存，进行业务逻辑处理
5. 发给客户端
6. 关闭连接，释放资源

## 1-16：字段为什么要求定义为not null?

null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.


## 1-17：数据库热备份与冷备份




# 2.sql的使用

## 2-1：SQL语句主要分为哪几类

DDL-------数据定义语言
DQL-------数据查询语言
DML-------数据操纵语言
DTL-------事务控制语言
DCL-------数据控制语言

## 2-2：超键、候选键、主键、外键分别是什么？

超键：一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）

外键：在一个表中存在的另一个表的主键称此表的外键。

## 2-3：为什么用自增列作为主键

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

## 2-4：truncate、 delete区别

1、TRUNCATE在各种表上无论是大的还是小的都非常快。如果有ROLLBACK命令DELETE将被撤销，而TRUNCATE则不会被撤销。

2、truncate不能进行回滚操作。

3、truncate不触发任何delete触发器。

5、当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。

6、不能truncate一个带有外键的表，如果要删除首先要取消外键，然后再删除。
    DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的的删除操作作为事务记录在日志中保存以便进行进行回滚操作。

## 2-5：什么是临时表，临时表什么时候删除?

临时表可以手动删除：

临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。

## 2-6：非关系型数据库和关系型数据库区别，优势比较?

非关系型数据库的优势：

 - 性能：NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。

 - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：

 - 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
 
 - 事务支持：使得对于安全性能很高的数据访问要求得以实现。

## 2-7：什么是 内连接、外连接、交叉连接、笛卡尔积等?

1. 内连接: 只连接匹配的行

2. 左外连接: 包含左边表的全部行，以及右边表中全部匹配的行

3. 右外连接: 包含右边表的全部行，以及左边表中全部匹配的行

4. 全外连接: 包含左、右两个表的全部行。

5. 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

## 2-8：varchar与char的区别

char长度固定，carchar长度可以变化

比如说字符串abc
char（10）就是占用10个字节，
varchar（10）只占用3个字节，10只是最大值

## 2-9：count(*)、count(1)、count(column)的区别

count(*)对行的数目进行计算,包含NULL，count(1)这个用法和count(*)的结果是一样的

count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

## 2-10：SQL 约束有哪几种？

NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
CHECK: 用于控制字段的值范围。

## 2-11：六种关联查询

1. 交叉连接(CROSS JOIN)
2. 内连接(INNER JOIN)
3. 外连接(LEFT JOIN/RIGHT JOIN)
4. 交叉连接
5. 联合查询(UNION 与 UNION ALL)
6. 全连接(FULL JOIN)
   
## 2-12：什么是子查询

在select嵌套select

## 2-13：子查询的三种情况

1. 子查询结果只要是单行单列， 肯定在 WHERE 后面作为条件

2. 子查询结果是多行单列，结果类似于一个数组，父查询使用 in 运算符

3. 子查询结果只要是多列，肯定在 From 后面作为表


## 2-14：mysql中 in 和 exists 区别

1. exists()适合B表比A表数据大的情况

2. 当A表数据与B表数据一样大时,in与exists效率差不多,可任选一个使用

## 2-15：varchar(50)中50的涵义

varchar(50)中50的涵义最多存放50个字符

## 2-16：int(20)中20的涵义

int(M)只是用来显示数据的宽度，比如说int（20），mysql会自动补0

## 2-17：FLOAT和DOUBLE的区别是什么？

1. 在内存中占有的字节数不同

　　　　单精度浮点数在机内存占4个字节

　　　　双精度浮点数在机内存占8个字节

2. 有效数字位数不同

　　　　单精度浮点数有效数字8位

　　　　双精度浮点数有效数字16位

3. 数值取值范围

4. 在程序中处理速度不同

　　　　一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快

## 2-18：UNION与UNION ALL的区别？

union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

union All：对两个结果集进行并集操作，包括重复行，不进行排序；

## 2-19：为什么要使用视图？什么是视图？那些特点？

视图是虚拟的表

1. 重用SQL语句；

2. 简化复杂的SQL操作（可以方便的重用它而不必知道它的基本查询细节）；

3. 使用表的组成部分而不是整个表；

4. 保护数据（可以给用户授予表的部分访问权限而不是整个表的访问权限）；

5. 更改数据格式和表示（视图可返回与底层表的表示和格式不同的数据）。

## 2-20：什么是存储过程？

预先用SQL语句写好并用一个指定的名称存储起来，只需调用execute,即可自动完成命令。

## 2-21：存储过程有哪些优缺点？

1. 一般SQL语句每执行一次就编译一次,使用存储过程创建进行编译，可提高数据库执行速度。

2. 当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时），可将此复杂操作用存储过程封装起来。

3. 存储过程可以重复使用,可减少数据库开发人员的工作量

4. 安全性高,可设定只有某此用户才具有对指定存储过程的使用权

## 2-22：什么是触发器？

数据库触发器是在数据库中发生特定操作时运行的特殊存储过程

## 2-23：触发器的使用场景有哪些？

1. 复杂的审计

可以使用触发器来跟踪对表所做的更改。

比如说认为这是涉及敏感操作的信息，进行了更改。

2. 执行业务规则

每次添加或修改客户记录时检查客户状态。

## 2-24：MySQL中都有哪些触发器？

不知道



# 3.索引

## 3-1：索引是什么

索引（Index）是帮助 MySQL 高效获取数据的数据结构，是一种排好序的数据结构

## 3-2：为什么要用索引（优点）

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

## 3-3：索引这么多优点，为什么不对表中的每一个列创建一个索引呢？（缺点）

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会
   更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 3-4：索引的主要原理，常用算法

修改

## 3-5：创建索引原则（使用场景）：

1. 对于查询频率高的字段创建索引；
2. 对排序、分组、联合查询频率高的字段创建索引； 
3. 索引的数目不宜太多

   * 因为每创建一个索引都会占用相应的物理控件，过多的索引会导致insert、update、delete语句的执行效率降低；

4. 若在实际中，需要将多个列设置索引时，可以采用多列索引

5. 选择唯一性索引

   * 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯
     一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

6. 尽量使用数据量少的索引

   * 如果索引的值很长，那么查询的速度会受到影响。

7. 尽量使用前缀来索引

   * 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字
     段的前面的若干个字符，这样可以提高检索速度。

8. 删除不再使用或者很少使用的索引

## 3-7：创建索引的注意事项

1. 限制表上的索引数目。
 
2. 避免在取值朝一个方向增长的字段（例如：日期类型的字段）上，建立索引；对复合索引，避免将这种类型的字段放置在最前面。由于字段的取值总是朝一个方向增长，新记录总是存放在索引的最后一个叶页中，从而不断地引起该叶页的访问竞争、新叶页的分配、中间分支页的拆分。此外，如果所建索引是聚集索引，表中数据按照索引的排列顺序存放，所有的插入操作都集中在最后一个数据页上进行，从而引起插入“热点”。
 
3. 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用。因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。
 
4. 删除不再使用，或者很少被使用的索引。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再被需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。


## 3-8：为什么索引能够提高查询速度

修改

## 3-9：创建索引的三种方式


## 3-10：最左前缀原则

以最左边的为起点任何连续的索引都能匹配上。

（1）如果第一个字段是范围查询需要单独建一个索引；

（2）在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边；

当创建(a,b,c)复合索引时，想要索引生效的话，只能使用 a和ab、ac和abc三种组合！

## 3-11：最左匹配原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

# 4.索引的分类

## 4-1：索引的分类

1. 主键索引
2. 二级索引
   * 唯一索引
   * 普通索引
   * 前缀索引
   * 全文索引

## 4-2：各种索引定义

1. 主键索引：数据表的主键列使用的就是主键索引。

在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。

2. 二级索引(辅助索引)

因为二级索引的叶子节点存储的数据是主键。通过二级索引，可以定位主键的位置。

3. 唯一索引(Unique Key) ：目的是为了该属性列的数据的唯一性，而不是为了查询效率。

4. 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。

5. 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更
   小， 因为只取前几个字符。

6. 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息

7. 覆盖索引：覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。
             而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。


# 5.索引的结构

## 5-1：mysql索引的结构

1. B树索引与B+树索引

2. 聚簇索引与非聚簇索引

3. Hash索引

4. 全文索引

5. 空间索引

## 5-2：B+树比B树的优势

1. B+树空间利用率更高，可减少I/O次数

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘1O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。也就是说: B+树中每
个非叶子节点没有指向某个关健字具体信息的指针，所以好个节点可以存放更多的关键字数量，减少了I/0操作。

2. 增删文件(节点)时，效率更高
因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。

3. B+树的查询效率更加稳定
因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相
当。


## 5-3：B+树与红黑树比较

1. 更少的查找次数

复杂度和树高h相关，红黑树的树高h很明显比B+Tee大非常多，查找的次数也就更多。

2. 利用磁盘预读特性

为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻
道，并且只需要很短的旋转时间，速度会非常快。

## 5-4：B+树与hash索引比较

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值。当然了，这个前提是，键值都是唯
   一的。 如果键值不是唯的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据:

2. 如果是范围查询检索，原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索:


## 5-5：聚簇索引与非聚簇索引概念

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。

非聚集索引即索引结构和数据分开存放的索引。

## 5-6：聚簇索引的优缺点

一、优点

由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。

二、缺点
1. 对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。
2. 由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。
3. 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。

## 5-7：非聚簇索引的优缺点

一、优点

更新代价比聚集索引要小，非聚集索引的叶子节点是不存放数据的

二、缺点

非聚集索引也依赖于有序的数据
可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 
当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。


# 6.数据库优化

## 6-1：为什么要优化

1. 避免网站页面出现访问错误

   由于慢查询造成页面无法加载
   由于阻塞造成数据无法提交
   增加数据库的稳定性

2. 很多数据库问题都是由于低效的查询引起的

## 6-2：索引优化

1、建立聚集索引
首先聚合索引是提升查询速度的最有效的手段。基于聚合索引的性质，我们可以了解到，数
据库的物理存储顺序是按照聚合索引顺序排列的，而通过聚合索引的B+树，我们可以迅速
的查找到任何一行的全部信息。
2、常查询数据建立索引或者组合索引
3、最左前缀原则
建立组合索引优化查询语句时，一定要考虑到最左前缀原则，否则你的索引建立的可以说毫无意义
4、较长的数据列建立前缀索引;
5、不要建立无意义的索引
对于查询次数很少的语句中的字段的索引、备注描述和大字段的索引等


## 6-3：查询优化

1、使用 Explain进行分析
Explain用来分析SELECT 查询语句，开发人员可以通过分析Explain结果者傥化参驾调
句。
比较重要的字段有:
select_type:查询类型，有简单查询、联合查询、子查询等
key:使用的索引
rows:扫描的行数
2、优化数据访问
（1）减少请求的数据量
只返回必要的列:最好不要使用SELECT*语句。
只返回必要的行:使用 LIMIT 语句来限制返回的数据。
缓存重复查询的数据:使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被
重复查询时，缓存带来的查询性能提升将会是非常明显的。
（2）减少服务器端扫描的行数
最有效的方式是使用索引来覆盖查询。
3、重构查询方式
（1）切分大查询
一个大查询如果一次性执行的话，可能一次锁住很多数据、耗尽系统资源、阻塞很多小的但重要的查询。
DELETE FROM messages WHERE create <DATE sLIB(NOWoINTERVAL 3 MONTH);
rows_affected= O
do {
rows_affected= do_query(
"DELETEFROM messages WHEREcreate<DATE SUB(NOWO.INTERVAL 3 MONTH)
LIMIT10000")
}while rows_affected>0
(2）分解大连接查询
将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样
做的好处有:
让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。
而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记
录的查询。

## 6-4：慢查询优化

1. 索引没起作用的情况

       1. 使用LIKE关键字的查询语句

               在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置索引才会起作用。

       2. 使用多列索引的查询语句

               MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。

2. 优化数据库结构

              合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

        1. 将字段很多的表分解成多个表 

                对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

        2. 增加中间表

                对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

3. 分解关联查询

         将一个大的查询分解为多个小查询是很有必要的。

         很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效，  

4. 优化LIMIT分页


# 7.mysql引擎

## 7-1：MySQL存储引擎MyISAM与InnoDB区别

## 7-2：能说下myisam 和 innodb的区别吗？

myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而
且myisam不支持外键，并且索引和数据是分开存储的。

innodb是基于聚簇索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。

## 7-3：InnoDB引擎的4大特性

1.插入缓冲（insert buffer)
提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效

只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。

2.二次写(double write)

Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入

在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write
doublewrite组成：
内存中的doublewrite buffer,大小2M。
物理磁盘上共享表空间中连续的128个页，即2个区（extend），大小同样为2M。
对缓冲池的脏页进行刷新时，不是直接写磁盘，而是会通过memcpy()函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite 再分两次，每次1M顺序地写入共享表空间的物理磁盘上，在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer 中的页写入各个 表空间文件中，此时的写入则是离散的。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，innodb可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。



3.自适应哈希索引(ahi)

Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数
关闭

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。
哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1),即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般3-4层，故需要3-4次的查询。

innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
AHI有一个要求，就是对这个页的连续访问模式必须是一样的。
例如对于（a,b）访问模式情况：
where a = xxx
where a = xxx and b = xxx

特点
　　1、无序，没有树高
　　2、降低对二级索引树的频繁访问资源，索引树高<=4，访问索引：访问树、根节点、叶子节点
　　3、自适应
3、缺陷
　　1、hash自适应索引会占用innodb buffer pool；
　　2、自适应hash索引只适合搜索等值的查询，如select * from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；
　　3、极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读。

 

4.预读(read ahead)
InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）
为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。

# 8.事务

## 8-1：什么是事务

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

## 8-2：数据库事务特性

1. 原⼦性（Atomicity）：事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要
   么完全不起作⽤；
2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据
   库是独⽴的；
4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故
   障也不应该对其有任何影响。

## 8-3：ACID靠什么保证的

A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C一致性一般由代码层面来保证

I隔离性由MVCC来保证

D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

## 8-4：什么是undo log

undo log主要有两个作用：回滚和多版本控制(MVCC)

在数据修改的时候，不仅记录了redo log，还记录undo log，如果因为某些原因导致事务失败或回滚了，可以用undo log进行回滚

undo log主要存储的也是逻辑日志，比如我们要insert一条数据了，那undo log会记录的一条对应的delete日志。我们要update一条记录时，它会记录一条对应相反的update记录。

因为回滚，跟需要修改的操作相反就好，这样就能达到回滚的目的。因为支持回滚操作，所以我们就能保证：“一个事务包含多个操作，这些操作要么全部执行，要么全都不执行”。【原子性】

因为undo log存储着修改之前的数据，相当于一个前版本，MVCC实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行了。

## 8-5：四大隔离级别

1. 读取未提交： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。
2. 读取已提交： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发
               ⽣。
3. 可重复读：   对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏
               读和不可重复读，但幻读仍有可能发⽣。
4. 可串⾏化：   最⾼的隔离级别， 该级别可以防⽌脏读、不可重复读以及幻读。

## 8-6：隔离级别的原理

1. READ_UNCOMMITED 的原理:

  - 事务对当前被读取的数据不加锁；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级共享锁，直到事务结束才释放。

2. READ_COMMITED 的原理:

  - 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

3. REPEATABLE READ 的原理:

  - 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
  - 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

4. SERIALIZABLE 的原理:

  - 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
  - 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

## 8-7：MySQL 中RC和RR隔离级别的区别

1. RR支持gap lock，而RC则没有gap lock（间隙锁）。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般
   要好于RR；

2. RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉；但是RR隔离级别，即使不符合where条件的记录，也不会是否行锁和gap lock；所以
   从锁方面来看，RC的并发应该要好于RR；

3. RC 隔离级别不支持 statement 格式的bin log，因为该格式的复制，会导致主从数据的不一致；只能使用 mixed 或者 row 格式的bin log

4. RC隔离级别时，事务中的每一条select语句会读取到他自己执行时已经提交了的记录，而RR隔离级别时，事务中的一致性读的是以第一条select语句的运行时，作为本事
   务的一致性读的建立时间点的。只能读取该时间点之前已经提交的数据

5. RC隔离级别下的update语句，使用的是半一致性读(semi consistent)；而RR隔离级别的update语句使用的是当前读；当前读会发生锁的阻塞

## 8-8：隔离级别用来做什么

隔离级别用于决定如何控制并发用户读写数据的操作


## 8-9：并发事务带来什么问题

1. 脏读: A读取B没有提交的事务
2. 不可重复读: A读取B已经提交的更改或者删除的数据
3. 幻读: A读取了B已经提交了的新增数据

## 8-10：数据库崩溃时事务的恢复机制

为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方，这个存储数据备份的地方称为UndoLog。

然后进行数据的修改。

如果出现了错误或者用户执行了回滚，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

## 8-11：Undo Log缺陷如何解决？

每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。

因此引入了另外一种机制来实现持久化，即Redo Log。

Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经
持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

# 9.锁

## 9-1：隔离级别与锁的关系

SQL使用锁来实现事务的隔离。事务获取锁这种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。

比如说

读未提交，可以通过写操作加“持续-X锁”实现。

读已提交，可以通过写操作加“持续-X”锁，读操作加“临时-S锁”实现。

可重复读，可以通过写操作加“持续-X”锁，读操作加“持续-S锁”实现。

## 9-2：封锁粒度



## 9-3：锁的类型

可以分为悲观锁与乐观锁两种

悲观锁按使用性质划分

1. 共享锁（Share Lock）
    
    S锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。

     在SQL Server中，默认情况下，数据被读取后，立即释放共享锁。
     
     例如，执行查询语句“SELECT * FROM my_table”时，首先锁定第一页，读取之后，释放对第一页的锁定，
     
     然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。


2. 排他锁（Exclusive Lock）
   
   X锁，也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，
   
   其他事务就不能再给它加任何锁了。（某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面打开了。）

产生排他锁的SQL语句如下：select * from ad_plan for update;

3. 更新锁

   U锁，在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。

因为当使用共享锁时，修改数据的操作分为两步：

1. 首先获得一个共享锁，读取数据，

2. 然后将共享锁升级为排他锁，再执行修改操作。

悲观锁按作用范围划分为：行锁、表锁。

表级锁定，行级锁定和页级锁定。

1.表级锁（表级锁一次会将整个表锁定，所可以很好的避免死锁问题）

（1）锁定粒度大，锁冲突概率高、并发度低；

（2）好处是不会出现死锁、开销小、获取锁和释放锁的速度很快；

（3）使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎，适用于以查询为主，少量更新的应用。

2.行级锁

（1）好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；

（2）缺点是开销大、加锁慢，行级锁容易发生死锁；

1.页面锁

（1）介于行级锁和表级锁之间；

（2）会发生死锁；

（3）BDB采用页面锁(page-level locking)或表级锁，默认为页面锁。 

## 9-4：三级封锁协议

一级封锁协议:事务T中如果对数据R有写操作，
            
            必须在这个事务中对R的第一次读操作前对它加锁，
            
            直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束ROLLBACK).

二级封约协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。

三级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。


## 9-5：排它锁

a.当试图修改数据时，事务只能为所依赖的数据资源请求排他锁。

b.一旦某个事务得到了排他锁，则这个事务将一直持有排他锁直到事务完成。

c.排他锁和其他任何类型的锁在多事务中不能在同一阶段作用于同一个资源。

如：当前事务获得了某个资源的排他锁，则其他事务不能获得该资源的任何其他类型的锁。其他事务获得了某个资源的任何其他类型的锁，则当前事务不能获得该资源的排他锁。

## 9-6：排他锁和共享锁的兼容性

（1）如果数据正在由一个事务进行修改，则其他事务既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。

（2）如果数据正在由一个事务读取，则其他事务不能修改该数据（至少默认不能）。

## 9-7：InnoDB存储引擎的锁的算法

Record lock：单个⾏记录上的锁
Gap lock：间隙锁，锁定⼀个范围，不包括记录本身
Next-key lock： record+gap 锁定⼀个范围，包含记录本身

## 9-8：MyISAM和InnoDB存储引擎使用的锁

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

## 9-9：表级锁和行级锁对比：

表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

## 9-10：Innodb如何加锁


## 9-11：Innodb解决死锁


# 10.阻塞

## 10-1：什么是阻塞

当多个事务都需要对某一资源进行锁定时，默认情况下会发生阻塞。被阻塞的请求会一直等待，直到原来的事务释放相关的锁。锁定超时期限可以限制，这样就可以限制被
阻塞的请求在超时之前要等待的时间。

比如说

有两个事务

事务A请求资源S1，事务不对资源S1进行操作

事务A用锁A锁定资源S1，事务B请求对资源S1进行不兼容的锁定（锁B）,锁B的请求被阻塞，事务B将进入等待状态

事务A正在释放锁A，事务B等待锁A释放，

事务A的锁A已释放，事务B用锁B锁定资源S1

## 10-2：阻塞的优化

# 11.什么是慢查询

它用来记录在MySQL中响应时间超过阀值的语句日志记录


# 12.主从复制

## 12-1：什么是主从复制

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。

## 12-2：主从复制的作用（好处，或者说为什么要做主从）：

1、做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。

2、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

3、读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用
    slave，那么报表sql将不会造成前台锁，保证了前台速度。

## 12-3：主从复制的原理（重中之重，面试必问）

步骤一：主库db的更新事件(update、insert、delete)被写到binlog

步骤二：从库发起连接，连接到主库

步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库

步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log

具体需要三个线程来操作：

binlog输出线程。每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。

在从库里，当复制开始的时候，从库就会创建两个线程进行处理：

从库I/O线程。当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。

从库的SQL线程。从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。

## 12-4：主从复制的几种方式

1. 同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。不会使用，比如，在WEB前端页面上，用户增加了条记录，需
   要等待很长时间。

2. 异步复制:如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设
   置。

3. 半同步复制:master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。




# 13.JDBC

## 13-1：JDBC数据库连接步骤

1.注册数据库驱动
2.建立数据库连接
3.创建一个Statement
4.执行SQL语句
5.处理结果集
6.关闭数据库连接

## 13-2：JDBC中的Statement 和PreparedStatement的区别？

PreparedStatement是预编译的SQL语句，效率高于Statement。
PreparedStatement支持?操作符，相对于Statement更加灵活。
PreparedStatement可以防止SQL注入，安全性高于Statement。
CallableStatement适用于执行存储过程。

## 13-3：JDBC中大数据量的分页解决方法?

最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。

## 13-4：说说数据库连接池工作原理和实现方案？

客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数
决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。
实现方案：连接池使用集合来进行装载，返回的Connection是原始Connection的代理，代理Connection的close方法，当调用close方法时，不是真正关连接，而是把它代
理的Connection对象放回到连接池中，等待下一次重复利用。

## 13-5：Java中如何进行事务的处理?

Connection类中提供了4个事务处理方法:

setAutoCommit(Boolean autoCommit):设置是否自动提交事务,默认为自动提交,即为true,通过设置false禁止自动提交事务;
commit():提交事务;
rollback():回滚事务.
savepoint:保存点

注意：savepoint不会结束当前事务，普通提交和回滚都会结束当前事务的

## 13-6：execute，executeQuery，executeUpdate的区别是什么？

Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者
update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。

Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用
executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的

java.util.SQLException。

Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，
它就是更新的条数，如果是DDL的话，就返回0。
只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。

## 13-7：PreparedStatement的缺点是什么，怎么解决这个问题？

PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案：

分别进行单条查询——这样做性能很差，不推荐。
使用存储过程——这取决于数据库的实现，不是所有数据库都支持。
动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。
在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。

## 13-8：JDBC的DriverManager是用来做什么的？

JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。
当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面
然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。

## 13-9：JDBC的ResultSet是什么?
在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。
ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。
默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet
当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。
可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。

## 13-10：有哪些不同的ResultSet？

一共有三种ResultSet对象。

ResultSet.TYPE_FORWARD_ONLY：这是默认的类型，它的游标只能往下移。
ResultSet.TYPE_SCROLL_INSENSITIVE：游标可以上下移动，一旦它创建后，数据库里的数据再发生修改，对它来说是透明的。
ResultSet.TYPE_SCROLL_SENSITIVE：游标可以上下移动，如果生成后数据库还发生了修改操作，它是能够感知到的。

ResultSet有两种并发类型。

ResultSet.CONCUR_READ_ONLY:ResultSet是只读的，这是默认类型。
ResultSet.CONCUR_UPDATABLE:我们可以使用ResultSet的更新方法来更新里面的数据。

## 13-11：JDBC的DataSource是什么，有什么好处

跟DriverManager相比，它的功能要更强大。我们可以用它来创建数据库连接，当然驱动的实现类会实际去完成这个工作。除了能创建连接外，它还提供了如下的特性：

缓存PreparedStatement以便更快的执行
可以设置连接超时时间
提供日志记录的功能
ResultSet大小的最大阈值设置
通过JNDI的支持，可以为servlet容器提供连接池的功能

## 13-12：如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？

在META-INF目录下配置context.xml文件【文件内容可以在tomcat默认页面的 JNDI Resources下Configure Tomcat's Resource Factory找到】

导入Mysql或oracle开发包到tomcat的lib目录下

初始化JNDI->获取JNDI容器->检索以XXX为名字在JNDI容器存放的连接池


## 13-13：常见的JDBC异常有哪些？

java.sql.SQLException——这是JDBC异常的基类。
java.sql.BatchUpdateException——当批处理操作执行失败的时候可能会抛出这个异常。这取决于具体的JDBC驱动的实现，它也可能直接抛出基类异常java.sql.SQLException。
java.sql.SQLWarning——SQL操作出现的警告信息。
java.sql.DataTruncation——字段值由于某些非正常原因被截断了（不是因为超过对应字段类型的长度限制）。

## 13-14：JDBC中存在哪些不同类型的锁?

乐观锁——只有当更新数据的时候才会锁定记录。
悲观锁——从查询到更新和提交整个过程都会对数据记录进行加锁。

## 13-15：java.util.Date和java.sql.Date有什么区别？

java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段

## 13-16：SQLWarning是什么，在程序中如何获取SQLWarning？

SQLWarning是SQLException的子类，通过Connection, Statement, Result的getWarnings方法都可以获取到它。 SQLWarning不会中断查询语句的执行，只是用来提示用户存在相关的警告信息。

## 13-17：如果java.sql.SQLException: No suitable driver found该怎么办？

如果你的SQL URL串格式不正确的话，就会抛出这样的异常。不管是使用DriverManager还是JNDI数据源来创建连接都有可能抛出这种异常。它的异常栈看起来会像下面这样。


## 13-18：JDBC的RowSet是什么，有哪些不同的RowSet？

RowSet用于存储查询的数据结果，和ResultSet相比，它更具灵活性。RowSet继承自ResultSet，因此ResultSet能干的，它们也能，而ResultSet做不到的，它们还是可以。RowSet接口定义在javax.sql包里。

RowSet提供的额外的特性有：

提供了Java Bean的功能，可以通过settter和getter方法来设置和获取属性。RowSet使用了JavaBean的事件驱动模型，它可以给注册的组件发送事件通知，比如游标的移动，行的增删改，以及RowSet内容的修改等。
RowSet对象默认是可滚动，可更新的，因此如果数据库系统不支持ResultSet实现类似的功能，可以使用RowSet来实现。
RowSet分为两大类：

A. 连接型RowSet——这类对象与数据库进行连接，和ResultSet很类似。JDBC接口只提供了一种连接型RowSet，javax.sql.rowset.JdbcRowSet，它的标准实现是com.sun.rowset.JdbcRowSetImpl。
B. 离线型RowSet——这类对象不需要和数据库进行连接，因此它们更轻量级，更容易序列化。它们适用于在网络间传递数据。

有四种不同的离线型RowSet的实现。

CachedRowSet——可以通过他们获取连接，执行查询并读取ResultSet的数据到RowSet里。我们可以在离线时对数据进行维护和更新，然后重新连接到数据库里，并回写改动的数据。
WebRowSet继承自CachedRowSet——他可以读写XML文档。
JoinRowSet继承自WebRowSet——它不用连接数据库就可以执行SQL的join操作。
FilteredRowSet继承自WebRowSet——我们可以用它来设置过滤规则，这样只有选中的数据才可见。

## 13-19：什么是JDBC的最佳实践？

数据库资源是非常昂贵的，用完了应该尽快关闭它。Connection, Statement, ResultSet等JDBC对象都有close方法，调用它就好了。
养成在代码中显式关闭掉ResultSet，Statement，Connection的习惯，如果你用的是连接池的话，连接用完后会放回池里，但是没有关闭的ResultSet和Statement就会造成资源泄漏了。
在finally块中关闭资源，保证即便出了异常也能正常关闭。
大量类似的查询应当使用批处理完成。
尽量使用PreparedStatement而不是Statement，以避免SQL注入，同时还能通过预编译和缓存机制提升执行的效率。
如果你要将大量数据读入到ResultSet中，应该合理的设置fetchSize以便提升性能。
你用的数据库可能没有支持所有的隔离级别，用之前先仔细确认下。
数据库隔离级别越高性能越差，确保你的数据库连接设置的隔离级别是最优的。
如果在WEB程序中创建数据库连接，最好通过JNDI使用JDBC的数据源，这样可以对连接进行重用。
如果你需要长时间对ResultSet进行操作的话，尽量使用离线的RowSet。

# 14.应用

## 14.1：一条SQL语句执行得很慢的原因有哪些

要分两种情形：

1. 大多数情况是正常的，只是偶尔会出现很慢的情况。
   
   * 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

   * 执行的时候，遇到锁，如表锁、行锁。

2. 在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。
   
   * 没有用上索引
   * 数据库选错了索引

## 14.2：为什么数据库会选错了索引

系统在执行的时候，会进行预测，是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？

扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，需要走两次索引，而且，我们也不知道符合 这个条件的数据有多少行，万一真的是n条，那就惨了，所以系统是有可能走全表扫描而不走索引的

系统如何进行预判主要依赖于索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。

这个区分度也叫做基数，系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的

那么出现失误的地方就是采样，比如采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后，系统就不走索引了，直接走全部扫描了。

主要是由于统计的失误，导致系统没有走索引，而是走了全表扫描。

## 6-4：当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，如何解决

1. 限定数据的范围
务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

2. 读/写分离
经典的数据库拆分方案，主库负责写，从库负责读；

3. 垂直分区
根据数据库里面数据表的相关性进行拆分。 

4. 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

## 6-5：垂直分表

垂直拆分的优点： 可以使得列数据变小，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让
事务变得更加复杂

## 6-6：水平分表

 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂

一般是水平分库，数据库分片的两种常见方案：

1. 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
2. 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 


# 15.分库分表的设计

## 4-7：为什么要分库分表？

当一张表的数据达到几千万时，查询一次所花的时间会变长。这时候，如果有联合查询的话，可能会卡死在那儿，甚至把系统给拖垮。

而分库分表的目的就在于此：减小数据库的负担，提高数据库的效率，缩短查询时间。另外，因为分库分表这种改造是可控的，底层还是基于RDBMS，因此整个数据库的运维体系以及相关基础设施都是可重用的。

## 4-8：分库分表，id如何处理

方式1——UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示
   比如文件的名字。

方式2——数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独
立部署数据库实例，成本高，还会有性能瓶颈。

方式3——利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编
码更加复杂，增加了系统成本。

## 4-9：为什么 MySQL 不推荐使用 uuid 或者雪花 id 作为主键？

自增的主键的值是顺序的,所以Innodb把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候：

①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费

②新插入的行一定会在原有的最大数据行下一行,mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗

③减少了页分裂和碎片的产生

因为uuid相对顺序的自增id来说是毫无规律可言的,新行的值不一定要比之前的主键的值要大,所以innodb无法做到总是把新行插入到索引的最后,而是需要为新行寻找新的合适的位置从而来分配新的空间。

这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致一些问题：

①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO

②因为写入是乱序的,innodb不得不频繁的做页分裂操作,以便为新的行分配空间,页分裂导致移动大量的数据，一次插入最少需要修改三个页以上

③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片

在把随机值（uuid和雪花id）载入到聚簇索引(innodb默认的索引类型)以后,有时候会需要做一次OPTIMEIZE TABLE来重建表并优化页的填充，这将又需要一定的时间消耗。

## 4-10：使用自增id的缺点

①别人一旦爬取你的数据库,就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况

②对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争

③Auto_Increment锁机制会造成自增锁的抢夺,有一定的性能损失



## 4-12：mysql分页，超大分页怎么处理？

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.

从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.

                     

## 4-14：为什么要尽量设定一个主键?

主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.

## 4-15：主键使用自增ID还是UUID?

推荐使用自增ID,不要使用UUID.

因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.




# ---------------------------------------------------------------------------------------------------------------


# 1.缓存

## 1-1：缓存思想

我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补。

## 1-2：使用缓存为系统带来了什么问题

1. 系统复杂性增加：引入缓存之后，你要维护缓存和数据库的数据一致性、维护热点缓存等等。
2. 系统开发成本增加：引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本还是很贵的，
   毕竟耗费的是宝贵的内存。但是，如果你只是简单的使用一下本地缓存存储一下简单的数据，并且数据量不大的话，那么就不需要单独去弄一个缓存服务。

## 1-3：本地缓存解决方案

一：JDK 自带的 HashMap 和 ConcurrentHashMap 了。

ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。

二： Ehcache 、 Guava Cache 、 Spring Cache 这三者是使用的比较多的本地缓存框架。

Ehcache 的话相比于其他两者更加重量。不过，相比于 Guava Cache 、 Spring Cache 来说， Ehcache 支持可以嵌入到 hibernate 和 mybatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中、同时也提供了集群方案（比较鸡肋，可忽略）。

Guava Cache 和 Spring Cache 两者的话比较像。

Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和 ConcurrentHashMap 的思想有异曲同工之妙。

使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如缓存穿透、内存溢出。

三： 后起之秀 Caffeine。

相比于 Guava 来说 Caffeine 在各个方面比如性能要更加优秀，一般建议使用其来替代 Guava 。并且， Guava 和 Caffeine 的使用方式很像！

本地缓存固然好，但是缺陷也很明显，比如多个相同服务之间的本地缓存的数据无法共享。

## 1-4：为什么要有分布式缓存?/为什么不直接用本地缓存?

其实分布式缓存类似于一种内存数据库的服务，它的最终作用就是提供缓存数据的服务。

本地的缓存的优势是低依赖，比较轻量并且通常相比于使用分布式缓存要更加简单。

本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。

本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

使用分布式缓存之后，缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的性能、容量和提供的功能都要更加强大。

使用分布式缓存的缺点呢，也很显而易见，那就是你需要为分布式缓存引入额外的服务比如 Redis 或 Memcached，你需要单独保证 Redis 或 Memcached 服务的高可用。

## 1-5：缓存读写模式/更新策略

1. Cache Aside Pattern（旁路缓存模式）
写：更新 DB，然后直接删除 cache 。
读：从 cache 中读取数据，读取到就直接返回，读取不到的话，就从 DB 中取数据返回，然后再把数据放到 cache 中。
Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。另外，Cache Aside Pattern 有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。

Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。

2. Read/Write Through Pattern（读写穿透）
Read/Write Through 套路是：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。

写（Write Through）：先查 cache，cache 中不存在，直接更新 DB。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。
读(Read Through)： 从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。
Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。

和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。

3. Write Behind Pattern（异步缓存写入）
Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。

但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。

Write Behind Pattern 下 DB 的写性能非常高，尤其适合一些数据经常变化的业务场景比如说一篇文章的点赞数量、阅读数量。 往常一篇文章被点赞 500 次的话，需要重复修改 500 次 DB，但是在 Write Behind Pattern 下可能只需要修改一次 DB 就可以了。

但是，这种模式同样也给 DB 和 Cache 一致性带来了新的考验，很多时候如果数据还没异步更新到 DB 的话，Cache 服务宕机就 gg 了。

## 1-6：缓存数据的处理流程是怎样的？

1. 如果用户请求的数据在缓存中就直接返回。
2. 缓存中不存在的话就看数据库中是否存在。
3. 数据库中存在的话就更新缓存中的数据。
4. 数据库中不存在的话就返回空数据。

# 2.Redis

## 2-1：为什么要⽤ redis/为什么要⽤缓存

1. 高性能方面，假如⽤户第⼀次访问数据库中的某些数据。这个过程会⽐较慢，因为是从硬盘上读取的。将该⽤户访问的数据存在缓存
   中，这样下⼀次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的
   对应数据改变的之后，同步改变缓存中相应的数据即可！

2. ⾼并发：直接操作缓存能够承受的请求是远远⼤于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这
   样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据库。

## 2-2：为什么要⽤ redis ⽽不⽤ map/guava 做缓存?

缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都需要各⾃保存⼀份缓存，缓存不具有⼀致性。

使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。

## 2-3：说一下 Redis 和 Memcached 的区别和共同点

共同点 ：

都是基于内存的数据库，一般都用来当做缓存使用。
都有过期策略。
两者的性能都非常高。

区别 ：

1. Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构
   的存储。Memcached 只支持最简单的 k/v 数据类型。
2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
3. Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。
5. Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.
6. Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）
7. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
8. Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

## 2-4：为什么说Redis快

1. 完全基于内存，数据存在内存中，类似于hashmap，hashmap的优势就是查找和操作的时间复杂度是o（1）

2. 数据结构进行了特别的设计，比如说SDS结构中字符串长度len，压缩链表

3. 采用单线程，避免了不洗要的上下文切换和竞争条件，也不存在多线程或者多线程导致切换而销号CPU，不用去考虑各种所得问题，不存在枷锁释放锁操
   作，没有因为可能出现死锁二导致的性能消耗

4. 使用多路I/O复用模型，非阻塞IO，多路IO复用模型利用select、poll、epoll可以同时监察多个流的IO事件时，就从阻塞态中唤醒，也是程序就会轮询一
   遍所有的流，并且只依次顺序的处理就绪流，这样就可以避免了大量的无用操作

5. RESP协议也就是Redis的序列化协议，文本协议，解析迅速

6. 持久化采用子线程进行磁盘操作

## 2-5：Redis应用场景

1. 热点数据的缓存

由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作

2. 限时业务的运用

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. 计数器相关问题

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、比如限制一个手机号发多少条短信、一个接口一分钟限
制多少请求、一个接口一天限制调用多少次等等。

4. 排行榜相关问题

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。

5. 分布式锁


6. 延时操作

没有做过具体操作，就是想过，比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 

7. 分页、模糊搜索

就是在实习期间利用zrangebylex方法可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。

对公司进行项目的数据进行了模拟测试，公司存储数据6000万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据���io操作，所以总体还是比直接mysql查询更利于
系统的性能保障。

8. 点赞、好友等相互关系的存储
   
Redis set可以实现set是可以自动排重的，比如说在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。

9. 队列

由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。

# 3.Redis五大数据类型与编码方式

## 3-1：五大数据类型（理解就好）

1. string

   * Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串

2. list

   * redis list数据结构底层采用压缩列表ziplist或linkedlist两种数据结构进行存储，首先以ziplist进行存储，在不满足ziplist的存储要求后转换为linkedlist列
     表。（list长度不超过64，数量不超过512）

3. hash
 
   * 使用ziplist（压缩列表）和hashtable
   * hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis的hash做了更多优化。

4. set

   *  set的底层存储intset和hashtable是存在编码转换的，使用intset存储必须满足元素都是整数和数量不超过512，否则使用hashtable

5. zset

   * 编码有ziplist（压缩链表）和skiplist（跳表）两种
   * zset 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元
素的列表。

## 3-2：动态字符串与C语言自带字符串的区别

## 3-3：Redis字典底层如何解决冲突

## 3-4：hash如何扩容

正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。

当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。

## 3-5：什么是渐进式

大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到
新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所
以 Redis 使用 渐进式 rehash 小步搬迁

+

书本

## 3-6：什么时候使用ziplist而不是hash

哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
哈希对象保存的键值对数量小于512个

## 3-7：什么时候使用ziplist什么时候使用skiplist？

当zset满足以下两个条件的时候，使用ziplist：

保存的元素少于128个
保存的所有元素大小都小于64字节

## 3-8：skiplist原理

核心点主要是包括一个dict对象和一个skiplist对象。dict保存key/value，key为元素，value为分值；skiplist保存的有序的元素列表，每个元素包括元素和分值。两种数据结构下的元素指向相同的位置。

## 3-9：ziplist原理


## 3-10：为什么选择跳表而不是平衡树或者哈希表

## 3-11：redis 数据存储过程

我只是大体看过set的一部分源码
从redisDb当中找到dict，每个db就一个dict而已。
从dict当中选择具体的dictht对象。
首先根据key计算hash桶的位置，也就是index。
新建一个DictEntry对象用于保存key/value，将新增的entry挂到dictht的table对应的hash桶当中，每次保存到挂链的头部。
dictSetKey的宏保存key
dictSetVal的宏保存value

## 3-12：数据淘汰过程

遍历所有的db进行数据的释放
根据不同的策略选择从db.dict还是从db.expires选择待过期数据
区分不同的淘汰策略选择不同的key，主要分为随机淘汰、LRU淘汰、TTL时间淘汰。

# 4.Redis的单线程

## 4-1：为什么Redis是单线程

1. 可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。

引入了多线程，我们就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，我们会需要在可能被并发读写的变量上增加互斥锁：

在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。


2. 使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制并发处理来自客户端的多个连接，同时等待多个连接发送的请求。

在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。

使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。


3. Redis 选择单线程模型的决定性原因，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。

比如说多线程中

保存线程 1 的执行上下文；
加载线程 2 的执行上下文；

频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。

## 4-2：既然是单线程，那怎么监听大量的客户端连接呢？

Redis 通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。

这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。

## 4-3：Redis为什么又采用了多线程

适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂

所以就需要提高网络 IO 读写性能


# 5.过期策略

## 5-1：Redis 给缓存数据设置过期时间有啥用？

因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。

很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。

如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

## 5-2：Redis是如何判断数据是否过期的呢？
Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。

## 5-3：过期策略分类

惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

## 5-4：缓存淘汰机制

volatile-lru（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## 5-5：LRU算法原理

如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。

## 5-6：如何实现LRU
   
1.用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。
2.利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。
3.利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。
对于第一种方法，需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。对于第二种方法，链表在定位数据的时候时间复杂度为O(n)。所以在一般使用第三种方式来是实现LRU算法。

# 6.持久化机制

## 6-1：什么是Redis持久化？

RDB 持久化：该机制可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

AOF 持久化：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令
全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），
使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小

无持久化：让数据只在服务器运行时存在。

同时应用 AOF 和 RDB：当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 
文件所保存的数据集更完整

## 6-2:各自的优缺点？

RDB 的优缺点：

优点：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每
小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复
（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进
程在保存 RDB 文件时唯一要做的就是 fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的
速度比 AOF 的恢复速度要快。

缺点：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 
因为 RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你
就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会
非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。


AOF 的优缺点。

优点：
1、使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 
fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后
台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek 
， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

2、Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安
全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF文件
创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

缺点：

对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依
然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间
（latency）。

AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾
经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在
AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。

## 6-3：Redis持久化数据和缓存怎么做扩容？

如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。

如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用
可以在运行时进行数据再平衡的一套系统

## 6-4：持久化期间工作流程

客户端向数据库 发送写命令 (数据在客户端的内存中)
数据库 接收 到客户端的 写请求 (数据在服务器的内存中)
数据库 调用系统 API 将数据写入磁盘 (数据在内核缓冲区中)
操作系统将 写缓冲区 传输到 磁盘控控制器 (数据在磁盘缓存中)
操作系统的磁盘控制器将数据 写入实际的物理媒介 中 (数据在磁盘中)

## 6-5：持久化机制

# 7.集群主从复制

# 8.缓存雪崩

## 8-1：什么是缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

## 8-2：缓存穿透解决方案


## 8-3：什么是缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

## 8-4：有哪些解决办法？
针对 Redis 服务不可用的情况：

采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
限流，避免同时处理大量的请求。
针对热点缓存失效的情况：

设置不同的失效时间比如随机设置缓存的失效时间。
缓存永不失效。

# 9.如何保证缓存和数据库数据的一致性？

# 10.事务

## 10-1：Redis事务的概念

　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

## 10-2：Redis事务的三个阶段

开启：以MULTI开始一个事务

入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面

执行：由EXEC命令触发事务

## 10-3：Redis事务相关命令

multi，标记一个事务块的开始，返回 ok
exec，执行所有事务块内，事务块内所有命令执行的先后顺序的返回值，操作被，返回空值 nil
discard，取消事务，放弃执行事务块内的所有命令，返回 ok
watch，监视 key 在事务执行之前是否被其他指令改动，若已修改则事务内的指令取消执行，返回 ok
unwatch，取消 watch 命令对 key 的监视，返回 ok

## 10-4：事务管理（ACID）概述

## 10-5：Redis事务支持隔离性吗

## 10-6：Redis事务保证原子性吗，支持回滚吗

# 11.Redis应用

## 11-1：为什么Redis 变慢了

1. 使用复杂度高的命令


通过查看慢日志记录，我们就可以知道在什么时间执行哪些命令比较耗时，如果你的业务经常使用O(n)以上复杂度的命令，例如sort、sunion、zunionstore，或者在执行O(n)命令时操作的数据量比较大，这些情况下Redis处理数据时就会很耗时。

最好不使用这些复杂度较高的命令，并且一次不要获取太多的数据，每次尽量操作少量的数据，让Redis可以及时处理返回。

2. 存储大key

针对大key的问题，Redis官方在4.0版本推出了lazy-free的机制，用于异步释放大key的内存，降低对Redis性能的影响。即使这样，我们也不建议使用大key，大key在集群的迁移过程中，也会影响到迁移的性能，

3. 集中过期

平时在使用Redis时没有延时比较大的情况，但在某个时间点突然出现一波延时，而且报慢的时间点很有规律，例如某个整点，或者间隔多久就会发生一次。
如果出现这种情况，就需要考虑是否存在大量key集中过期的情况。

在集中过期时增加一个随机时间，把这些需要过期的key的时间打散即可。

4. 实例内存达到上限

有时我们把Redis当做纯缓存使用，就会给实例设置一个内存上限maxmemory，然后开启LRU淘汰策略。
当实例的内存达到了maxmemory后，你会发现之后的每次写入新的数据，有可能变慢了。
导致变慢的原因是，当Redis内存达到maxmemory后，每次写入新的数据之前，必须先踢出一部分数据，让内存维持在maxmemory之下。
这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于配置的淘汰策略

5. fork耗时严重

如果你的Redis开启了自动生成RDB和AOF重写功能，那么有可能在后台生成RDB和AOF重写时导致Redis的访问延迟增大，而等这些任务执行完毕后，延迟情况消失。

生成RDB和AOF都需要父进程fork出一个子进程进行数据的持久化，在fork执行过程中，父进程需要拷贝内存页表给子进程，如果整个实例内存占用很大，那么需要拷贝的内存页表会比较耗时，此过程会消耗大量的CPU资源，在完成fork之前，整个实例会被阻塞住，无法处理任何请求，如果此时CPU资源紧张，那么fork的时间会更长，甚至达到秒级。这会严重影响Redis的性能。

所以使用Redis时建议部署在物理机上，降低fork的影响。

6. 绑定CPU

绑定CPU的Redis，在进行数据持久化时，fork出的子进程，子进程会继承父进程的CPU使用偏好，而此时子进程会消耗大量的CPU资源进行数据持久化，子进程会与主进程发生CPU争抢，这也会导致主进程的CPU资源不足访问延迟增大。

所以在部署Redis进程时，如果需要开启RDB和AOF重写机制，一定不能进行CPU绑定操作！

7. 开启AOF

当执行AOF文件重写时会因为fork执行耗时导致Redis延迟增大，除了这个之外，如果开启AOF机制，设置的策略不合理，也会导致性能问题。

8. 使用Swap

如果你发现Redis突然变得非常慢，每次访问的耗时都达到了几百毫秒甚至秒级，那此时就检查Redis是否使用到了Swap，这种情况下Redis基本上已经无法提供高性能的服
务。
我们知道，操作系统提供了Swap机制，目的是为了当内存不足时，可以把一部分内存中的数据换到磁盘上，以达到对内存使用的缓冲。
但当内存中的数据被换到磁盘上后，访问这些数据就需要从磁盘中读取，这个速度要比内存慢太多！

9. 网卡负载过高

Redis也稳定运行了很长时间，但在某个时间点之后开始，访问Redis开始变慢了，而且一直持续到现在，

检查一下机器的网卡流量，是否存在网卡流量被跑满的情况。

网卡负载过高，在网络层和TCP层就会出现数据发送延迟、数据丢包等情况。Redis的高性能除了内存之外，就在于网络IO，请求量突增会导致网卡负载变高。

# ---------------------------------------------------------------------------------------------------------------

# 1.Spring概述

## 1-1：什么是spring?

书本

Spring的优缺点是什么？

1，降低了组件之间的耦合性，实现了软件各层之间的解耦。

2，可以使用容器提供的众多服务，如事务管理，消息服务等。

3，容器提供单例模式支持。

4，容器提供了AOP技术，利用它可以很容易实现一些拦截，如权限拦截，运行期监控等。

5，容器提供了众多的辅助类，能够加快应用的开发。

6，spring对于主流的应用框架提供了很好的支持，例如mybatis等。

7，spring属于低入侵式设计。

8，独立于各种应用服务器。

9，spring的DI机制降低了业务对象替换的复杂性。

10，spring的高度开放性，并不强制应用完全依赖于它，开发者可以自由选择spring的部分或者全部。

spring的缺点：

使用了大量的反射机制，反射机制非常占用内存。


4、Spring有哪些应用场景
5、Spring由哪些模块组成？
6、Spring 框架中都用到了哪些设计模式？
7、详细讲解一下核心容器（spring context应用上下文) 模块
8、Spring框架中有哪些不同类型的事件

9、Spring 应用程序有哪些不同组件？

10、使用 Spring 有哪些方式？





## 1-2：Spring用到的设计模式

1. 工厂模式:BeanFactory 就是简单工厂模式的体现，用来创建对象的实例;
2. 单例模式:Bean默认为单例模式。
3. 代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;
4. 模板方法:用来解决代码重复的问题。比如.RestTemplate,JmsTemplate,JpaTemplate。
5. 观察者模式:定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新,如Spring 中 listener的实现--ApplicationListener.


## 1-3：什么是 Spring 的循环依赖

就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，然后去创建 B 对象的时候，又发现 B 对象依赖 C，然后去创建 C 对象的时候，又发现 C 对象依赖 A。

## 1-4：什么是三级缓存

1. 第一级缓存：单例缓存池 singletonObjects。
2. 第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。
3. 第三级缓存：singletonFactories 单例对象工厂缓存

先从一级缓存singletonObjects中去获取，如果获取到 Bean 就直接返回。
如果获取不到或者对象正在创建中，那就再从二级缓存earlySingletonObjects中获取，如果获取到就直接返回。
如果前两级缓存都没成功返回，且允许 singletonFactories(allowEarlyReference=true)通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。

## 1-5：什么是早期暴露的对象

你是一个不完整的对象，你的属性还没有值，你的对象也没有被初始化。这就是早期暴露的对象，只是提前拿出来给你认识认识。但他非常重要。这是多级缓存解决循环依赖问题的一个巧妙的地方。

## 1-6：如何解决循环依赖

主要是用三级缓存来解决循环依赖问题

比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决

1. 使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~
2. 实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
3. 初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
4. 为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~
5. 实例化B，并将其放入缓存。（此时B也能够被引用了）
6. 初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
7. 此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回
8. B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。
9. 因为B实例已经成功返回了，因此最终A也初始化成功
10. 到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美

## Spring两大特性

IOC、AOP

自己细化

## Spring和Springboot的区别





# 2.Spring控制反转

## 2-1：IOC原理

ioc也叫控制反转，是一种设计思想。简单来说就是将对象的创建和管理交由spring管理。ioc容器是实现这一思想的载体

ioc容器本质上是一个map，存放着各种bean对象，key是bean对象名，value是bean配置信息。bean对象的创建、依赖关系都交由ioc容器完成，使用时不需要关心bean对象什么时候创建也不需要手动维护对象间的关系。

ioc容器相当于一个第三方的容器，关联着使用资源的双方。

比如一个user类和userinfo类，user类要使用userinfo类的属性，需要调用时创建user类和userinfo类的的对象，然后进行属性注入。
但是如果将user和userinfo都交由ioc容器管理，调用时只需要从ioc容器中取出user对象，那么user对象需要的userinfo属性会在ioc容器中进行注入，取出的user对象是已经完成依赖注入的对象。

## 2-2：IOC容器种类

## 2-3：BeanFactory与ApplicationContext区别

## 2-4：什么是依赖注入

Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。

## 2-5：有哪些不同类型的IOC（依赖注入）方式？

构造器依赖注入： 构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。

Setter方法注入： Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。

接口注入：定义接口

## 2-5：IOC与DI的的区别: 

IOC:  控制反转,将类的对象的创建交给Spring类管理创建. 
DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. 

## 2-6：


# 3.Spring面向切面编程(AOP)

## 3-1：什么是aop

面相切面编程，与传统oop相比，传统oop编程是自顶向下的编写主业务逻辑，但往往需要参杂着一些与主业务逻辑无关或关系不大的逻辑，这就产生了横切性问题。Aop能很好的隔离和管理这些与主业务逻辑关联不大的业务代码，使得代码的可读性和可维护性大大提高。

能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装
起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

## 3-2：AOP的相关概念：

(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知
(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)
(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式
(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程
(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段
(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类
(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO





# 3.Spring Bean
## 3-1：Bean的五种作用域

singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。
global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话

## 3-2：Spring 中的单例 bean 的线程安全问题了解吗？

单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。

常见的有两种解决办法：

在Bean对象中尽量避免定义可变的成员变量（不太现实）。

在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

## 3-2：Bean的生命周期

（1）实例化（必须的）构造函数构造对象
（2）装配（可选的）为属性赋值
（3）回调（可选的）（容器-控制类和组件-回调类）
（4）初始化(init-method=" ")
（5）就绪
（6）销毁（destroy-method=" "） 

（1）实例化Bean：
对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入
另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当
容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。
（2）设置对象属性（依赖注入）：
实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通 过BeanWrapper提供的设置属性的接口完成依赖注入。
（3）处理Aware接口：
接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：
①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方
法，此处传递的就是Spring配置文件中Bean的id值；
②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的
是Spring工厂自身。
③如果这个Bean已经实现了ApplicationContextAware接口，会调用
setApplicationContext(ApplicationContext)方法，传入Spring上下文；
（4）BeanPostProcessor：
如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用
postProcessBeforeInitialization(Object obj, String s)方法。
（5）InitializingBean 与 init-method：
如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。
（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object
obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；
以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。
（7）DisposableBean： 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的
destroy()方法；
（8）destroy-method：
最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。



## 3-3：


# 4.Spring注解


# 5.Spring数据访问


# 6.


# 7.SpringMVC

## 7-1：SpringMVC流程

1）用户发送请求至前端控制器DispatcherServlet:

2）DispatcherServlet收到请求后，题用HandlerMapping处理器映射器,请求获取Handle;

3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给
   DispatcherServlet;

4） DispatcherServlet调用HandlerAdapter处理器适配器;

5）HandlerAdapter 经过适配调用具体处理器(Handler，也叫后端控制器):

6）Handler执行完成返回 ModelAndView;

7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet:

8） DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析;

9）ViewResolver解析后返回具体View:

10）DispatcherServlet对 View进行渲染视图（即将模型数据填充至视图中）

11） DispatcherServlet 响应用户。


# 8.Spring事务

## 8-1：spring事务种类

spring支持编程式事务管理和声明式事务管理两种方式
①编程式事务管理使用TransactionTemplate.
②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，
将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完
目标方法之后根据执行情况提交或者回滚事务。

## 8-2：Spring两种事务区别

1）声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务 
   规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。

2）声明式事务管理要优于编程式事务管理，这正是 spring倡导的非侵入式的开发方式，使业务代码不受污染，
   只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。

## 8-3：事务管理接口

1. PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。
2. TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。
3. TransactionStatus： 事务运行状态。

我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，

而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。

PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离界别、传播行
为等来进行事务管理 ，

而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。


## 8-3：事务传播行为

①PROPAGATION_REQUIRED:如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
PROPAGATION_SUPPORTS:支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
③ PROPAGATION_MANDATORY:支持当前事务，如果当前仔在事分，影果当前不存在事务，就抛出异常。
PROPAGATION_REOUIRES NEW:创建新事务，无论当前存不存在事务，都创建新事务。
PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED属性执行。

## 8-4：事务隔离级别

①ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。
ISOLATION_READ_UNCOMMITTED:读未提交，允许另外一个事务可以看到这个事务未提交的数据。
③ISOLATION_READ_COMMITTED:读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该 
事务对已有记录的更新。
④ ISOLATION_REPEATABLE_READ:可重复读，保证一个事务修改的数据提交后才能另一事务读取，但是不能看到
该事务对已有记录的更新。
⑤ ISOLATION_SERIALIZABLE:一个事务在执行的过程中完全看不到其他事务对数据库所


## 8-5：Spring的事务和数据库的事务隔离是一个概念么？

Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是： PlatformTransactionManager 。
通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。

## 8-6：事务属性详解

事务属性主要包括五部分：隔离级别、传播行为、回滚规则、是否只读、事务超时

## 8-7：事务传播行为

事务传播行为是为了解决业务层方法之间互相调用的事务问题。

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如

我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。

这个时候就涉及到业务层方法之间互相调用的事务问题。

如果我们的 bMethod()如果发生异常需要回滚，

如何配置事务传播行为才能让 aMethod()也跟着回滚呢

这个时候就需要事务传播行为的知识了，

## @Transactional 注解使用详解

方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。

类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。

接口 ：不推荐在接口上使用。

## 注解常用属性

1. propagation	事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过
2. isolation	事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过
3. timeout	事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。
4. readOnly	指定事务是否为只读事务，默认值为 false。
5. rollbackFor	用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。

## 注解原理

@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。

通过createAopProxy() 方法 决定了是使用 JDK 还是 Cglib 来做动态代理

如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。

# 9.MyBatis

## 9-1：MyBatis是什么

就和传统的JDBC一样，就是个连接数据库进行增删改查的开源框架

## 9-2：ORM是什么

指将数据库中的每一行数据用对象的形式表现出来。

## 9-3：JPA

是Java持久化接口

## 9-4：MyBatis优点

1. 简单易学，容易上手（相比于Hibernate） ---- 基于SQL编程

2. 消除了JDBC大量冗余的代码，不需要手动开关连接

3. 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDB提供了可扩展性，所以只要这个数据库有针对Java的
   jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。

4. 提供了很多第三方插件（分页插件 / 逆向工程）

5. 能够与Spring很好的集成

## 9-5：为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联
对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

## 9-6：传统JDBC开发存在的问题，如何解决的

1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。


2. Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。


3. 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决： Mybatis自动将java对象映射至sql语句。


4. 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比
较方便。
解决：Mybatis自动将sql执行结果映射至java对象。

## 9-7：Hibernate 和 MyBatis 的区别

1） Mybatis 它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，
2） Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性
能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运
营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的
前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定
义多套 sql 映射文件，工作量大。
3） Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是
Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象
模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都
是好架构，所以框架只有适合才是最好。


## 9-8：MyBatis的解析和运行原理

MyBatis的运行过程分为两大步：

1. 读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory；
   - 第一步：通过org.apache.ibatis.builder.xml.XMLConfigBuilder解析配置的XML文件，对出所配置的参数，并将读取的能容存入org.apache.ibatis.session.
     Configuration类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中，以便后续将这些内容读出。
   - 第二步：使用Configuration对象去创建SqlSessionFactory。MyBatis中的SqlSessionFactory是个接口，而不是一个实现类，为此MyBatis提供了一个默认的实现类
     org.apache.ibatis.session.default.DefaultSqlSessionFactory。在大部分情况下都没有必要自己创建新的SqlSessionFactory实现类。

2. SqlSession的执行过程。
    主要使用JDK动态代理

## 9-9：MyBatis编程步骤是什么样的？

1、创建 SqlSessionFactory
2、通过 SqlSessionFactory 创建 SqlSession
3、通过 sqlsession 执行数据库操作
4、调用 session.commit()提交事务
5、调用 session.close()关闭会话

## 9-10：MyBatis的工作原理

1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着<select | update | delete | insert>标签项。

2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。

3、SqlSession对象完成和数据库的交互：
a、用户程序调用mybatis接口层api（即Mapper接口中的方法）
b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象
c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象
d、JDBC执行sql。

e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。

## 2.5 为什么需要预编译

预编译（#{}）会将SQL提前编译好，#{}位置为占位符，执行时候一个占位符就对应一个变量，不会影响到SQL结
构，所以不会存在SQL注入问题；
非预编译（${}）不会提前编译SQL，${}位置会直接将变量拼接进来，会影响到SQL的本身机构

## MyBatis是如何做到SQL预编译的呢？

在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。

## 如何防止SQL注入

攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵参数检验不足的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。

在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。

## Mybatis都有哪些Executor执行器？它们之间的区别是什么？

Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。

**SimpleExecutor：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

**``ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

**BatchExecutor：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

2.7 Mybatis中如何指定使用哪一种Executor执行器？

在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。

## 2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。

它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。

# 10.映射器

## 10-1：#{}和${}的区别是什么？

1. ${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
2. #{}是 sql 的参数占位符，Mybatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，
   比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。

## 10-2：Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为 sql 片段标签，通过<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。


3.2 模糊查询like语句该怎么写
3.3 在mapper中如何传递多个参数
3.4 Mybatis如何执行批量操作
3.5 如何获取生成的主键
3.6 当实体类中的属性名和表中的字段名不一样 ，怎么办
3.7 Mapper 编写有哪几种方式？
3.8 什么是MyBatis的接口绑定？有哪些实现方式？

3.9 使用MyBatis的mapper接口调用时有哪些要求？
## 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗

Dao 接口，就是人们常说的 Mapper接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中MappedStatement的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。


## 3.11 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？

不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。

原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。


## 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？

Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。


3.13 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？

## Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，3.16 还是说必须定义在A标签的前面？

虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。

原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。

# 11.高级查询

## 4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？

能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

t_id t_name s_id

| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |


## 4.2 Mybatis是否可以映射Enum枚举类？

Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。


# 12.动态SQL

## 12-1：Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？

Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind。

其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

## 12-2：Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。

有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

# 13.插件模块

## 6.1 Mybatis是如何进行分页的？分页插件的原理是什么？

Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：select _ from student，拦截 sql 后重写为：select t._ from （select \* from student）t limit 0，10

## 6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。

Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

# 14.缓存

## 14-1：Mybatis的一级、二级缓存

一级缓存是mybatis默认就帮我们开启的，一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓
存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

# 15.servlet

## 15-1：Servlet生命周期?


加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例

初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象

处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求

销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁

卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。

简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。

## forward和redirect的区别

实际发生位置不同，地址栏不同

转发是发生在服务器的

转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。
重定向是发生在浏览器的

- **重定向是由浏览器进行跳转的**，进行重定向跳转的时候，**浏览器的地址会发生变化的**。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。**这是由浏览器进行的页面跳转**实现重定向**会发出两个http请求**，**request域对象是无效的，因为它不是同一个request对象**
用法不同:

很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上

request.getRequestDispatcher("/资源名 URI").forward(request,response)

转发时"/"代表的是本应用程序的根目录【zhongfucheng】
response.send("/web应用/资源名 URI");

���定向时"/"代表的是webapps目录
能够去往的URL的范围不一样:

转发是服务器跳转只能去往当前web应用的资源
重定向是服务器跳转，可以去往任何的资源
传递数据的类型不同

转发的request对象可以传递各种类型的数据，包括对象
重定向只能传递字符串
跳转的时间不同

转发时：执行到跳转语句时就会立刻跳转
重定向：整个页面执行完之后才执行跳转
那么转发(forward)和重定向(redirect)使用哪一个？

根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。
典型的应用场景：

转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变
重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了

## tomcat容器是如何创建servlet类实例？用到了什么原理

当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）
在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。

## Servlet安全性问题
由于Servlet是单例的，当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。

## servlet写就行了，为什么要有springMVC这个东西呢

比如说在数据库进行了添加删除更改功能，在web.xml中注册新sevlet，并映射对应的/insert /delete /update /XXX，在这些新的servlet中调用View和Model层完成功能。

这样新定义servlet的方法比较麻烦，要去继承HttpServlet接口，实现接口方法，手写调用jsp的重定向或者请求转发，还要再web.xml中注册。

Spring主要也是通过DispatcherServlet实现了Servlet这个接口，又叫前端控制器，来自前端的请求会先到达这里，它负责到后台去匹配合适的handler。DispatcherServlet的主要工作流程如下：

前端请求到达DispatcherServlet。

前端控制器请求HandlerMappering 查找Handler。

如果查找到存在的处理器，进一步去调用service和dao层

返回结果再到controller层，渲染具体的视图，返回结果给页面。

## 两者区别

Servlet：性能最好，处理Http请求的标准。

SpringMVC：开发效率高（好多共性的东西都封装好了，是对Servlet的封装，核心的DispatcherServlet最终继承自HttpServlet）

## servlet加载顺序

web.xml 的加载顺序是：context- param -> listener -> filter -> servlet

## filter和Interceptor的区别

1、filter接口在javax.servlet包下面。inteceptor定义在org.springframework.web.servlet中。
2、filter是servlet规定的，interceptor即可用于web程序，也可用于application中。
3、filter是servlet容器支持的，interceptor是spring框架支持的。
4、filter通过dochain放行，interceptor通过prehandler放行。
5、filter只在方法前后执行，interceptor粒度更细，可以深入到方法前后，异常抛出前后。

## jsp和servlet区别

通过 http 请求一个 JSP 页面是，首先 Tomcat 会调用 service（）方法将JSP编译成为 Servlet，然后执行 Servlet。

## Servlet是线程安全的吗？

Servlet不是线程安全的

比如说，当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

Thread1和Thread2调用了同一个Servlet1，所以此时如果Servlet1中定义了实例变量或静态变量，那么可能会发生线程安全问题（因为所有的线程都可能使用这些变量）

# 15.SpringBoot

## 什么是 Spring Boot？

Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。

Spring Boot 有哪些优点？

Spring Boot 主要有如下优点：

容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。
开箱即用，远离繁琐的配置。
提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
没有代码生成，也不需要XML配置。
避免大量的 Maven 导入和各种版本冲突。
Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

@ComponentScan：Spring组件扫描。

配 置

什么是 JavaConfig？

Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：

（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。

（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。

（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。

Spring Boot 自动配置原理是什么？

注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，

@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。

筛选有效的自动配置类。

每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能

你如何理解 Spring Boot 配置加载顺序？

在 Spring Boot 里面，可以使用以下几种方式来加载配置。

1）properties文件；

2）YAML文件；

3）系统环境变量；

4）命令行参数；

等等……

什么是 YAML？

YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。

YAML 配置的优势在哪里 ?

YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？

配置有序，在一些特殊的场景下，配置有序很关键
支持数组，数组中的元素可以是基本数据类型也可以是对象
简洁
相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。

Spring Boot 是否可以使用 XML 配置 ?

Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。

spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?

单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。

spring boot 核心的两个配置文件：

bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；
application (. yml 或者 . properties)：由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
什么是 Spring Profiles？

Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。

如何在自定义端口上运行 Spring Boot 应用程序？

为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port = 8090

安全

如何实现 Spring Boot 应用程序的安全性？

为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。

比较一下 Spring Security 和 Shiro 各自的优缺点 ?

由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：

Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架
Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单
Spring Security 功能强大；Shiro 功能简单
Spring Boot 中如何解决跨域问题 ?

跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。

@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .maxAge(3600);
    }
}

项目中前后端分离部署，所以需要解决跨域的问题。
我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。
当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。
我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(urlBasedCorsConfigurationSource);
    }
}

什么是 CSRF 攻击？

CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。

监视器

Spring Boot 中的监视器是什么？

Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。

如何在 Spring Boot 中禁用 Actuator 端点安全性？

默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。

我们如何监视所有 Spring Boot 微服务？

Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。

整合第三方项目

什么是 WebSockets？

WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。

1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。

2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。

3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信

4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。

什么是 Spring Data ?

Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：

SpringData 项目支持 NoSQL 存储：

MongoDB （文档数据库）
Neo4j（图形数据库）
Redis（键/值存储）
Hbase（列族数据库）
SpringData 项目所支持的关系数据存储技术：

JDBC
JPA
Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。

什么是 Spring Batch？

Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。

什么是 FreeMarker 模板？

FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。

如何集成 Spring Boot 和 ActiveMQ？

对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。它只需要很少的配置，并且不需要样板代码。

什么是 Apache Kafka？

Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。

什么是 Swagger？你用 Spring Boot 实现了它吗？

Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。

前后端分离，如何维护接口文档 ?

前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。

其他

如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？

这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>

您使用了哪些 starter maven 依赖项？

使用了下面的一些依赖项

spring-boot-starter-activemq

spring-boot-starter-security

这有助于增加更少的依赖关系，并减少版本的冲突。

Spring Boot 中的 starter 到底是什么 ?

首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter

spring-boot-starter-parent 有什么用 ?

我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：

定义了 Java 编译版本为 1.8 。
使用 UTF-8 格式编码。
继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。
执行打包操作的配置。
自动化的资源过滤。
自动化的插件配置。
针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。
Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?

Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。

Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。

运行 Spring Boot 有哪几种方式？

1）打包用命令或者放到容器中运行

2）用 Maven/ Gradle 插件运行

3）直接执行 main 方法运行

Spring Boot 需要独立的容器运行吗？

可以不需要，内置了 Tomcat/ Jetty 等容器。

开启 Spring Boot 特性有哪几种方式？

1）继承spring-boot-starter-parent项目

2）导入spring-boot-dependencies项目依赖

如何使用 Spring Boot 实现异常处理？

Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。

如何使用 Spring Boot 实现分页和排序？

使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。

微服务中如何实现 session 共享 ?

在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。

Spring Boot 中如何实现定时任务 ?

定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。

在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。

使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。

使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。


## SpringBoot自动配置原理

# -----------------------------------------------------------------------

# 1.单例模式

## 1.1：什么是单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 1.2：为什么要用单例模式呢？

这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

## 1.3：简单来说使用单例模式可以带来下面几个好处:

1. 对于频繁使用的对象，可以省略创建对象所花费的时间；
2. 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

## 1.3：什么可以破坏单例模式

1. 反射
2. 序列化与反序列化
   * 通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性

## 1-4：单例有哪几种实现方式

饿汉方式(线程安全）
饿汉式（枚举方式）
懒汉式（非线程安全和synchronized关键字线程安全版本)
懒汉式(双重检查加锁版本)
懒汉式（登记式/静态内部类方式）


## 1-5：饿汉方式(线程安全)

```java
    public class Singleton {
       //在静态初始化器中创建单例实例，这段代码保证了线程安全
        private static Singleton uniqueInstance = new Singleton();
        //Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例
        private Singleton(){}
        public static Singleton getInstance(){
            return uniqueInstance;
        }
    }
```

JVM在加载这个类时就马上创建此唯一的单例实例，

不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，

典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。

## 1-6：饿汉式（枚举方式）

这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 它自动支持序列化机制，绝对防止多次实例化 （如果单例类实现了Serializable接口，默认情况下每次反序列化总会创建一个新的实例对象，关于单例与序列化的问题可以查看这一篇文章《单例与序列化的那些事儿》），同时这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式。

public enum Singleton {
	 //定义一个枚举的元素，它就是 Singleton 的一个实例
    INSTANCE;  
    
    public void doSomeThing() {  
	     System.out.println("枚举方法实现单例");
    }  
}


## 1-6：懒汉式（非线程安全和synchronized关键字线程安全版本 ）

```java
public class Singleton {  
      private static Singleton uniqueInstance;  
      private Singleton (){
      }   
      //没有加入synchronized关键字的版本是线程不安全的
      public static Singleton getInstance() {
          //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
	      if (uniqueInstance == null) {  
	          uniqueInstance = new Singleton();  
	      }  
	      return uniqueInstance;  
      }  
 }
```

“ 懒汉式” 就是说单例实例在第一次被使用时构建，而不是在JVM在加载这个类时就马上创建此唯一的单例实例。

上面这种方式很明显是线程不安全的，如果多个线程同时访问getInstance()方法时就会出现问题。如果想要保证线程安全，一种比较常见的方式就是在getInstance() 方法前加上synchronized关键字，

```java
public static synchronized Singleton getInstance() {  
	      if (instance == null) {  
	          uniqueInstance = new Singleton();  
	      }  
	      return uniqueInstance;  
      }  
```
## 1-7：懒汉式(双重检查加锁版本)

利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步，这正是我们想要的效果。

```java
public class Singleton {

    //volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getInstance() {
       //检查实例，如果不存在，就进入同步代码块
        if (uniqueInstance == null) {
            //只有第一次才彻底执行这里的代码
            synchronized(Singleton.class) {
               //进入同步代码块后，再检查一次，如果仍是null，才创建实例
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
## 1-8：懒汉式（登记式/静态内部类方式）

静态内部实现的单例是懒加载的且线程安全。

只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 
instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}   
```


## 单例模式里面为什么写了volatile

因为在new一个对象有几个步骤。1.看class对象是否加载，如果没有就先加载class对象，2.分配内存空间，初始化实例，3.调用构造函数，4.返回地址给引用。而cpu为了优化程序，可能会进行指令重排序，打乱这3，4这几个步骤，导致实例内存还没分配，就被使用了。

假设线程A执行到new Singleton()，开始初始化实例对象，由于存在指令重排序，这次new操作，先
把引用赋值了，还没有执行构造函数。这时时间片结束了，切换到线程B执行，线程B调用new 
Singleton()方法，发现引用不等于null，就直接返回引用地址了，然后线程B执行了一些操作，就
可能导致线程B使用了还没有被初始化的变量。

加了volatile之后，就保证new 不会被指令重排序。

# 2.工厂模式

## 2-1：工厂模式的定义

在基类中定义创建对象的一个接口，让子类决定实例化哪个类。

工厂方法让一个类的实例化延迟到子类中进行。

## 2-2：工厂模式的分类：

（1）简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。

（2）工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式；

（3）抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。

## 2-3：在开源框架中的使用

(1)Spring中通过getBean(“xxx”)获取Bean；


## 2-4：为什么要用工厂模式

(1) 解耦 ：把对象的创建和使用的过程分开

(2)降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用
到，那么就会有很多的重复代码。

(3) 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需
要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。

## 2-5：简单工厂例子

创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图.

（1）创建Shape接口
```java
public interface Shape {
    void draw();
}
```
（2）创建实现该接口的具体图形类

圆形
```java
public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}
```

长方形
```java
public class Rectangle implements Shape {
    public Rectangle() {
        System.out.println("Rectangle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Rectangle");
    }
}
```

正方形

```java
public class Square implements Shape {
    public Square() {
        System.out.println("Square");
    }

    @Override
    public void draw() {
        System.out.println("Draw Square");
    }
}
```

（3）创建工厂类：
```java
public class ShapeFactory {

    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}
```

（4）测试方法：

```java
public class Test {

    public static void main(String[] args) {

        // 获取 Circle 的对象，并调用它的 draw 方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();

        // 获取 Rectangle 的对象，并调用它的 draw 方法
        Shape rectangle = ShapeFactory.getShape("RECTANGLE");
        rectangle.draw();

        // 获取 Square 的对象，并调用它的 draw 方法
        Shape square = ShapeFactory.getShape("SQUARE");
        square.draw();
    }
}
```
但是

这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 
开放-封闭原则 。

## 2-6：使用反射机制改善简单工厂

```java
package factory_pattern;

/**
 * 利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端
 * 
 * @author Administrator
 *
 */
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
```

测试方法：
```java
package factory_pattern;

public class Test2 {
    public static void main(String[] args) {

        Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);
        circle.draw();

        Rectangle rectangle = (Rectangle) ShapeFactory2.getClass(factory_pattern.Rectangle.class);
        rectangle.draw();

        Square square = (Square) ShapeFactory2.getClass(factory_pattern.Square.class);
        square.draw();
    }

}
```

这种方式的虽然符合了 开放-关闭原则 ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 反射+配置文件 的形式来改善，这种方式使用的也是比较多的。

## 2-7：工厂方法模式

在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。

适用场景

1. 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

2. 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏

3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

工厂方法模式角色分配

抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应

工厂方法模式实例
对于简单工厂来说，我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。

(1)增加一个工厂接口：

public interface Factory {
    public Shape getShape();
}

（2）增加相关工厂类:

圆形工厂类

public class CircleFactory implements Factory {

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Circle();
    }

}

长方形工厂类

public class RectangleFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Rectangle();
    }

}

圆形工厂类

public class SquareFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Square();
    }

}

（3）测试：

public class Test {

    public static void main(String[] args) {
        Factory circlefactory = new CircleFactory();
        Shape circle = circlefactory.getShape();
        circle.draw();
    }

}

## 2-8：抽象工厂模式

在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。

适用场景

和工厂方法一样客户端不需要知道它所创建的对象的类。

需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品）

系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）

抽象工厂方法模式角色分配：

抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。
。

抽象工厂的工厂和工厂方法中的工厂有什么区别呢？

抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。


抽象工厂模式实例

我们现在这样考虑生产A类产品的工厂可以顺便生产A类产品的衍生品，生产B类产品的工厂可以顺便生产B类产品的衍生品。

抽象工厂模式实例

（1）创建相关接口：
类

public interface Gun {
    public void shooting();
}

衍生品

public interface Bullet {
    public void load();
}

（2）创建接口对应实现类：

A类

public class AK implements Gun{

    @Override
    public void shooting() {
        System.out.println("shooting with AK");

    }

}

B类

public class M4A1 implements Gun {

    @Override
    public void shooting() {
        System.out.println("shooting with M4A1");

    }

}

A子弹类

public class AK_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with AK");
    }

}

B子弹类

public class M4A1
_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with M4A1");
    }

}

（3）创建工厂接口

public interface Factory {
    public Gun produceGun();
    public Bullet produceBullet();
}

（4）创建具体工厂

生产A和A衍生品的工厂

public class AK_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new AK();
    }

    @Override
    public Bullet produceBullet() {
        return new AK_Bullet();
    }

}

生产B和B衍生品的工厂

public class M4A1_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new M4A1();
    }

    @Override
    public Bullet produceBullet() {
        return new M4A1_Bullet();
    }

}

（5）测试

public class Test {

    public static void main(String[] args) {  

     Factory factory;
     Gun gun;
     Bullet bullet;

     factory =new AK_Factory();
     bullet=factory.produceBullet();
     bullet.load();
     gun=factory.produceGun();
     gun.shooting(); 

    }

}

# 3.建造者模式

## 3-1：什么是建造者模式

建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节.


为什么要用建造者模式（优点）？

1) 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。

3) 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

4) 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”

哪些情况不要用建造者模式（缺点）？

1) 产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

2) 产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。


建造者模式主要包含四个角色

Product（产品角色）：一个具体的产品对象。
Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。
ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。
Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

二 建造者模式分析
1 ) 一个典型的复杂对象其类代码示例如下：

public class Product 
{
    private String partA; //可以是任意类型
    private String partB;
    private String partC;
    //partA的Getter方法和Setter方法省略
    //partB的Getter方法和Setter方法省略
    //partC的Getter方法和Setter方法省略
}

2 ) 抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：

public abstract class Builder
{
    protected Product product=new Product();

    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();

    public Product getResult()
    {
        return product;
    }
} 

3 ) 具体建造者。实现抽象接口，构建和装配各个部件,实例代码如下：

public class ConcreteBuilder extends Builder{
    public void buildPartA(){
    ...
    }
    public void buildPartB(){
    ...
    }
    public void buildPartC(){
    ...
    }
}

4）指挥者类的代码示例如下：

建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。

public class Director
{
    private Builder builder;
    //1 构造方法的方式注入builder对象
    public Director(Builder builder)
    {
        this.builder=builder;
    }
    //2 set方法注入builder对象
    public void setBuilder(Builder builder)
    {
        this.builder=builer;
    }

    public Product construct()
    {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
} 

5 ) 客户端类代码片段：

在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。

……
Builder builder = new ConcreteBuilder();
Director director = new Director(builder);
Product product = director.construct();
…… 

# 4.原型模式

一 原型模式介绍
在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。

另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

孙悟空分身

1.1 定义
GOF给出的原型模式定义如下：

Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype. （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）

1.2 原型模式适用场景
我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。

使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。

1) 对象种类繁多，无法将他们整合到一个类的时候；

2) 难以根据类生成实例时；

3) 想解耦框架与生成的实例时。

如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。

1.3 模式分析
在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。

能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。

注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。

在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。

关于深克隆 和 浅克隆 的详细内容可以参考：详解Java中的clone方法

1.4 模式优缺点分析
原型模式的优点：

当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。
可以动态增加或减少产品类。
原型模式提供了简化的创建结构。
可以使用深克隆的方式保存对象的状态。
原型模式的缺点：

需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。
在实现深克隆时需要编写较为复杂的代码。
二 示例程序
下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。

类和接口一览表：

类和接口一览表

示例程序类图：


2.1 Product接口 （Prototype）
Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).
另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。

package prototype_pattern;

public interface Product extends Cloneable{
   //use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现。
    public abstract void use(String s);
    //creatClone方法是用于复制实例的方法
    public abstract Product creatClone();

}

2.2 Manager类（Client）
Manager类使用Product接口来复制实例。

Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重要的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。

package prototype_pattern;

import java.util.HashMap;

public class Manager {
    //保存实例的“名字”和“实例”之间的对应关系
    private HashMap<String, Product> showcase=new HashMap<String, Product>();
    //register方法将接收到的一组“名字”和“Product接口”注册到showcase中。这里Product是实现Product接口的实例，具体还未确定
    public void register(String name ,Product product){
        showcase.put(name, product);
    }
    public Product create(String productname){
        Product p=showcase.get(productname);
        return p.creatClone();
    }

}

2.3 MessageBox类（ConcreteProtorype）
装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。

package prototype_pattern;

public class MessageBox implements Product {
    //保存的是装饰方框使用的字符样式
    private char decochar;

    public MessageBox(char decochar) {
        this.decochar = decochar;
    }

    @Override
    public void use(String s) {
     int length=s.getBytes().length;
     for (int i = 0; i < length+4; i++) {
            System.out.print(decochar); 
    }
     System.out.println("");
     System.out.println(decochar+" "+s+" "+decochar);
     for (int i = 0; i < length+4; i++) {
        System.out.print(decochar);
    }
     System.out.println("");
    }

    //该方法用于复制自己
    @Override
    public Product creatClone() {
        Product p=null;
        try {
            p=(Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }

}

只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。

2.4 UnderlinePen类（ConcreteProtorype）
下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。

package prototype_pattern;

public class UnderlinePen implements Product {

    private char ulchar;

    public UnderlinePen(char ulchar) {
        this.ulchar = ulchar;
    }

    @Override
    public void use(String s) {
        int length = s.getBytes().length;
        System.out.println("\""+s+"\"");
        for (int i = 0; i <length+2; i++) {
            System.out.print(ulchar);

        }
        System.out.println("");
    }

    @Override
    public Product creatClone() {
        Product p=null;
        try {
            p=(Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }

}

2.5 Main类
Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。

package prototype_pattern;

public class Main {

    public static void main(String[] args) {
        Manager manager = new Manager();
        UnderlinePen underlinePen=new UnderlinePen('~');
        MessageBox mbox=new MessageBox('*');
        MessageBox sbox=new MessageBox('/');
        manager.register("Strong message", underlinePen);
        manager.register("Waring Box", mbox);
        manager.register("Slash Box", sbox);
        Product p1=manager.create("Strong message");
        p1.use("hello world");
        Product p2=manager.create("Waring Box");
        p2.use("hello world");
        Product p3=manager.create("Slash Box");
        p3.use("hello world");
    }

}



三 原型模式的角色分析
通过上面的例子，相信大家对于原型模式有了更进一步的认识，下面我们看看原型模式的几个登场角色。

3.1 Prototype（抽象原型类）
Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。

3.2 ConcretePrototype（具体原型类）
ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。

3.3 Client（客户类/使用者）
Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。

Prototype模式的类图：
Prototype模式的类图

四 原型模式的实际应用案例
(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。

(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将通过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。

(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。


# 5.代理模式
