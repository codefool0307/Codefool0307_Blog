# ------设计模式-----------------------------------------------------------------

# 1.单例模式

## 1.1：什么是单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 1.2：为什么要用单例模式呢？

这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

## 1.3：简单来说使用单例模式可以带来下面几个好处:

1. 对于频繁使用的对象，可以省略创建对象所花费的时间；
2. 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

## 1.3：什么可以破坏单例模式

1. 反射
2. 序列化与反序列化
   * 通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性

## 1-4：单例有哪几种实现方式

饿汉方式(线程安全）
饿汉式（枚举方式）
懒汉式（非线程安全和synchronized关键字线程安全版本)
懒汉式(双重检查加锁版本)
懒汉式（登记式/静态内部类方式）


## 1-5：饿汉方式(线程安全)

```java
    public class Singleton {
       //在静态初始化器中创建单例实例，这段代码保证了线程安全
        private static Singleton uniqueInstance = new Singleton();
        //Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例
        private Singleton(){}
        public static Singleton getInstance(){
            return uniqueInstance;
        }
    }
```

JVM在加载这个类时就马上创建此唯一的单例实例，

不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，

典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。

## 1-6：饿汉式（枚举方式）

这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 它自动支持序列化机制，绝对防止多次实例化 （如果单例类实现了Serializable接口，默认情况下每次反序列化总会创建一个新的实例对象，关于单例与序列化的问题可以查看这一篇文章《单例与序列化的那些事儿》），同时这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式。

public enum Singleton {
	 //定义一个枚举的元素，它就是 Singleton 的一个实例
    INSTANCE;  
    
    public void doSomeThing() {  
	     System.out.println("枚举方法实现单例");
    }  
}


## 1-6：懒汉式（非线程安全和synchronized关键字线程安全版本 ）

```java
public class Singleton {  
      private static Singleton uniqueInstance;  
      private Singleton (){
      }   
      //没有加入synchronized关键字的版本是线程不安全的
      public static Singleton getInstance() {
          //判断当前单例是否已经存在，若存在则返回，不存在则再建立单例
	      if (uniqueInstance == null) {  
	          uniqueInstance = new Singleton();  
	      }  
	      return uniqueInstance;  
      }  
 }
```

“ 懒汉式” 就是说单例实例在第一次被使用时构建，而不是在JVM在加载这个类时就马上创建此唯一的单例实例。

上面这种方式很明显是线程不安全的，如果多个线程同时访问getInstance()方法时就会出现问题。如果想要保证线程安全，一种比较常见的方式就是在getInstance() 方法前加上synchronized关键字，

```java
public static synchronized Singleton getInstance() {  
	      if (instance == null) {  
	          uniqueInstance = new Singleton();  
	      }  
	      return uniqueInstance;  
      }  
```
## 1-7：懒汉式(双重检查加锁版本)

利用双重检查加锁（double-checked locking），首先检查是否实例已经创建，如果尚未创建，“才”进行同步。这样以来，只有一次同步，这正是我们想要的效果。

```java
public class Singleton {

    //volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getInstance() {
       //检查实例，如果不存在，就进入同步代码块
        if (uniqueInstance == null) {
            //只有第一次才彻底执行这里的代码
            synchronized(Singleton.class) {
               //进入同步代码块后，再检查一次，如果仍是null，才创建实例
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```
## 1-8：懒汉式（登记式/静态内部类方式）

静态内部实现的单例是懒加载的且线程安全。

只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 
instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。

```java
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}   
```


## 单例模式里面为什么写了volatile

因为在new一个对象有几个步骤。1.看class对象是否加载，如果没有就先加载class对象，2.分配内存空间，初始化实例，3.调用构造函数，4.返回地址给引用。而cpu为了优化程序，可能会进行指令重排序，打乱这3，4这几个步骤，导致实例内存还没分配，就被使用了。

假设线程A执行到new Singleton()，开始初始化实例对象，由于存在指令重排序，这次new操作，先
把引用赋值了，还没有执行构造函数。这时时间片结束了，切换到线程B执行，线程B调用new 
Singleton()方法，发现引用不等于null，就直接返回引用地址了，然后线程B执行了一些操作，就
可能导致线程B使用了还没有被初始化的变量。

加了volatile之后，就保证new 不会被指令重排序。

# 2.工厂模式

## 2-1：工厂模式的定义

在基类中定义创建对象的一个接口，让子类决定实例化哪个类。

工厂方法让一个类的实例化延迟到子类中进行。

## 2-2：工厂模式的分类：

（1）简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。

（2）工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式；

（3）抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。

## 2-3：在开源框架中的使用

(1)Spring中通过getBean(“xxx”)获取Bean；


## 2-4：为什么要用工厂模式

(1) 解耦 ：把对象的创建和使用的过程分开

(2)降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用
到，那么就会有很多的重复代码。

(3) 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需
要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。

## 2-5：简单工厂例子

创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图.

（1）创建Shape接口
```java
public interface Shape {
    void draw();
}
```
（2）创建实现该接口的具体图形类

圆形
```java
public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}
```

长方形
```java
public class Rectangle implements Shape {
    public Rectangle() {
        System.out.println("Rectangle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Rectangle");
    }
}
```

正方形

```java
public class Square implements Shape {
    public Square() {
        System.out.println("Square");
    }

    @Override
    public void draw() {
        System.out.println("Draw Square");
    }
}
```

（3）创建工厂类：
```java
public class ShapeFactory {

    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}
```

（4）测试方法：

```java
public class Test {

    public static void main(String[] args) {

        // 获取 Circle 的对象，并调用它的 draw 方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();

        // 获取 Rectangle 的对象，并调用它的 draw 方法
        Shape rectangle = ShapeFactory.getShape("RECTANGLE");
        rectangle.draw();

        // 获取 Square 的对象，并调用它的 draw 方法
        Shape square = ShapeFactory.getShape("SQUARE");
        square.draw();
    }
}
```
但是

这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 
开放-封闭原则 。

## 2-6：使用反射机制改善简单工厂

```java
package factory_pattern;

/**
 * 利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端
 * 
 * @author Administrator
 *
 */
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
```

测试方法：
```java
package factory_pattern;

public class Test2 {
    public static void main(String[] args) {

        Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);
        circle.draw();

        Rectangle rectangle = (Rectangle) ShapeFactory2.getClass(factory_pattern.Rectangle.class);
        rectangle.draw();

        Square square = (Square) ShapeFactory2.getClass(factory_pattern.Square.class);
        square.draw();
    }

}
```

这种方式的虽然符合了 开放-关闭原则 ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 反射+配置文件 的形式来改善，这种方式使用的也是比较多的。

## 2-7：工厂方法模式

在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。

适用场景

1. 一个类不知道它所需要的对象的类：在工厂方��模式中，客户��不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

2. 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏

3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

工厂方法模式角色分配

抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应

工厂方法模式实例
对于简单工厂来说，我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。

(1)增加一个工厂接口：

public interface Factory {
    public Shape getShape();
}

（2）增加相关工厂类:

圆形工厂类

public class CircleFactory implements Factory {

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Circle();
    }

}

长方形工厂类

public class RectangleFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Rectangle();
    }

}

圆形工厂类

public class SquareFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Square();
    }

}

（3）测试：

public class Test {

    public static void main(String[] args) {
        Factory circlefactory = new CircleFactory();
        Shape circle = circlefactory.getShape();
        circle.draw();
    }

}

## 2-8：抽象工厂模式

在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。

适用场景

和工厂方法一样客户端不需要知道它所创建的对象的类。

需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品）

系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）

抽象工厂方法模式角色分配：

抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。

具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。

抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。

具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。
。

抽象工厂的工厂和工厂方法中的工厂有什么区别呢？

抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。


抽象工厂模式实例

我们现在这样考虑生产A类产品的工厂可以顺便生产A类产品的衍生品，生产B类产品的工厂可以顺便生产B类产品的衍生品。

抽象工厂模式实例

（1）创建相关接口：
类

public interface Gun {
    public void shooting();
}

衍生品

public interface Bullet {
    public void load();
}

（2）创建接口对应实现类：

A类

public class AK implements Gun{

    @Override
    public void shooting() {
        System.out.println("shooting with AK");

    }

}

B类

public class M4A1 implements Gun {

    @Override
    public void shooting() {
        System.out.println("shooting with M4A1");

    }

}

A子弹类

public class AK_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with AK");
    }

}

B子弹类

public class M4A1
_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with M4A1");
    }

}

（3）创建工厂接口

public interface Factory {
    public Gun produceGun();
    public Bullet produceBullet();
}

（4）创建具体工厂

生产A和A衍生品的工厂

public class AK_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new AK();
    }

    @Override
    public Bullet produceBullet() {
        return new AK_Bullet();
    }

}

生产B和B衍生品的工厂

public class M4A1_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new M4A1();
    }

    @Override
    public Bullet produceBullet() {
        return new M4A1_Bullet();
    }

}

（5）测试

public class Test {

    public static void main(String[] args) {  

     Factory factory;
     Gun gun;
     Bullet bullet;

     factory =new AK_Factory();
     bullet=factory.produceBullet();
     bullet.load();
     gun=factory.produceGun();
     gun.shooting(); 

    }

}

# 3.建造者模式

## 3-1：什么是建造者模式

建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节.


为什么要用建造者模式（优点）？

1) 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。

3) 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

4) 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”

哪些情况不要用建造者模式（缺点）？

1) 产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

2) 产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。


建造者模式主要包含四个角色

Product（产品角色）：一个具体的产品对象。
Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。
ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。
Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

二 建造者模式分析
1 ) 一个典型的复杂对象其类代码示例如下：

public class Product 
{
    private String partA; //可以是任意类型
    private String partB;
    private String partC;
    //partA的Getter方法和Setter方法省略
    //partB的Getter方法和Setter方法省略
    //partC的Getter方法和Setter方法省略
}

2 ) 抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：

public abstract class Builder
{
    protected Product product=new Product();

    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();

    public Product getResult()
    {
        return product;
    }
} 

3 ) 具体建造者。实现抽象接口，构建和装配各个部件,实例代码如下：

public class ConcreteBuilder extends Builder{
    public void buildPartA(){
    ...
    }
    public void buildPartB(){
    ...
    }
    public void buildPartC(){
    ...
    }
}

4）指挥者类的代码示例如下：

建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。

public class Director
{
    private Builder builder;
    //1 构造方法的方式注入builder对象
    public Director(Builder builder)
    {
        this.builder=builder;
    }
    //2 set方法注入builder对象
    public void setBuilder(Builder builder)
    {
        this.builder=builer;
    }

    public Product construct()
    {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
} 

5 ) 客户端类代码片段：

在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。

……
Builder builder = new ConcreteBuilder();
Director director = new Director(builder);
Product product = director.construct();
…… 

# 4.原型模式

一 原型模式介绍
在面向对象系统中，使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象。

另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

孙悟空分身

1.1 定义
GOF给出的原型模式定义如下：

Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype. （使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。）

1.2 原型模式适用场景
我们现在一般会使用new关键字指定类名生成类的实例（PS：我们以前使用java.lang.Cloneable的一个很大原因是使用new创建对象的速度相对来说会慢一些，随着JVM性能的提升，new的速度和Object的clone（）方法的速度差不多了。）。

使用new关键字创建类的时候必须指定类名，但是在开发过程中也会有“在不指定类名的前提下生成实例”的需求。例如，在下面这些情况下，就需要根据现有的实例来生成新的实例。

1) 对象种类繁多，无法将他们整合到一个类的时候；

2) 难以根据类生成实例时；

3) 想解耦框架与生成的实例时。

如果想要让生成实例的框架不再依赖于具体的类，这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。

1.3 模式分析
在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。

能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。

注意： `java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。

在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆 和 浅克隆 。

关于深克隆 和 浅克隆 的详细内容可以参考：详解Java中的clone方法

1.4 模式优缺点分析
原型模式的优点：

当创建新的对象实例较为复杂时，使用原型模式可以���化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。
可以动态增加或减少产品类。
原型模式提供了简化的创建结构。
可以使用深克隆的方式保存对象的状态。
原型模式的缺点：

需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。
在实现深克隆时需要编写较为复杂的代码。
二 示例程序
下面示例程序的作用是将字符串放入方框中显示出来或者是加了下划线显示出来。

类和接口一览表：

类和接口一览表

示例程序类图：


2.1 Product接口 （Prototype）
Product接口是复制功能接口，该接口继承了java.lang.Cloneable(只有实现了该接口的类的实例才可以调用clone()方法复制实例,否则会抛出异常).
另外需要注意：`java.lang.Cloneable 只是起到告诉程序可以调用clone方法的作用，它本身并没有定义任何方法。

package prototype_pattern;

public interface Product extends Cloneable{
   //use方法是用于“使用”的方法，具体怎么“使用”，则被交给子类去实现。
    public abstract void use(String s);
    //creatClone方法是用于复制实例的方法
    public abstract Product creatClone();

}

2.2 Manager类（Client）
Manager类使用Product接口来复制实例。

Product接口以及Manager类的代码完全没有出现在MessageBox类和UnderlinePen类的名字，因此这意味着我们可以独立地修改Product接口以及Manager类，不受MessageBox类和UnderlinePen类的影响。这是非常重���的，因为 一旦在类中使用到了别的类名，就意味着该类与其他类紧密的地耦合在了一起 。在Manager类中，并没有写明具体的类名， 仅仅使用了Product这个接口名。也就是说，Product接口成为了连接Manager类与其他具体类之间的桥梁。

package prototype_pattern;

import java.util.HashMap;

public class Manager {
    //保存实例的“名字”和“实例”之间的对应关系
    private HashMap<String, Product> showcase=new HashMap<String, Product>();
    //register方法将接收到的一组“名字”和“Product接口”注册到showcase中。这里Product是实现Product接口的实例，具体还未确定
    public void register(String name ,Product product){
        showcase.put(name, product);
    }
    public Product create(String productname){
        Product p=showcase.get(productname);
        return p.creatClone();
    }

}

2.3 MessageBox类（ConcreteProtorype）
装饰方框样式的具体原型，实现了Product接口，实现复制现有实例并生成新实例的方法。

package prototype_pattern;

public class MessageBox implements Product {
    //保存的是装饰方框使用的字符样式
    private char decochar;

    public MessageBox(char decochar) {
        this.decochar = decochar;
    }

    @Override
    public void use(String s) {
     int length=s.getBytes().length;
     for (int i = 0; i < length+4; i++) {
            System.out.print(decochar); 
    }
     System.out.println("");
     System.out.println(decochar+" "+s+" "+decochar);
     for (int i = 0; i < length+4; i++) {
        System.out.print(decochar);
    }
     System.out.println("");
    }

    //该方法用于复制自己
    @Override
    public Product creatClone() {
        Product p=null;
        try {
            p=(Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }

}

只有类自己（或是它的子类）能够调用Java语言中定义的clone方法。当其他类要求复制实例时，必须先调用createClone这样的方法，然后在该方法内部在调用clone方法。

2.4 UnderlinePen类（ConcreteProtorype）
下划线样式的具体原型，实现了Product接口，用于实现复制现有实例并生成新实例的方法。UnderlinePen类的实现几乎和MessageBox类一样，不同的可能只是use方法的实现。

package prototype_pattern;

public class UnderlinePen implements Product {

    private char ulchar;

    public UnderlinePen(char ulchar) {
        this.ulchar = ulchar;
    }

    @Override
    public void use(String s) {
        int length = s.getBytes().length;
        System.out.println("\""+s+"\"");
        for (int i = 0; i <length+2; i++) {
            System.out.print(ulchar);

        }
        System.out.println("");
    }

    @Override
    public Product creatClone() {
        Product p=null;
        try {
            p=(Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }

}

2.5 Main类
Main类首先生成Manager实例。接着，在Manager实例中通过`register方法注册了UnderlinePen类的实例（带名字）和MessageBox类的实例（带名字）。

package prototype_pattern;

public class Main {

    public static void main(String[] args) {
        Manager manager = new Manager();
        UnderlinePen underlinePen=new UnderlinePen('~');
        MessageBox mbox=new MessageBox('*');
        MessageBox sbox=new MessageBox('/');
        manager.register("Strong message", underlinePen);
        manager.register("Waring Box", mbox);
        manager.register("Slash Box", sbox);
        Product p1=manager.create("Strong message");
        p1.use("hello world");
        Product p2=manager.create("Waring Box");
        p2.use("hello world");
        Product p3=manager.create("Slash Box");
        p3.use("hello world");
    }

}



三 原型模式的角色分析
通过上面的例子，相信大家对于原型模式有了更进一步的认识，下面我们看看原型模式的几个登场角色。

3.1 Prototype（抽象原型类）
Product角色负责定义用于复制现有实例来生成新实例的方法。在示例程序中的Product接口就是该角色。

3.2 ConcretePrototype（具体原型类）
ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。在示例程序中，MessageBox和UnderlinePen都是该角色。

3.3 Client（客户类/使用者）
Client角色负责使用复制实例的方法生成新的实例。在示例程序中，Manager类扮演的就是该角色。

Prototype模式的类图：
Prototype模式的类图

四 原型模式的实际应用案例
(1) 原型模式应用于很多软件中，如果每次创建一个对象要花大量时间，原型模式是最好的解决方案。很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的应用，复制得到的对象与原型对象是两个类型相同但内存地址不同的对象，通过原型模式可以大大提高对象的创建效率。

(2) 在Struts2中为了保证线程的安全性，Action对象的创建使用了原型模式，访问一个已经存在的`Action对象时将���过克隆的方式创建出一个新的对象，从而保证其中定义的变量无须进行加锁实现同步，每一个Action中都有自己的成员变量，避免Struts1因使用单例模式而导致的并发和同步问题。

(3) 在Spring中，用户也可以采用原型模式来创建新的bean实例，从而实现每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。


# 5.代理模式

## 5-1：什么是代理模式

我们使用代理对象来代替对真实对象(real object)的访问，

这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

## 5-2：代理模式实现方式-静态代理

静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），

非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）

且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，

日常开发几乎看不到使用静态代理的场景。

从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。

静态代理实现步骤:

定义一个接口及其实现类；
创建一个代理类同样实现这个接口
将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。

这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
```java
1.定义发送短信的接口

public interface SmsService {
    String send(String message);
}
2.实现发送短信的接口

public class SmsServiceImpl implements SmsService {
    public String send(String message) {
        System.out.println("send message:" + message);
        return message;
    }
}
3.创建代理类并同样实现发送短信的接口

public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }

    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}
4.实际使用

public class Main {
    public static void main(String[] args) {
        SmsService smsService = new SmsServiceImpl();
        SmsProxy smsProxy = new SmsProxy(smsService);
        smsProxy.send("java");
    }
}
运行上述代码之后，控制台打印出：

before method send()
send message:java
after method send()
可以输出结果看出，我们已经增加了 SmsServiceImpl 的send()方法。
```

## 5-3：动态代理

我们不需要针对每个目标类都单独创建一个代理类，

并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。

从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。



## 5-4：静态代理和动态代理的对比
灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

# 6.适配器模式

当你想使用一个已经存在的类，而它的接口不符合你的需求，或者你想创建一个可重用的类（与不兼容接口无关的类），这时候可以考虑使用适配器模式。同时它也是一种包装模式，它与装饰模式同样具有包装的功能。

## 6-2：优缺点

优点

可以让任何两个没有关联的类一起运行
提高了类的复用，想使用现有的类，而此类的接口标准又不符合现有系统的需要。通过适配器模式就可以让这些功能得到更好的复用。
增加了类的透明度，客户端只关注结果
使用适配器的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
缺点

过多使用会导致系统凌乱，追溯困难（内部转发导致，调用A适配成B）

## 6-3：适用场景

系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

## 6-4：类适配器

```java
1.首先定义M4DataLine 代表是Micro USB，我们目的就是通过适配器能够用米4数据线连接米5手机

class M4DataLine {
    public void connection() {
        System.out.println("使用小米4数据线连接...");
    }
}
2.定义客户端使用的接口，与业务相关

interface Target {
    void connection();
}

class M5DataLine implements Target {
    @Override
    public void connection() {
        System.out.println("使用小米5数据线连接...");
    }
}
3.创建适配器类，继承了被适配类，同时实现标准接口

class M5DataLineAdapter extends M4DataLine implements Target {

    @Override
    public void connection() {
        System.out.println("插入 type-c 转接头");
        super.connection();
    }
}
4.客户端代码，测试

public class AdapterMain {

    public static void main(String[] args) {
        Target target = new M5DataLine();
        target.connection();

        Target adapter = new M5DataLineAdapter();
        adapter.connection();
    }
}
5.结果

使用小米5数据线连接...
插入 type-c 转接头
使用小米4数据线连接...


```

## 6-5:对象适配器


```java
创建适配器类，实现标准接口，将这个调用委托给实现新接口的对象来处理

class M5DataLineAdapter implements Target {

    private Target target;

    public M5DataLineAdapter(Target target) {
        this.target = target;
    }

    @Override
    public void connection() {
        System.out.println("插入 type-c 转接头");
        target.connection();
    }
}

public class AdapterMain {

    public static void main(String[] args) {
        // 使用特殊功能类，即适配类
        Target adapter = new M5DataLineAdapter(new M5DataLine());
        adapter.connection();
    }
}

```
## 6-6：区别

类适配器：对象继承的方式，静态的定义。

对象适配器：依赖于对象的组合，都是采用对象组合的方式，也就是对象适配器实现的方式。

## 6-7：使用

### 6-7-1：JDK使用

使用适配器模式的类

java.util.Arrays#asList()
java.io.InputStreamReader(InputStream)
java.io.OutputStreamWriter(OutputStream)
Java I/O 库大量使用了适配器模式，如 ByteArrayInputStream 是一个适配器类，它继承了 InputStream 的接口，并且封装了一个 byte 数组。换言之，它将一个 byte 数组的接口适配成 InputStream 流处理器的接口。

在 OutputStream 类型中，所有的原始流处理器都是适配器类。ByteArrayOutputStream 继承了 OutputStream 类型，同时持有一个对 byte 数组的引用。它一个 byte 数组的接口适配成 OutputString 类型的接口，因此也是一个对象形式的适配器模式的应用。

FileOutputStream 继承了 OutputStream 类型，同时持有一个对 FileDiscriptor 对象的引用。这是一个将 FileDiscriptor 接口适配成 OutputStream 接口形式的对象型适配器模式。

Reader 类型的原始流处理器都是适配器模式的应用。StringReader 是一个适配器类，StringReader 类继承了 Reader 类型，持有一个对 String 对象的引用。它将 String 的接口适配成 Reader 类型的接口。

### 6-7-2：Spring 中使用适配器模式的典型应用
在 Spring 的 AOP 里通过使用的 Advice（通知）来增强被代理类的功能。Spring 实现这一 AOP 功能的原理就使用代理模式（1、JDK 动态代理。2、CGLib 字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类，并在代理类的方法前，设置拦截器，通过执行拦截器中的内容增强了代理方法的功能，实现的面向切面编程。

Advice（通知）的类型有：BeforeAdvice、AfterReturningAdvice、ThrowSadvice 等。每个类型 Advice（通知）都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。Spring 需要将每个 Advice（通知）都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换。























# -------------算法-----------------------------------------------------------

# 1.排序算法








# 1. 布隆过滤器

## 1-1：
它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。
它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。

## 1-2：布隆过滤器的原理介绍

当一个元素加入布隆过滤器中的时候，

   1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
   2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

当我们需要判断一个元素是否存在于布隆过滤器的时候，：

   1. 对给定元素再次进行相同的哈希计算；
   2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，
      那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

## 1-3：布隆过滤器使用场景

1. 判断给定数据是否存在：
       比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5亿以上！）、 
      防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。

## 1-4：通过 Java 编程手动实现布隆过滤器

1. 一个合适大小的位数组保存数据
2. 几个不同的哈希函数
3. 添加元素到位数组（布隆过滤器）的方法实现
4. 判断给定元素是否存在于位数组（布隆过滤器）的方法实现。


# 2.线性数据结构

线性表，栈，队列，双队列，串

## 2-2：数组与链表区别

1. 数组的优点
            随机访问性强
            查找速度快
1. 数组的缺点
            插入和删除效率低
            可能浪费内存
            内存空间要求高，必须有足够的连续内存空间。
            数组大小固定，不能动态拓展

2. 链表的优点
            插入删除速度快
            内存利用率高，不会浪费内存
            大小没有固定，拓展很灵活。
2. 链表的缺点
           不能随机查找，必须从第一个开始遍历，查找效率低


# 3.树

## 3-1：红黑树

红黑树比较传统的定义是需要满足以下五个特征：
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
其特点在于给数的每一个节点加上了颜色属性，在插入的过程中通过颜色变换和节点旋转调平衡。

## 19-7：AVL树


avl树即平衡树，他对二叉树做了改进，在我们每插入一个节点的时候，

必须保证每个节点对应的左子树和右子树的树高度差不超过1。如果超过了就对其进行调平衡，

无非就是四个操作——左旋，左旋再右旋，右旋再左旋。

最终可以是二叉树左右两边的树高相近，这样我们在查找的时候就可以按照二分查找来检索，

也不会出现退化成链表的情况。

# 5.图

# 6.LRU

## 6-1：LRU实现

```java
class DLinkedNode {
    String key;
    int value;
    DLinkedNode pre;
    DLinkedNode post;
}
LRU Cache
public class LRUCache {
   
    private Hashtable<Integer, DLinkedNode>
            cache = new Hashtable<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.pre = null;

        tail = new DLinkedNode();
        tail.post = null;

        head.post = tail;
        tail.pre = head;
    }

    public int get(String key) {

        DLinkedNode node = cache.get(key);
        if(node == null){
            return -1; // should raise exception here.
        }

        // move the accessed node to the head;
        this.moveToHead(node);

        return node.value;
    }


    public void set(String key, int value) {
        DLinkedNode node = cache.get(key);

        if(node == null){

            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.value = value;

            this.cache.put(key, newNode);
            this.addNode(newNode);

            ++count;

            if(count > capacity){
                // pop the tail
                DLinkedNode tail = this.popTail();
                this.cache.remove(tail.key);
                --count;
            }
        }else{
            // update the value.
            node.value = value;
            this.moveToHead(node);
        }
    }
    /**
     * Always add the new node right after head;
     */
    private void addNode(DLinkedNode node){
        node.pre = head;
        node.post = head.post;

        head.post.pre = node;
        head.post = node;
    }

    /**
     * Remove an existing node from the linked list.
     */
    private void removeNode(DLinkedNode node){
        DLinkedNode pre = node.pre;
        DLinkedNode post = node.post;

        pre.post = post;
        post.pre = pre;
    }

    /**
     * Move certain node in between to the head.
     */
    private void moveToHead(DLinkedNode node){
        this.removeNode(node);
        this.addNode(node);
    }

    // pop the current tail.
    private DLinkedNode popTail(){
        DLinkedNode res = tail.pre;
        this.removeNode(res);
        return res;
    }
}
```

# 9 排序算法
## 9.0 排序算法综述
![avatar](./assets/9-1.jpg)

## 9.1 冒泡排序

冒泡排序是最原始的排序算法，其主导思想就是：

1. 第一趟排序，第1个和第2个比较，比较完成之后，交换两者顺序，第2个和第三个比较，比较完成之后，交换两者顺序...直到比较到最后一个数值，这样最后一个数值就在最后一位了
2. 那你的最后一位已经定了，那就在从确定n-1位确定就好了

关键在于：

1. 两两比较怎么做？
2. 如何做到长度控制？

![avatar](https://media.giphy.com/media/iEpOBIQKVDmGFeP8F2/giphy.gif)


```java
public class BubbleSort {
    public static void main(String[] args) {
          int[] arr={2,4,1,7,5,3,9};
          sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }

    public static void sort(int[] arr){
        if (arr==null || arr.length<2){
            return;
        }
        //第一个循环主要是进行0~N-1，0~N-2.......
        for (int i = arr.length-1; i >0; i--) {
            //在0~x之间进行遍历两两比较
            //  01  12  23  34  45  
            for (int j = 0; j < i; j++) {
                if (arr[j]>arr[j+1]){
                    swap(arr,j,j+1);
                }
            }
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

## 9.2 选择排序
基本思路：假设数组为 [1....n]，每一趟，<font color=red>选择一个值</font>与<font color=red>数组剩下的值</font>进行比较，<font color=#2fe32>互换最小值的索引</font>并<font color=#f7873>交换</font>

```java
public class SelectSort {
    public static void main(String[] args) {
        int[] arr={2,4,1,7,5,3,9};
        sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }
    public static void sort(int[] arr){
        for (int i = 0; i < arr.length; i++) {
            int min=i;
            for (int j = i+1; j < arr.length ; j++) {
                min =arr[min] < arr[j]?min:j;
            }
            swap(arr,i,min);
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```



## 9.3 插入排序

基本思路：左看看右看看
假设数组为 [1....n]，选出一个数值与<font color=green>左侧的值</font><font color=blue>比较交换</font>直到<font color=red>越界为止</font>

![avatar](./assets/9-2.jpg)
此图借鉴了这位大佬的辛苦劳作，再次说明
https://blog.csdn.net/zxm317122667/article/details/83344178


```java
ublic class InsertionSort {
    public static void main(String[] args) {
        int[] arr={2,4,1,7,5,3,9};
        Sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }
    public static void Sort(int[] arr){
        //第一个for循环是找到一个基准数值
        for (int i = 1; i < arr.length; i++) {
            //第二个for循环是把基准书左侧的所有数值进行比较并交换
            for (int j = i-1; j >= 0 && arr[j]>arr[j+1]; j--) {
                swap(arr,j,j+1);
            }
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

## 9.4 归并排序

### 9.4.1 整体思路

左边排序，右边排序--->整体排序

1. 首先将数组分割，分为左右两部分
2. 对A部分的指针的元素与B部分指针元素进行比较
3. 堆排序好的数组放置在辅助数组中，最后放置到原数组


### 9.4.2 leetcode 912

```java
class Solution {
   public int[] sortArray(int[] nums) {
          if (nums==null || nums.length<2){
              return nums;
          }
        process(nums,0,nums.length-1);
        return nums;
    }
    public void process(int[] nums,int L ,int R){
        if (L==R){
            return;
        }
        int mid=L+((R-L)>>1);
        process(nums,L,mid);
        process(nums,mid+1,R);
        merge(nums,L,R,mid);
    }

    public void merge(int[] nums,int L,int R,int mid){
        int p1=L;
        int p2=mid+1;
        int[] help = new int[R-L+1];
        int i=0;

        while(p1<=mid && p2<=R){
            help[i++]=nums[p1]<=nums[p2]?nums[p1++]:nums[p2++];
        }
        while(p1<=mid){
            help[i++]=nums[p1++];
        }
        while(p2<=R){
            help[i++]=nums[p2++];
        }

        for (int j = 0; j < help.length; j++) {
            nums[L+j]=help[j];
        } 
    }
}
```

1. 那么这个复杂度是怎样的呢？

首先就利用递归的公式了

T(N) = 2T（N/2）+o(N)

log(2,2)=1,则复杂度为O（NlogN）


### 9.4.3 归并排序扩展——小和问题

定义：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和

例如：一个数组[1,3,4,2,5] ,1右边比1大的有4个，就记录4个1（4x1）以此类推

```java
package Sort;
public class Demo200809_MergeSort_xiaohe {
    public static void main(String[] args) {
        int[] arr={1,3,4,2,5};
        int i = mergesort(arr);
        System.out.println(i);
    }

    public static int mergesort(int[] nums){
        if (nums==null || nums.length<2){
            return 0;
        }
       return process(nums,0,nums.length-1);
    }
    public static int process(int[] nums,int L,int R){
       if (L==R){
           return 0;
       }
       int mid=L+((R-L)>>1);
       return process(nums,L,mid)+process(nums,mid+1,R)+merge(nums,L,R,mid);
    }
    public static int merge(int[] nums,int L,int R,int mid){
        int p1=L;
        int p2=mid+1;
        int i=0;
        int[] help = new int[R-L+1];
        int res=0;

        while(p1<=mid && p2<=R){
            //因为左侧指针<右侧指针，那么左侧指针<右侧所有的数
            //为什么呢？因为层级排序中，底层已经排序完成了，
            //比如说 7 2 3 6 8 3 4 9
            //  7 2 3 6 ---->  7 2  和   3  6 ----> 7和2    3和6
            //这样7与2比较 7比2大，不用，没有小和，交换
            //3和6,3<6,那么3与6就不进行交换了
            //所以已经交换完成了
            //-----------------------------------------------------------------------
            //如果是  2  和   7  的话，那么将要进行判断个数了，但是怎么判断呢?
            //那么通过数个数的形式应该是最好的了，如下就可以了
            res += nums[p1]<nums[p2]?(R-p2+1)*nums[p1]:0;
            help[i++]=nums[p1]<nums[p2]?nums[p1++]:nums[p2++];
        }

        while(p1<=mid){
            help[i++]=nums[p1++];
        }

        while(p2<=R){
            help[i++]=nums[p2++];
        }

        for (int j = 0; j < help.length; j++) {
            nums[L+j]=help[j];
        }
        return res;
    }
}

```

### 9.4.4 归并排序扩展——逆序对

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，




## 9.5 堆排序

### 9.5.1 堆原理

~~堆结构就是用数组实现的完全二叉树结构~~

这样看，太啰嗦了，就这么说吧，你可以把堆想象成完全二叉树，但是实际上，它是一个数组

什么是完全二叉树，可以查看[二叉树](./3-二叉树.md)

但是，说一下完全二叉树的简单易学的概念：从左到右<font color="#FF0000">依次</font>变满的，如图：

![avatar](http://code.clouddn.com/02_10_09_study_al_sort_duipaixu_01.jpg)

一定要记得是从左到右依次填满，才可以的！！！！！

这个只不过是一个理想的形式

比如说一个数组

6 4 8

那么我们就把他想象成一个完全二叉树

那么二叉树就如下下面这个动图

![原理](https://media.giphy.com/media/l0QtDoCyBs5oyroBOW/giphy.gif)

那么通过这个图我们发现了一个规律：
父节点：(i-1)/2
左孩子：2*i+1
右孩子：2*i+2

那么是通过 有效区 这个概念来进行控制他的范围的

根据这两概念（有效区、父子节点），比如说这个数组，如果有效区是size=3，

那么我们肯定6是头节点，那么哪个是他的左孩子根据公式就是2*i+1--->数组坐标是1的元素

![avatar](http://code.clouddn.com/02_10_09_study_al_sort_duipaixu_02.jpg)

好了，那么我么通过堆就发现了这么两个概念

1. 父子关系，建立父子关系
2. 有效区，控制范围


那么想到堆，就会想到<font color="#FF0000">大根堆</font>与<font color="#FF0000">小根堆</font>

那么什么是大根堆呢：

每一颗子树的最大值一定是子树的头节点，并且扩展到整个二叉树中才能是大根堆，如：

![avatar](http://code.clouddn.com/02_10_09_study_al_sort_duipaixu_03.jpg)

本次主要介绍大根堆方式（小根堆与大根堆基本方式一致）

开始进入正题，

还是以上面的例子为主，由于左右两个孩子是4和8，但是他确实不是大根堆，我就想把它变成大根堆，怎么变呢？

就把孩子与父节点进行交换

![avatar](http://code.clouddn.com/02_10_09_study_al_sort_duipaixu_04.jpg)

假设上面这个数组，添加了几个元素

6 4 8 5 9

那么继续按照上面的思路，

![avatar](http://code.clouddn.com/02_10_09_study_al_sort_duipaixu_05.jpg)

那么规定这个过程就是<font color=red size='5'>heapinsert过程</font>

当前节点与父节点进行比较

```java
public static void heapInsert(int[] arr,int index){
        while(arr[index]>arr[(index-1)/2]){
            swap(arr,index,(index-1)/2);
            index=(index-1)/2;//停止的关键在于idnex为0，
                              //并且不在大于了（尾----头）
        }
    }
```

如果出现在某个位置元素突然发生变化（在往上走的过程中发生变化），那么我们就需要先比较左右孩子，再根据最大的孩子与父节点进行比较

那么这个过程就是heapify的过程

```java
public static void heapify(int[] arr,int index,int size){
        int left=2*index+1;
        //左孩子小于size，右孩子不一定小于size，主要是防止右孩子越界
        while(left<size){
            //两个孩子比较，但是一定要保证不越界
            int largest= left+1 < size && arr[left+1]>arr[left]
                    ? arr[left+1]
                    : arr[left];
            //最大的孩子与父进行比较
            largest=arr[largest]<arr[index]?index:largest;

            if (largest==index){
                break;
            }
            //互换元素
            swap(arr,index,largest);
            //然后，不断往上走
            index=largest;
            left=2*index+1;
        }
    }
```


那么堆排序就是思路：
1. 首先变成大根堆，但是呢无法完成左右孩子的大小判断
2. 开始解决左右孩子无法判断的问
   - 首先进行同辈比较--heapify
   - 其次交换首尾元素，通过有效区把数值进行排除操作
   
![heapify](https://media.giphy.com/media/lQfiZgTXlzm23HMUHf/giphy.gif)


```java
package Sort;
import java.util.Arrays;
public class Demo200811_HeapSort {
    public static void main(String[] args) {
          int[] a={1,4,0,2,7};
        System.out.println(Arrays.toString(a));

        heapsort(a);

        System.out.println(Arrays.toString(a));

    }

    public static void heapsort(int[] nums){
        if (nums==null ||nums.length<2){
            return;
        }
         //变成大根堆
        for (int i = 0; i < nums.length; i++) {
            HeapInsert(nums,i);
        }
        //左右两个孩子怎么比较呢？
        int size=nums.length;
        swap(nums,0,--size);
        while (size>0){
            Heapify(nums,0,size);
            swap(nums,0,--size);
        }
    }


    //把数组排序成大根堆的形式
    public static void HeapInsert(int[] nums,int index){
        while (nums[index]>nums[(index-1)/2]){
            swap(nums,index,(index-1)/2);
            index=(index-1)/2;
        }

    }
    //数组改变的话，进行判断
    public static void Heapify(int[] nums,int index,int heapsize){
        int left=2*index+1;

        while(left<heapsize){
            //比较左右两个孩子哪个大哪个小
            int max=nums[left]<nums[left+1] && left+1<heapsize
                    ?left+1
                    :left;//为什么是这种写法？
            //那么较大值，就可以与父节点进行比较了
            max=nums[max]>nums[index]?max:index;

            //但是如果父子相等，那么退出就好了
            if (max==index) {break;}

            //然后比较完成后开始互换元素
            swap(nums,index,max);

            //这样连接起来
            index=max;     //看箭头方向确定左右侧
            left=2*index+1;
        }
    }

    public static void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
}


```

## 9.6 快速排序


快排的主要思路就是

首先根据选择方式，将区分值放入一侧。根据所包含的范围进行区分值交换

1. 当前数<区分值  
   
   * 当前数与≤区下一个数换  ≤区右移，指针右移

2. 当前数=区分值 
   
   * 指针直接跳下一个

3. 当前数>区分值  
   
   * 当前数与>区前一个数换  >区左移，指针不动

<br>

那么这个<font color=red>数</font>就有好几种选择方式，

方式1. 选择最后一个数作为区分值，就是上面这个程序

方式2. 选择有边界作为区分值，每次都是右边界

方式3. 随机选择一个数，复杂度为O（N*logN）

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr={3,6,1,4,4,6,2,8,3,8,10};
        quicksort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void quicksort(int[] arr){
        if (arr==null || arr.length<2){
            return;
        }
        process(arr,0,arr.length-1);
    }
    public static void process(int[] arr,int L,int R){
     if (L<R){
         swap(arr, L+(int) (Math.random()*(R-L+1)),R);//把选出来的数值放在最后
         int[] p = partition2(arr, L, R);
         process(arr,L,p[0]-1);
         process(arr,p[1]+1,R);
     }

    }
    public static int[] partition2(int[] arr,int L,int R){
        int less=L-1;
        int more=R;
        while (L<more){
            if (arr[L]<arr[R]){
                //为什么是++less的原因，主要是我先把<区下一个进行交换，然后进行跳转
                //如果是less++就是先使用less这个数值，然后在进行+操作
                swap(arr,++less,L++);
            }else if(arr[L]>arr[R]){
                swap(arr,--more,L);
            }else {
                L++;
            }
        }
        swap(arr,more,R);//交换的目的是把随机选择的数给换回来
        return new int[]{less+1,more};//这样可以把=区域的两个区间确定下来
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

## 9.7 比较器

比较器在C++是冲在比较运算符，Java中叫比较器

比较器主要是用请详见[4-集合]()

## 9.8 桶排序

### 9.8.0 综述

桶排序分为了

* <font color=red>计数排序</font>

* <font color=yellow>基数排序</font>

### 9.8.1 计数排序

假设有一个数组arr=[17,23,0,96,17,23],其中所有数据的范围在0~200之间，那么我就创造一个辅助数组help=[],共有201个
元素，

那么我的这个辅助数组不是用来存储数字，而是存储arr某个数字出现的频率，

比如说下图，

![avatar](http://code.clouddn.com/02_10_09_study_sort_tongpaixu_01.jpg)

这个辅助数组干嘛呢，他就在记录arr每个数字在help数组出现的频率

### 9.8.2 基数排序

基数排序的基本条件：样本是以十进制的非负数

比如说一个数组[13,17,9,23,27,100]，思路：

1. 确定好最大位数，就遍历几遍
2. 根据每位数进行计数排序
3. 确定好<=0元素个数一共有几个，<=1元素个数一共有几个。。。。。。。<=9桶中元素个数
   一共有几个
   * 目的主要是在放入桶的时候，确定好每个桶有几个数值，比如说第2桶，他不就是<=2个数-<=1个数<font color='red'>（后话，不是这一步的目的）</font>
4. 从右→左判断arr原数组中每一个数字个位数数值

```java
public static void radixsort(int[] nums,int L ,int R,int digit){//digit表示最大数一共有几位
        final int raidx=10;//表示十进制

        //表示辅助空间大小
        int[] bucket = new int[R - L + 1];

        int i=0;
        int j=0;

        //第一步、根据最大数个数进行遍历
        for (int d = 1; d <= digit; d++) {
            //第二步、进行计数排序，分别对每个数值的个位放入桶（数组）中，再将十位百位放入
            //首先放入个位，如何放置？
            //那么就靠这个getDigit函数，然后按照计数排序的思路，进行入桶操作
            int[] count = new int[raidx];
            for (i = L; i < R; i++) {
                //开始个位入桶，挨个来吧，27---7，23---3等等
                j = getDigit(nums[i], d);
                //入桶统计
                count[j]++;
            }
            //第三步、入完桶，看看<=0元素个数一共有几个，<=1元素个数一共有几个。。。。。。。<=9桶中元素个数
            for (i = 1; i < raidx; i++) {
                count[i]=count[i]+count[i-1];
            }
            //比如说count桶 [0 1 2 3 4 5 6 7 8 9]
            //    <=0有几个  1 4 6 6 6 6 6 6 6 6


            //第四步、进行排序操作
            //比如说，[022 021 032 031 001 100]
            for (i = R; i >=L ; i--) {
              j = getDigit(nums[i], d); //判断每个数值的数位是多少，比如说001的个位数是1，
              //看看<=1所有的桶中元素个数数量（看上面的for循环），看了看有4个，
              //然后看看他是在哪个范围上（0-3范围（这个范围是根据计数个数确定的）），
              ///而我要倒出元素，就需要先把大范围的数值倒出来，也就是把3倒出来
              bucket[count[j]-1]=nums[i];
              count[j]--;//计数完毕，就消除
            }
            //从桶中放入数组中
            for (i = L,j=0; i <=R ; i++,j++) {
                nums[i]=bucket[j];
            }
        }
    }
    //主要完成的工作就是判断我用的是这个数值的哪一位数字
    //比如说27,给定的d=1，d=2，d=3，
    //那可以判定出他的个位数是7，十位数是2，百位数是0（因为要按照最高位进行补齐操作）
    public static int getDigit(int x,int d){
        //pow函数，是a^b
        return ((x/((int)Math.pow(10,d-1)))%10);
    }
```

注：

再次还有一个问题，你是怎么确定出他是几位数的？

```java


```


## 9.9 总结

![avatar](http://code.clouddn.com/02_10_09_study_sort_zongjie_01.jpg)


## 9.10 topk

在N个数的无序序列中找出最大的K个数，而其中的N往往都特别大

方法一、利用堆实现

思路：只找到TopK，不排序TopK。

先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。

接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，

如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。

直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。

## 9.11 如何评价算法的好坏

稳定性

## 整型转字节

整型转字节
public int Byte2Int(Byte[]bytes) {
return (bytes[0]&0xff)<<24
| (bytes[1]&0xff)<<16
| (bytes[2]&0xff)<<8
| (bytes[3]&0xff);
}

## 数组与链表的区别

（1）存储位置上：

数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；

（2）存储空间上：

链表存放的内存空间可以是连续的，也可以是不连续的，数组则是连续的一段内存空间。一般情况下存放相同多的数据数组占用较小的内存，而链表还需要存放其前驱和后继的空间。

（3）长度的可变性：

链表的长度是按实际需要可以伸缩的，而数组的长度是在定义时要给定的，如果存放的数据个数超过了数组的初始大小，则会出现溢出现象。

（4）按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　

（5）按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　

（6）插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　

（7）空间分配方面：

数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败； 即数组从栈中分配空间,，对于程序员方便快速,但自由度小。链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；即链表从堆中分配空间, 自由度大但申请管理比较麻烦。


## 链表应用场景

数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建的线性表较稳定。

链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。



## 反转链表

方法一：递归法
```java
public Node reverse(Node head) {
    if (head == null || head.next == null)
        return head;
    Node temp = head.next;
    Node newHead = reverse(head.next);
    temp.next = head;
    head.next = null;
    return newHead;
}
```
递归实质上就是系统帮你压栈的过程，系统在压栈的时候会保留现场。

1. 程序到达Node newHead = reverse(head.next);时进入递归
2. 我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)
3. 执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。
4. 接下来就是弹栈过程了
        程序继续执行 temp.next = head就相当于4->3
        head.next = null 即把3结点指向4结点的指针断掉。
        返回新链表的头结点newHead
## 链表有环

方法一：首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。

 

例如这样的链表：A->B->C->D->B->C->D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。

 

假设从链表头节点到入环点的距离是D，链表的环长是S。那么算法的时间复杂度是0+1+2+3+....+(D+S-1) = (D+S-1)*(D+S)/2 ， 可以简单地理解成 O(N*N)。而此算法没有创建额外存储空间，空间复杂度可以简单地理解成为O(1)。


。
public class Solution {
    public boolean hasCycle(ListNode head) {
    	//声明一个set存放已遍历的节点，即为标记节点（Set中不允许重复元素）
        Set<ListNode> set = new HashSet<>();
		while(head!=null) {
			if(set.contains(head)) {
				return true;
			}else {
				set.add(head);
				head = head.next;
			}
		}
		return false;
    }
}


方法二：声明两个指针，一个指针走一次经过两个节点(快指针quick)，另一个走一次经过一个节点(慢指针slow)
方法说明：快指针走的比较快，若链表有环，则一定会追上慢指针，若无环，则会走到链表末端。
public class Solution {
    public boolean hasCycle(ListNode head) {
        ==//声明两个节点从头开始遍历节点==
        ListNode quick = head;
        ListNode slow = head;
        //当快指针能够走到头表示无环
        while(quick!=null&&quick.next!=null){
            quick = quick.next.next;
            slow = slow.next;
            if(quick==slow){
                return true;
            }
        }      
 	    return false;
    }
}