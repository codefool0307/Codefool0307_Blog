<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-28 09:56:50
 * @FilePath: \docs\4.interview\8-redis面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
-->
<!-- TOC -->

- [1.缓存](#1缓存)
  - [1-1：缓存思想](#1-1缓存思想)
  - [1-2：使用缓存为系统带来了什么问题](#1-2使用缓存为系统带来了什么问题)
  - [1-3：本地缓存解决方案](#1-3本地缓存解决方案)
  - [1-4：为什么要有分布式缓存?/为什么不直接用本地缓存?](#1-4为什么要有分布式缓存为什么不直接用本地缓存)
  - [1-5：缓存读写模式/更新策略](#1-5缓存读写模式更新策略)
  - [1-5：为什么要⽤ redis/为什么要⽤缓存](#1-5为什么要-redis为什么要缓存)
  - [1-6：为什么要⽤ redis ⽽不⽤ map/guava 做缓存?](#1-6为什么要-redis-不-mapguava-做缓存)
  - [1-6：缓存数据的处理流程是怎样的？](#1-6缓存数据的处理流程是怎样的)
- [2.分布式缓存技术](#2分布式缓存技术)
  - [2-1：说一下 Redis 和 Memcached 的区别和共同点](#2-1说一下-redis-和-memcached-的区别和共同点)
  - [2-2：为什么说Redis快](#2-2为什么说redis快)
  - [2-3：Redis应用场景](#2-3redis应用场景)
- [3.Redis五大数据类型与编码方式](#3redis五大数据类型与编码方式)
  - [3-1：五大数据类型（理解就好）](#3-1五大数据类型理解就好)
  - [3-2：动态字符串与C语言自带字符串的区别](#3-2动态字符串与c语言自带字符串的区别)
  - [3-3：Redis字典底层如何解决冲突](#3-3redis字典底层如何解决冲突)
  - [3-4：hash如何扩容](#3-4hash如何扩容)
  - [3-5：什么是渐进式](#3-5什么是渐进式)
  - [3-6：什么时候使用ziplist而不是hash](#3-6什么时候使用ziplist而不是hash)
  - [3-7：什么时候使用ziplist什么时候使用skiplist？](#3-7什么时候使用ziplist什么时候使用skiplist)
  - [3-8：skiplist原理](#3-8skiplist原理)
  - [3-9：ziplist原理](#3-9ziplist原理)
  - [3-10：为什么选择跳表而不是平衡树或者哈希表](#3-10为什么选择跳表而不是平衡树或者哈希表)
- [4.Redis的单线程](#4redis的单线程)
  - [4-1：为什么Redis是单线程](#4-1为什么redis是单线程)
  - [4-2：既然是单线程，那怎么监听大量的客户端连接呢？](#4-2既然是单线程那怎么监听大量的客户端连接呢)
  - [4-3：Redis为什么又采用了多线程](#4-3redis为什么又采用了多线程)
- [5.过期策略](#5过期策略)
  - [5-1：Redis 给缓存数据设置过期时间有啥用？](#5-1redis-给缓存数据设置过期时间有啥用)
  - [5-2：Redis是如何判断数据是否过期的呢？](#5-2redis是如何判断数据是否过期的呢)
  - [5-3：过期策略分类](#5-3过期策略分类)
  - [5-4：缓存淘汰机制](#5-4缓存淘汰机制)
  - [5、过期键的删除策略](#5过期键的删除策略)
  - [Redis key的过期时间和永久有效分别怎么设置？](#redis-key的过期时间和永久有效分别怎么设置)
- [6.持久化机制](#6持久化机制)
  - [6-1：什么是Redis持久化？](#6-1什么是redis持久化)
  - [6-2:各自的优缺点？](#6-2各自的优缺点)
  - [6-3：Redis持久化数据和缓存怎么做扩容？](#6-3redis持久化数据和缓存怎么做扩容)
  - [6-1：持久化期间工作流程](#6-1持久化期间工作流程)
  - [6-2：持久化机制](#6-2持久化机制)
- [7.集群主从复制](#7集群主从复制)
- [8.缓存雪崩](#8缓存雪崩)
  - [8-1：什么是缓存穿透](#8-1什么是缓存穿透)
  - [8-2：缓存穿透解决方案](#8-2缓存穿透解决方案)
  - [8-4：什么是缓存雪崩](#8-4什么是缓存雪崩)
  - [8-5：有哪些解决办法？](#8-5有哪些解决办法)
- [9.如何保证缓存和数据库数据的一致性？](#9如何保证缓存和数据库数据的一致性)
- [10.事务](#10事务)
  - [10-1：什么是事务？](#10-1什么是事务)
  - [10-2：Redis事务的概念](#10-2redis事务的概念)
  - [10-3：Redis事务的三个阶段](#10-3redis事务的三个阶段)
  - [10-4：Redis事务相关命令](#10-4redis事务相关命令)
  - [10-5：事务管理（ACID）概述](#10-5事务管理acid概述)
  - [10-6：Redis事务支持隔离性吗](#10-6redis事务支持隔离性吗)
  - [10-7：Redis事务保证原子性吗，支持回滚吗](#10-7redis事务保证原子性吗支持回滚吗)
  - [10-8：Redis事务其他实现](#10-8redis事务其他实现)

<!-- /TOC -->

# 1.缓存

## 1-1：缓存思想

我们为了避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补。

## 1-2：使用缓存为系统带来了什么问题

1. 系统复杂性增加：引入缓存之后，你要维护缓存和数据库的数据一致性、维护热点缓存等等。
2. 系统开发成本增加：引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本还是很贵的，
   毕竟耗费的是宝贵的内存。但是，如果你只是简单的使用一下本地缓存存储一下简单的数据，并且数据量不大的话，那么就不需要单独去弄一个缓存服务。

## 1-3：本地缓存解决方案

一：JDK 自带的 HashMap 和 ConcurrentHashMap 了。

ConcurrentHashMap 可以看作是线程安全版本的 HashMap ，两者都是存放 key/value 形式的键值对。但是，大部分场景来说不会使用这两者当做缓存，因为只提供了缓存的功能，并没有提供其他诸如过期时间之类的功能。

二： Ehcache 、 Guava Cache 、 Spring Cache 这三者是使用的比较多的本地缓存框架。

Ehcache 的话相比于其他两者更加重量。不过，相比于 Guava Cache 、 Spring Cache 来说， Ehcache 支持可以嵌入到 hibernate 和 mybatis 作为多级缓存，并且可以将缓存的数据持久化到本地磁盘中、同时也提供了集群方案（比较鸡肋，可忽略）。

Guava Cache 和 Spring Cache 两者的话比较像。

Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和 ConcurrentHashMap 的思想有异曲同工之妙。

使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如缓存穿透、内存溢出。

三： 后起之秀 Caffeine。

相比于 Guava 来说 Caffeine 在各个方面比如性能要更加优秀，一般建议使用其来替代 Guava 。并且， Guava 和 Caffeine 的使用方式很像！

本地缓存固然好，但是缺陷也很明显，比如多个相同服务之间的本地缓存的数据无法共享。

## 1-4：为什么要有分布式缓存?/为什么不直接用本地缓存?

其实分布式缓存类似于一种内存数据库的服务，它的最终作用就是提供缓存数据的服务。

本地的缓存的优势是低依赖，比较轻量并且通常相比于使用分布式缓存要更加简单。

本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。

本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

使用分布式缓存之后，缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的性能、容量和提供的功能都要更加强大。

使用分布式缓存的缺点呢，也很显而易见，那就是你需要为分布式缓存引入额外的服务比如 Redis 或 Memcached，你需要单独保证 Redis 或 Memcached 服务的高可用。

## 1-5：缓存读写模式/更新策略

1. Cache Aside Pattern（旁路缓存模式）
写：更新 DB，然后直接删除 cache 。
读：从 cache 中读取数据，读取到就直接返回，读取不到的话，就从 DB 中取数据返回，然后再把数据放到 cache 中。
Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。另外，Cache Aside Pattern 有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。

Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。

2. Read/Write Through Pattern（读写穿透）
Read/Write Through 套路是：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。

写（Write Through）：先查 cache，cache 中不存在，直接更新 DB。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。
读(Read Through)： 从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。
Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。

和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。

3. Write Behind Pattern（异步缓存写入）
Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。

但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。

Write Behind Pattern 下 DB 的写性能非常高，尤其适合一些数据经常变化的业务场景比如说一篇文章的点赞数量、阅读数量。 往常一篇文章被点赞 500 次的话，需要重复修改 500 次 DB，但是在 Write Behind Pattern 下可能只需要修改一次 DB 就可以了。

但是，这种模式同样也给 DB 和 Cache 一致性带来了新的考验，很多时候如果数据还没异步更新到 DB 的话，Cache 服务宕机就 gg 了。

## 1-5：为什么要⽤ redis/为什么要⽤缓存

1. 高性能方面，假如⽤户第⼀次访问数据库中的某些数据。这个过程会⽐较慢，因为是从硬盘上读取的。将该⽤户访问的数据存在缓存
   中，这样下⼀次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的
   对应数据改变的之后，同步改变缓存中相应的数据即可！

2. ⾼并发：直接操作缓存能够承受的请求是远远⼤于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这
   样⽤户的⼀部分请求会直接到缓存这⾥⽽不⽤经过数据库。

## 1-6：为什么要⽤ redis ⽽不⽤ map/guava 做缓存?

缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都需要各⾃保存⼀份缓存，缓存不具有⼀致性。

使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。


## 1-6：缓存数据的处理流程是怎样的？

1. 如果用户请求的数据在缓存中就直接返回。
2. 缓存中不存在的话就看数据库中是否存在。
3. 数据库中存在的话就更新缓存中的数据。
4. 数据库中不存在的话就返回空数据。

# 2.分布式缓存技术

## 2-1：说一下 Redis 和 Memcached 的区别和共同点

共同点 ：

都是基于内存的数据库，一般都用来当做缓存使用。
都有过期策略。
两者的性能都非常高。

区别 ：

Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。
Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。
Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。
Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.
Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）
Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

## 2-2：为什么说Redis快

书本

## 2-3：Redis应用场景

1. 热点数据的缓存

由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作

2. 限时业务的运用

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. 计数器相关问题

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、比如限制一个手机号发多少条短信、一个接口一分钟限
制多少请求、一个接口一天限制调用多少次等等。

4. 排行榜相关问题

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。

5. 分布式锁


6. 延时操作

没有做过具体操作，就是想过，比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 

7. 分页、模糊搜索

就是在实习期间利用zrangebylex方法可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。

对公司进行项目的数据进行了模拟测试，公司存储数据6000万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于
系统的性能保障。

8. 点赞、好友等相互关系的存储
   
Redis set可以实现set是可以自动排重的，比如说在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。

9. 队列

由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。

# 3.Redis五大数据类型与编码方式

## 3-1：五大数据类型（理解就好）

1. string

   * Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串

2. list

   * Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

3. hash
 
   * 使用ziplist（压缩列表）和hashtable
   * hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis的hash做了更多优化。

4. set

   * Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，

5. zset

   * 编码有ziplist（压缩链表）和skiplist（跳表）两种
   * zset 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元
素的列表。

## 3-2：动态字符串与C语言自带字符串的区别

## 3-3：Redis字典底层如何解决冲突

## 3-4：hash如何扩容

正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。

当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。

## 3-5：什么是渐进式

大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁
+
书本

## 3-6：什么时候使用ziplist而不是hash

哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
哈希对象保存的键值对数量小于512个

## 3-7：什么时候使用ziplist什么时候使用skiplist？

当zset满足以下两个条件的时候，使用ziplist：

保存的元素少于128个
保存的所有元素大小都小于64字节

## 3-8：skiplist原理

核心点主要是包括一个dict对象和一个skiplist对象。dict保存key/value，key为元素，value为分值；skiplist保存的有序的元素列表，每个元素包括元素和分值。两种数据结构下的元素指向相同的位置。

## 3-9：ziplist原理


## 3-10：为什么选择跳表而不是平衡树或者哈希表


# 4.Redis的单线程

## 4-1：为什么Redis是单线程

1. 可维护性对于一个项目来说非常重要，如果代码难以调试和测试，问题也经常难以复现，这对于任何一个项目来说都会严重地影响项目的可维护性。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，代码的执行过程不再是串行的，多个线程同时访问的变量如果没有谨慎处理就会带来诡异的问题。

引入了多线程，我们就必须要同时引入并发控制来保证在多个线程同时访问数据时程序行为的正确性，这就需要工程师额外维护并发控制的相关代码，例如，我们会需要在可能被并发读写的变量上增加互斥锁：

在访问这些变量或者内存之前也需要先对获取互斥锁，一旦忘记获取锁或者忘记释放锁就可能会导致各种诡异的问题，管理相关的并发控制机制也需要付出额外的研发成本和负担。


2. 使用单线程模型也并不意味着程序不能并发的处理任务，Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用机制并发处理来自客户端的多个连接，同时等待多个连接发送的请求。

在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。

使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要额外创建和维护进程和线程来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。


3. Redis 选择单线程模型的决定性原因，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。

比如说多线程中

保存线程 1 的执行上下文；
加载线程 2 的执行上下文；

频繁的对线程的上下文进行切换可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。

## 4-2：既然是单线程，那怎么监听大量的客户端连接呢？

Redis 通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。

这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。

## 4-3：Redis为什么又采用了多线程

适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂

所以就需要提高网络 IO 读写性能


# 5.过期策略

## 5-1：Redis 给缓存数据设置过期时间有啥用？

因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。

很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。

如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

## 5-2：Redis是如何判断数据是否过期的呢？
Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。

## 5-3：过期策略分类

惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。
定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

## 5-4：缓存淘汰机制

volatile-lru（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## 5、过期键的删除策略
6、Redis的过期键的删除策略

## Redis key的过期时间和永久有效分别怎么设置？
8、我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?


# 6.持久化机制

## 6-1：什么是Redis持久化？

RDB 持久化：该机制可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

AOF 持久化：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令
全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），
使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小

无持久化：让数据只在服务器运行时存在。

同时应用 AOF 和 RDB：当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 
文件所保存的数据集更完整

## 6-2:各自的优缺点？

RDB 的优缺点：

优点：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每
小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复
（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进
程在保存 RDB 文件时唯一要做的就是 fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的
速度比 AOF 的恢复速度要快。

缺点：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 
因为 RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你
就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会
非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。


AOF 的优缺点。

优点：
1、使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 
fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后
台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek 
， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

2、Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安
全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF文件
创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

缺点：

对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依
然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间
（latency）。

AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾
经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在
AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。

## 6-3：Redis持久化数据和缓存怎么做扩容？

如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。

如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用
可以在运行时进行数据再平衡的一套系统

## 6-1：持久化期间工作流程

客户端向数据库 发送写命令 (数据在客户端的内存中)
数据库 接收 到客户端的 写请求 (数据在服务器的内存中)
数据库 调用系统 API 将数据写入磁盘 (数据在内核缓冲区中)
操作系统将 写缓冲区 传输到 磁盘控控制器 (数据在磁盘缓存中)
操作系统的磁盘控制器将数据 写入实际的物理媒介 中 (数据在磁盘中)

## 6-2：持久化机制

# 7.集群主从复制

# 8.缓存雪崩

## 8-1：什么是缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

## 8-2：缓存穿透解决方案


## 8-4：什么是缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

## 8-5：有哪些解决办法？
针对 Redis 服务不可用的情况：

采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
限流，避免同时处理大量的请求。
针对热点缓存失效的情况：

设置不同的失效时间比如随机设置缓存的失效时间。
缓存永不失效。

# 9.如何保证缓存和数据库数据的一致性？

# 10.事务

## 10-1：什么是事务？

## 10-2：Redis事务的概念

## 10-3：Redis事务的三个阶段

## 10-4：Redis事务相关命令

## 10-5：事务管理（ACID）概述

## 10-6：Redis事务支持隔离性吗

## 10-7：Redis事务保证原子性吗，支持回滚吗

## 10-8：Redis事务其他实现




