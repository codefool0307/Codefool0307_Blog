<!--
 * @Author: 孙浩然
 * @Date: 2020-07-28 11:04:41
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-16 15:18:56
 * @FilePath: \docs\4.interview\8-redis面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
-->
# 

## 为什么要⽤ redis/为什么要⽤缓存

1. 高性能方面，假如⽤户第⼀次访问数据库中的某些数据。这个过程会⽐较
   慢，因为是从硬盘上读取的。将该⽤户访问的数据存在缓存中，这样下⼀
   次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接
   操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步
   改变缓存中相应的数据即可！

2. ⾼并发：直接操作缓存能够承受的请求是远远⼤于直接访问数据库的，所
   以我们可以考虑把数据库中的部分数据转移到缓存中去，这样⽤户的⼀部
   分请求会直接到缓存这⾥⽽不⽤经过数据库。

## 为什么要⽤ redis ⽽不⽤ map/guava 做缓存?

缓存分为本地缓存和分布式缓存。以 Java 为例，使⽤⾃带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，⽣命周期随着 jvm 的销毁⽽结束，并且在多实例的情况下，每个实例都需要各⾃保存⼀份缓存，缓存不具有⼀致性。

使⽤ redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共⽤⼀份缓存数据，缓存具有⼀致性。缺点是需要保持 redis 或 memcached服务的⾼可⽤，整个程序架构上较为复杂。

## Redis与Memcached区别

1. redis⽀持更丰富的数据类型（⽀持更复杂的应⽤场景） ： Redis不仅
   仅⽀持简单的k/v类型的数据，同时还提供list， set， zset， hash
   等数据结构的存储。 memcache⽀持简单的数据类型，String。
2. Redis⽀持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时
   候可以再次加载进⾏使⽤,⽽Memecache把数据全部存在内存之中。
3. 集群模式： memcached没有原⽣的集群模式，需要依靠客户端来实现往
   集群中分⽚写⼊数据；但是 redis ⽬前是原⽣⽀持 cluster 模式的.
4. Memcached是多线程，⾮阻塞IO复⽤的⽹络模型； Redis使⽤单线程的多
   路 IO 复⽤模型。

## 为什么说Redis快

书本

# 缓存雪崩

## 什么是缓存雪崩



## 如何解决 Redis 的并发竞争 Key 问题

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对⼀个 key 进⾏操作，但是最后执⾏的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐⼀种⽅案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使⽤分布式锁，这样会影响性能）基于zookeeper临时有序节点可以实现的分布式锁。⼤致思想为：每个客户端对某个⽅法加锁时，在zookeeper上的与该⽅法对应的指定节点的⽬录下，⽣成⼀个唯⼀的瞬时有序节点。 判断是否获取锁的⽅式很简单，只需要判断有序节点中序号最⼩的⼀个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁⽆法释放，⽽产⽣的死锁问题。完成业务流程后，删除对应的⼦节点释放锁。在实践中，当然是从以可靠性为主。所以⾸推Zookeeper。


## Redis的数据结构

## 介绍zset类型的底层结构



## redis怎么保证原子性？

因为redis是单线程。


## Redis单线程，如何实现异步和非阻塞

对于Redis的网络请求，Redis会有一个EventLoop，里面有两个数组events,fired。events存放被注册的事件，fired用于存放EventLoop从多路复用器（epoll）中读取到的，将要执行的事件。

异步和非阻塞就反映在这里，注册到多路复用器（epoll）后去做其他事，之后通过主动轮询多路复用器，来逐个取出将要执行的事件，放入fired，逐个执行，这个过程是单线程的，因此不会出现并发问题。


## redis为什么是单进程？

如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。

## 什么时候可以用多线程

下层的存储等慢速的情况

## 引出redis的分布式锁

## redis负载多少，测过没有

## Redis的zset原理