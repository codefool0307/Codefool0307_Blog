<!--
 * @Author: 孙浩然
 * @Date: 2020-07-01 10:38:12
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-21 10:54:45
 * @FilePath: \docs\4.interview\1-java基础面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
<!-- TOC -->

- [1.java基础-java特性](#1java基础-java特性)
  - [1-1：java特点](#1-1java特点)
- [2.java基础-面对对象-综述](#2java基础-面对对象-综述)
  - [2-1 ：面对对象三大特征(特点)](#2-1-面对对象三大特征特点)
  - [2-2：面对对象的五大原则](#2-2面对对象的五大原则)
  - [2-3：Java创建对象方式](#2-3java创建对象方式)
  - [2-4：⾯向过程性能⽐⾯向对象⾼](#2-4向过程性能向对象)
- [3.java基础-面对对象-多态](#3java基础-面对对象-多态)
  - [3-1:多态的必要条件（实现方式）](#3-1多态的必要条件实现方式)
  - [3-2：多态机制](#3-2多态机制)
- [4.java基础-面对对象-重载与重写](#4java基础-面对对象-重载与重写)
  - [4-1:重载与重写](#4-1重载与重写)
  - [4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？](#4-2java-中是否可以覆盖override一个-private-或者是-static-的方法)
- [5.java基础-面对对象-接口与抽象类](#5java基础-面对对象-接口与抽象类)
  - [5-1：接⼝和抽象类的区别是什么？](#5-1接和抽象类的区别是什么)
  - [5-2：Java 抽象类可以有构造函数吗？作用是什么](#5-2java-抽象类可以有构造函数吗作用是什么)
  - [5-3: Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗？](#5-3-java-抽象类可以实现接口吗-它们需要实现所有的方法吗)
  - [5-4：Java 抽象类可以是 final 的吗？](#5-4java-抽象类可以是-final-的吗)
  - [5-5：Java 抽象类可以有 static 方法吗？](#5-5java-抽象类可以有-static-方法吗)
  - [5-6：可以创建抽象类的实例吗？](#5-6可以创建抽象类的实例吗)
  - [5-7：抽象类必须有抽象方法吗？](#5-7抽象类必须有抽象方法吗)
  - [5-8：何时选用抽象类而不是接口？](#5-8何时选用抽象类而不是接口)
  - [5-9：Java中的抽象方法是什么？](#5-9java中的抽象方法是什么)
  - [5-10：Java抽象类中可以包含main方法吗？](#5-10java抽象类中可以包含main方法吗)
  - [5-11：创建⼀个对象⽤什么运算符?对象实体与对象引⽤有何不同?](#5-11创建个对象什么运算符对象实体与对象引有何不同)
- [6.java基础-值传递与引用传递](#6java基础-值传递与引用传递)
- [7.java基础-深拷贝与浅拷贝](#7java基础-深拷贝与浅拷贝)
  - [7-1：深拷贝与浅拷贝](#7-1深拷贝与浅拷贝)
  - [7-2：浅拷贝方法](#7-2浅拷贝方法)
  - [7-3：深拷贝方法](#7-3深拷贝方法)
- [8.java基础-面对对象-构造器](#8java基础-面对对象-构造器)
  - [8-1：⼀个类的构造⽅法的作⽤是什么? 若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? 为什么?](#8-1个类的构造法的作是什么-若个类没有声明构造法该程序能正确执吗-为什么)
  - [8-2：构造⽅法有哪些特性？](#8-2构造法有哪些特性)
- [9.java基础-面对对象-静态与非静态](#9java基础-面对对象-静态与非静态)
  - [9-1：静态⽅法和实例⽅法有何不同](#9-1静态法和实例法有何不同)
  - [9-2：静态变量和实例变量的区别？](#9-2静态变量和实例变量的区别)
- [10.java基础-运算符-相等问题](#10java基础-运算符-相等问题)
  - [10-1： == 与 equals](#10-1--与-equals)
  - [10-2：为什么要重写hashcode与equals](#10-2为什么要重写hashcode与equals)
  - [10-3：重写equals不重写hashcode会出现什么问题](#10-3重写equals不重写hashcode会出现什么问题)
  - [10-4：为什么两个对象有相同的hashcode值，它们也不一定是相等的？](#10-4为什么两个对象有相同的hashcode值它们也不一定是相等的)
  - [10-5：说说&和&&的区别。](#10-5说说和的区别)
  - [10-6：用最有效率的方法算出 2 乘以 8 等于几?](#10-6用最有效率的方法算出-2-乘以-8-等于几)
- [11.java基础-数据类型-8种常见类型](#11java基础-数据类型-8种常见类型)
  - [11-1：八种数据类型是什么？-中兴](#11-1八种数据类型是什么-中兴)
  - [11-2：数据类型的范围](#11-2数据类型的范围)
  - [11-3：为什么byte类型是-128~+127](#11-3为什么byte类型是-128127)
  - [11-4：java为什么除了基本数据类型还要有引用数据类型](#11-4java为什么除了基本数据类型还要有引用数据类型)
  - [11-5：String为什么不是基本数据类型-字节](#11-5string为什么不是基本数据类型-字节)
- [12.java基础-数据类型-自动拆装箱](#12java基础-数据类型-自动拆装箱)
  - [12-1：为什么要有自动拆装箱](#12-1为什么要有自动拆装箱)
  - [12-2：Integer缓存机制](#12-2integer缓存机制)
  - [12-3：自动拆装箱的原理](#12-3自动拆装箱的原理)
  - [12-4:自动拆装箱使用场景](#12-4自动拆装箱使用场景)
  - [12-5：自动拆装箱带来的问题](#12-5自动拆装箱带来的问题)
  - [12-6：String转出int型， 判断能不能转？ 如何转？](#12-6string转出int型-判断能不能转-如何转)
  - [12-7：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?](#12-7short-s1--1-s1--s1--1有什么错-short-s1--1-s11有什么错)
  - [12-8：int与Integer区别](#12-8int与integer区别)
- [13.java基础-关键字-访问权限关键字](#13java基础-关键字-访问权限关键字)
  - [13-1：访问控制关键字级别](#13-1访问控制关键字级别)
  - [13-2: 通过反射访问private成员和方法，既然能访问为什么要private？](#13-2-通过反射访问private成员和方法既然能访问为什么要private)
- [14.java基础-关键字-static](#14java基础-关键字-static)
  - [14-1:static使用场景](#14-1static使用场景)
- [15.java基础-关键字-final关键字](#15java基础-关键字-final关键字)
  - [15-1 final关键字使用特点](#15-1-final关键字使用特点)
  - [15-2：final, finally, finalize 的区别。](#15-2final-finally-finalize-的区别)
  - [15-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？](#15-3使用-final-关键字修饰一个变量时是引用不能变还是引用的对象不能变)
- [16.java基础-关键字-this关键字和super关键字](#16java基础-关键字-this关键字和super关键字)
- [17.java基础-关键字-transient](#17java基础-关键字-transient)
- [18.java基础-集合map-hashmap的数据结构](#18java基础-集合map-hashmap的数据结构)
  - [18-1：hashmap的数据结构](#18-1hashmap的数据结构)
  - [18-2；为什么JDK8时候引入了红黑树？](#18-2为什么jdk8时候引入了红黑树)
  - [18-3：为什么不把链表全部换为红黑树](#18-3为什么不把链表全部换为红黑树)
  - [18-4：为什么是使用红黑树而不是AVL树？](#18-4为什么是使用红黑树而不是avl树)
  - [18-5：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？](#18-5为什么在jdk17的时候是先进行扩容后进行插入而在jdk18的时候则是先插入后进行扩容的呢)
  - [18-6：为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）](#18-6为什么在jdk18中进行对hashmap优化的时候把链表转化为红黑树的阈值是8而不是7或者不是20呢面试蘑菇街问过)
  - [18-7：扰动函数以及作用](#18-7扰动函数以及作用)
  - [18-8：哈希冲突的解决方法](#18-8哈希冲突的解决方法)
  - [18-9：HashMap的put操作](#18-9hashmap的put操作)
  - [18-10：HashMap的get操作](#18-10hashmap的get操作)
  - [18-11：hashmap的get和put操作的时间复杂度](#18-11hashmap的get和put操作的时间复杂度)
  - [18-12：hashmap的String类型如何计算hashcode的](#18-12hashmap的string类型如何计算hashcode的)
  - [18-13:reHash过程](#18-13rehash过程)
  - [18-14：hash函数以及常用方法](#18-14hash函数以及常用方法)
  - [18-15：HashMap为什么要树化?](#18-15hashmap为什么要树化)
  - [18-16：hashmap树化门槛及作用](#18-16hashmap树化门槛及作用)
  - [18-17：hashmap的特性](#18-17hashmap的特性)
  - [18-18:HashMap为什么可以插入空值?](#18-18hashmap为什么可以插入空值)
  - [18-19：JDK的hashmap与Redis的hashmap的区别](#18-19jdk的hashmap与redis的hashmap的区别)
- [19.java基础-集合map-hashmap源码数值分析](#19java基础-集合map-hashmap源码数值分析)
  - [19-1:HashMap中(tab.length - 1) & hash作用](#19-1hashmap中tablength---1--hash作用)
  - [19-2：请解释一下HashMap的参数loadFactor，它的作用是什么？](#19-2请解释一下hashmap的参数loadfactor它的作用是什么)
  - [19-3：HashMap的扩容因子为什么是0.75](#19-3hashmap的扩容因子为什么是075)
  - [19-4:为什么默认初始化桶数组大小为16](#19-4为什么默认初始化桶数组大小为16)
  - [19-5：hashmap为什么是2的次幂](#19-5hashmap为什么是2的次幂)
- [20.java基础-集合map-hashmap线程问题](#20java基础-集合map-hashmap线程问题)
  - [20-1:hashMap是否线程安全](#20-1hashmap是否线程安全)
  - [20-2为什么hashmap中String、integer包装类适合作为key](#20-2为什么hashmap中stringinteger包装类适合作为key)
  - [20-3：线程安全的Map](#20-3线程安全的map)
  - [20-4：设计线程安全的map](#20-4设计线程安全的map)
- [21.java基础-集合map-ConcurrentHashMap](#21java基础-集合map-concurrenthashmap)
  - [21-1：ConcurrentHashMap的底层实现](#21-1concurrenthashmap的底层实现)
  - [21-2：为何会出现ConcurrenHashMap?](#21-2为何会出现concurrenhashmap)
  - [21-3：为什么ConcurrentHashMap（hashtable）为何不支持null键和null值](#21-3为什么concurrenthashmaphashtable为何不支持null键和null值)
  - [21-4：ConcurrentHashMap的put操作](#21-4concurrenthashmap的put操作)
  - [21-5：分段锁原理](#21-5分段锁原理)
- [22.java基础-集合map-TreeMap](#22java基础-集合map-treemap)
  - [22-1:TreeMap底层原理：](#22-1treemap底层原理)
  - [22-2：使用场景](#22-2使用场景)
- [23.java基础-集合map-LinkedHashmap](#23java基础-集合map-linkedhashmap)
  - [23-1：linkedhashmap的底层原理](#23-1linkedhashmap的底层原理)
- [24.java基础-集合map-HashTable](#24java基础-集合map-hashtable)
  - [24-1：HashTable的底层原理](#24-1hashtable的底层原理)
- [25.java基础-集合list-ArrayList](#25java基础-集合list-arraylist)
  - [25-1：数组(Array)和列表(ArrayList)有什么区别？ 什么时候应该使用 Array 而不是ArrayList？](#25-1数组array和列表arraylist有什么区别-什么时候应该使用-array-而不是arraylist)
- [26.java基础-集合list-vector](#26java基础-集合list-vector)
- [27.java基础-集合list-linkedlist](#27java基础-集合list-linkedlist)
- [28.java基础-集合set-HashSet](#28java基础-集合set-hashset)
  - [28-1：hashset原理](#28-1hashset原理)
- [29.java基础-集合set-TreeSet](#29java基础-集合set-treeset)
  - [29-1：TreeSet原理](#29-1treeset原理)
- [30.java基础-集合set-LinkedSet](#30java基础-集合set-linkedset)
  - [30-1：LinkedSet原理](#30-1linkedset原理)
- [31.java基础-集合-集合大比较（区别和使用场景）](#31java基础-集合-集合大比较区别和使用场景)
  - [31-1：set和list、map的区别](#31-1set和listmap的区别)
  - [31-2：arraylist、linkedlist区别和适用场景](#31-2arraylistlinkedlist区别和适用场景)
  - [31-3：vector、Arraylist区别和适用场景](#31-3vectorarraylist区别和适用场景)
  - [31-4：HashMap、Treemap、linkedHashMap区别和适用场景](#31-4hashmaptreemaplinkedhashmap区别和适用场景)
  - [31-5：HashTable、Hashmap区别和适用场景](#31-5hashtablehashmap区别和适用场景)
  - [31-6： ConcurrentHashMap、Hashmap区别和适用场景](#31-6-concurrenthashmaphashmap区别和适用场景)
  - [31-7： Hashset、Hashmap区别和适用场景](#31-7-hashsethashmap区别和适用场景)
  - [31-8：treeset、hashset区别和适用场景](#31-8treesethashset区别和适用场景)
  - [31-9：JAVA集合类](#31-9java集合类)
- [32.java基础-设计类问题](#32java基础-设计类问题)
  - [32-1：如果想要一个key对应多个Value的话，怎么设计Map](#32-1如果想要一个key对应多个value的话怎么设计map)
  - [32-2：插入一万个元素之后会不会扩容，扩容扩多少](#32-2插入一万个元素之后会不会扩容扩容扩多少)
  - [32-3：创建一个对象HashMap<Integer,Integer> map=new HashMap<>先put(10),然后get(new Long(10))结果是多少？](#32-3创建一个对象hashmapintegerinteger-mapnew-hashmap先put10然后getnew-long10结果是多少)
- [33.java基础-IO-各种流](#33java基础-io-各种流)
  - [33-1：为何还要有字符流](#33-1为何还要有字符流)
  - [33-2：字节流和字符流区别](#33-2字节流和字符流区别)
  - [33-3：同步、异步与阻塞、非阻塞](#33-3同步异步与阻塞非阻塞)
  - [33-4：BIO\NIO\AIO区别](#33-4bionioaio区别)
  - [33-5：linux的5种IO模型](#33-5linux的5种io模型)
  - [33-6:IO多路复用](#33-6io多路复用)
  - [33-7：三种常用的实现方式-select](#33-7三种常用的实现方式-select)
  - [33-8：三种常用的实现方式-poll](#33-8三种常用的实现方式-poll)
  - [33-9：三种常用的实现方式-epoll](#33-9三种常用的实现方式-epoll)
  - [33-10：三种常用的实现方式区别](#33-10三种常用的实现方式区别)
- [22.java基础-反射](#22java基础-反射)
  - [21-1：什么是反射](#21-1什么是反射)
  - [21-2：反射的作用](#21-2反射的作用)
  - [21-3：获取class对象方法](#21-3获取class对象方法)
  - [21-4：Class.forName和classloader.loadClass的区别](#21-4classforname和classloaderloadclass的区别)
  - [21-3：哪些类不能反射](#21-3哪些类不能反射)
  - [21-3：Java创建对象的方式](#21-3java创建对象的方式)
  - [21-4：设计模式——代理模式](#21-4设计模式代理模式)
  - [21-5：静态代理的用途](#21-5静态代理的用途)
  - [21-6：动态代理的几种实现方式(aop代理方式)](#21-6动态代理的几种实现方式aop代理方式)
  - [21-7：两种方式区别](#21-7两种方式区别)
  - [21-8：什么是静态代理](#21-8什么是静态代理)
  - [21-9：什么是静态代理（继续修改）](#21-9什么是静态代理继续修改)
  - [21-10：动态代理与静态代理的区别](#21-10动态代理与静态代理的区别)
- [23.java基础-注解](#23java基础-注解)
  - [22-1：元注解以及分类](#22-1元注解以及分类)
  - [22-2 Java常用注解](#22-2-java常用注解)
- [24.java基础-泛型](#24java基础-泛型)
  - [23-1：什么是泛型](#23-1什么是泛型)
  - [23-2：编译器如何处理泛型](#23-2编译器如何处理泛型)
  - [23-3：为什么Java要用这种编译器](#23-3为什么java要用这种编译器)
  - [23-4: 什么是类型擦除](#23-4-什么是类型擦除)
  - [23-5：类型擦除过程](#23-5类型擦除过程)
  - [23-6：泛型带来的问题](#23-6泛型带来的问题)
  - [23-7：List泛型和原始类型List之间的区别?](#23-7list泛型和原始类型list之间的区别)
  - [23-8：List泛型和原始类型List泛型之间的区别?](#23-8list泛型和原始类型list泛型之间的区别)
- [25-java基础-泛型应用](#25-java基础-泛型应用)
  - [24-1:子类继承父类的public可以写成private吗](#24-1子类继承父类的public可以写成private吗)
  - [24-2：多态时是否会出现类型擦除](#24-2多态时是否会出现类型擦除)
- [26-java基础-异常](#26-java基础-异常)
  - [26-1:异常的分类](#26-1异常的分类)
  - [26-2:Java 中的两种异常类型是什么？ 他们有什么区别？](#26-2java-中的两种异常类型是什么-他们有什么区别)
  - [26-3：异常类型](#26-3异常类型)
  - [26-4：什么是OOM？常见有哪些OOM？](#26-4什么是oom常见有哪些oom)
  - [25-3：异常链](#25-3异常链)
- [27.java基础-常用类-String](#27java基础-常用类-string)
  - [23-1：String为什么是final的？](#23-1string为什么是final的)
  - [23-2：拼接方式](#23-2拼接方式)
  - [23-3: String、StringBuffer和StringBuilder区别](#23-3-stringstringbuffer和stringbuilder区别)
  - [23-4：StringBuffer如何实现线程安全](#23-4stringbuffer如何实现线程安全)
  - [23-6：String 和 char[] 数组谁更适合存密码](#23-6string-和-char-数组谁更适合存密码)
  - [23-7：String str = new String("abc");创建了几个对象-百度，京东](#23-7string-str--new-stringabc创建了几个对象-百度京东)
  - [23-8：处理数据量较大的字符串用string还是stringbuilder，为什么](#23-8处理数据量较大的字符串用string还是stringbuilder为什么)
  - [23-9：为什么StringBuffer和StringBuilder比String更快（不变性）](#23-9为什么stringbuffer和stringbuilder比string更快不变性)
  - [23-10：如何把一段逗号分割的字符串转换成一个数组?](#23-10如何把一段逗号分割的字符串转换成一个数组)
- [28.java基础-常用类-枚举](#28java基础-常用类-枚举)
  - [-1：enum线程安全](#-1enum线程安全)
  - [-2: switch 是否可用于String类型的判断，Java哪个版本之后有此功能的](#-2-switch-是否可用于string类型的判断java哪个版本之后有此功能的)
- [29.Java基础-常用类-时间类](#29java基础-常用类-时间类)
  - [29-1：SimpDateFormat是线程不安全的类，不要定义为static变量，如果定义，必须加锁或工具类](#29-1simpdateformat是线程不安全的类不要定义为static变量如果定义必须加锁或工具类)
- [30.java基础-常用类-Object类](#30java基础-常用类-object类)
  - [30-1:Object类有哪些方法](#30-1object类有哪些方法)
  - [30-2：为什么操作线程方法会在Object对象中](#30-2为什么操作线程方法会在object对象中)
- [31.java基础-序列化](#31java基础-序列化)
  - [-1：什么是序列化和饭序列化](#-1什么是序列化和饭序列化)
  - [-2：序列化的作用](#-2序列化的作用)
  - [-2：java对象如何实现序列化](#-2java对象如何实现序列化)
  - [-3：java对象如何实现反序列化](#-3java对象如何实现反序列化)
  - [-4：哪些不会被序列化](#-4哪些不会被序列化)
  - [-5：序列化协议有哪些](#-5序列化协议有哪些)
  - [-3:该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？](#-3该接口并没有方法和字段为什么只有实现了该接口的类的对象才能被序列化呢)
  - [-4: 什么是serialVersionUID](#-4-什么是serialversionuid)

<!-- /TOC -->



# 1.java基础-java特性

## 1-1：java特点

1. 简单易学；
2. <font color=red size='5'>⾯向对象（封装，继承，多态）；</font>
3. <font color=red size='5'>平台⽆关性（ Java 虚拟机实现平台⽆关性）；</font>
4. 可靠性；
5. 安全性；
6. <font color=red size='5'>⽀持多线程；</font>
7. <font color=red size='5'>⽀持⽹络编程并且很⽅便；</font>
8. 编译与解释并存；

# 2.java基础-面对对象-综述

## 2-1 ：面对对象三大特征(特点)

1. 封装
2. 继承
3. 多态

## 2-2：面对对象的五大原则

1. 单一职责原则
   * 一个类，最好只做一件事，只有一个引起它的变化
2. 开放封闭原则
   * 对抽象编程，而不对具体编程
3. 里式替换原则
   * 子类必须能够替换其基类（这个是继承的关键）
4. 依赖倒置原则
   * 抽象不依赖于具体，具体依赖于抽象
5. 接口隔离原则
   * 使用多个小的专门的接口，而不要使用一个大的总接口

## 2-3：Java创建对象方式

1. 使用new关键字
2. 使用反射的机制创建对象
   * 使用Class类的newInstance方法
   * 使用Constructor类的newInstance方法
3. 使用clone方法
   * 需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。
4. 反序列化
   * 调用ObjectInputStream类的readObject（）方法

注：使用构造器的三种(new和反射的两种newInstance)，没用构造器的两种(clone和反序列化)

## 2-4：⾯向过程性能⽐⾯向对象⾼

Java 性能差的主要原因并不是因为它是⾯向对象语⾔，⽽是 Java 是半编译语⾔，最终的执⾏代码并不是可以直接被 CPU 执⾏的
⼆进制机械码。


# 3.java基础-面对对象-多态

## 3-1:多态的必要条件（实现方式）

1. 有类继承或者接口实现
2. 子类要重写父类的方法
3. 父类的引用指向子类的对象

## 3-2：多态机制

靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象

# 4.java基础-面对对象-重载与重写 

## 4-1:重载与重写

1. 重载——函数或者方法有同样的名称，但是参数列表不相同的情形
2. 重写——Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法

## 4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？

1. Java中static方法不能被覆盖， 因为方法覆盖是基于运行时动态绑定的， 而static方法是编译时静态绑定的。 

2. Java中也不可以覆盖private的方法， 因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的， 当然也不能覆盖。

# 5.java基础-面对对象-接口与抽象类

## 5-1：接⼝和抽象类的区别是什么？

1. 所有⽅法在接⼝中不能有实现，⽽抽象类可以有⾮抽象的⽅法。

2. 接⼝中除了static final变量，不能有其他变量，⽽抽象类中则不⼀定。

3. ⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。

4. 从设计层⾯来说，抽象类作为很多子类的父类，是一种模板式设计，接口是一种行为规范

## 5-2：Java 抽象类可以有构造函数吗？作用是什么

可以有， 抽象类可以声明并定义构造函数。 

它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。

## 5-3: Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗？

可以， 抽象类可以通过使用关键字implements来实现接口。 

## 5-4：Java 抽象类可以是 final 的吗？

不可以， Java 抽象类不能是 final 的。 将它们声明为final的将会阻止它们被继承， 而这正是使用抽象类唯一的方法。 

## 5-5：Java 抽象类可以有 static 方法吗？

可以， 抽象类可以声明并定义 static 方法， 没什么阻止这样做。

## 5-6：可以创建抽象类的实例吗？

不可以， 当一段代码尝试实例化一个抽象类时 Java 编译器会抛错误。

## 5-7：抽象类必须有抽象方法吗？

不需要， 抽象类有抽象方法不是强制性的。 但是一般在抽象类中设置抽象方法

## 5-8：何时选用抽象类而不是接口？

1. 当关心升级时， 因为不可能在一个发布的接口中添加一个新方法， 用抽象类会更好。
2. 如果你的接口中有很多方法， 你对它们的实现感到很头疼， 考虑提供一个抽象类作为默认实现。

## 5-9：Java中的抽象方法是什么？

1. 抽象方法是一个没有方法体的方法。 你仅需要声明一个方法， 
2. 不需要定义它并使用关键字abstract 声明。 

## 5-10：Java抽象类中可以包含main方法吗？

是的， 抽象类可以包含 main 方法， 它只是一个静态方法， 你可以使用 main 方法执行抽象类， 但不可以创建任何实例。

## 5-11：创建⼀个对象⽤什么运算符?对象实体与对象引⽤有何不同?

new 运算符，new创建对象实例，对象引⽤指向对象实例。⼀个对象引⽤可以指向0个或1个对象;⼀个对象可以有n个引⽤指向它。

# 6.java基础-值传递与引用传递

1. 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本的值不影响原变量的值

2. 引用传递一般是对于引用类型变量而言的,传递的是该对象地址的一个副本，是一个地址。
   * 如果说改变了原地址的值（注意是  值  ），那么会影响
   * 如果改变了副本地址，如new 一个原地址不会改变  

一般认为,java传递都是值传递.

# 7.java基础-深拷贝与浅拷贝

## 7-1：深拷贝与浅拷贝
1. 浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷⻉。

2. 深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其成员变量。

## 7-2：浅拷贝方法

1. 通过拷贝<font color=red>构造方法</font>实现浅拷贝：

   * 拷贝构造方法指的是该类的构造方法参数为该类的对象。

2. 通过重写clone()方法进行浅拷贝
   
   * 使用clone方法的类必须实现Cloneable接口

## 7-3：深拷贝方法

[参考文献](https://www.cnblogs.com/coderzhw/archive/2019/06/26/11094284.html)

1. 序列化
   * 序列化为数据流，在反序列化回来，就可以得到这个对象
2. 利用Kryo框架，这是一个快速高效的Java序列化框架
3. 利用json转化方式
   * 对象转化为JSON，再序列化为对象
4. 人工构建对象

# 8.java基础-面对对象-构造器

## 8-1：⼀个类的构造⽅法的作⽤是什么? 若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? 为什么?

主要作⽤是完成对类对象的初始化⼯作。可以执⾏。因为⼀个类即使没有声明构造⽅法也会有默认的不带参数的构造⽅法。

## 8-2：构造⽅法有哪些特性？

1. 名字与类名相同。
2. 没有返回值，但不能⽤ void 声明构造函数。
3. ⽣成类的对象时⾃动执⾏，⽆需调⽤。

# 9.java基础-面对对象-静态与非静态

## 9-1：静态⽅法和实例⽅法有何不同

1. 调⽤静态⽅法可以⽆需创建对象。而实例方法需要用类名.方法名访问

2. 静态⽅法在访问本类的成员时，只允许访问静态成员，⽽不允许访问实例成员变量和实例⽅法；实例⽅法则⽆此限制。

## 9-2：静态变量和实例变量的区别？

1. 语法区别： 静态变量前要加 static 关键字，而实例变量前则不加。

2. 程序运行的区别：实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

# 10.java基础-运算符-相等问题

## 10-1： == 与 equals

1. == : 它的作⽤是判断两个对象的地址是不是相等。
   基本数据类型⽐较的是值，引⽤数据类型⽐较的是内存地址

2. equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：

   * 情况 1：类没有覆盖equals()⽅法。则通过equals()⽐较该类的两个对象时，等价于通过“==”⽐ 较这两个对象。
   * 情况 2：类覆盖了equals()⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回true。

## 10-2：为什么要重写hashcode与equals

当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的ashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。

## 10-3：重写equals不重写hashcode会出现什么问题

在存储散列集合时 ,如果原对象equals(新对象) ,但没有对hashCode重写,则在集合中将会存储两个值相同的对象,从而导致混淆。


## 10-4：为什么两个对象有相同的hashcode值，它们也不一定是相等的？

hashCode方法实际上返回的就是对象存储的物理地址，也就是说 hashcode 只是用来缩小查找成本。


## 10-5：说说&和&&的区别。

1. &和&&都可以表示逻辑与，当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。
2. &&还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，所以不会出现 NullPointerException 
3. &还可以用作位运算符，当&操作符两边的表达式不是 boolean 类型时， &表示按位与操作

## 10-6：用最有效率的方法算出 2 乘以 8 等于几?

用移位运算符

2<<3

* 因为将一个数左移 n 位，就相当于乘以了2的 n 次方


# 11.java基础-数据类型-8种常见类型
##  11-1：八种数据类型是什么？-中兴

1. 字符型   char
2. 布尔型  boolean
3. 数值型
   1. 整型：byte、short、int、long
   2. 浮点型：float、double

<font?color=red>特别注意</font>：String不是基本数据类型，是引用类型。

## 11-2：数据类型的范围

byte：-2^7 ~ 2^7-1，

short：-2^15 ~ 2^15-1

int：-2^31 ~ 2^31-1

long：-2^63 ~ 2^63-1，

浮点型：

float：4字节。

double：8字节。

字符型：

char：2字节。
                                                          
##  11-3：为什么byte类型是-128~+127

使用原码或反码表示的范围为[-127, +127], -0并没有反码补码表示，而使用补码表示的范围为[-128, 127]

##  11-4：java为什么除了基本数据类型还要有引用数据类型

引用类型在堆里，基本类型在栈里。
栈空间小且连续，往往会被放在缓存。引用类型cache miss（缓存未命中）率高且要多一次解引用。对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高

## 11-5：String为什么不是基本数据类型-字节

1. 基本类型仅表示简单的数据类型，引用类型可以表示复杂的数据类型，还可以操作这种数据类型的行为 

2. java虚拟机处理基础类型与引用类型的方式是不一样的，对于基本类型，java虚拟机会为其分配数据类型实际占用的内存空间，而对于引用类型变量，他仅仅是一个指向堆区中某个实例的指针。


# 12.java基础-数据类型-自动拆装箱
## 12-1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 12-2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候该数据的时候，那么就可以直接从本地内存进行调用，就不需要再次创建对象来解决

1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
   * 如果说有，那么直接从内存进行读取
   * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置，但是只有Integer源码可以对高值、低值进行改变。

## 12-3：自动拆装箱的原理

    * 自动装箱：调用valueOf（）方法将原始类型值转换成对象
    * 自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。

## 12-4:自动拆装箱使用场景

1. 场景一、将基本数据类型放入集合类
2. 场景二、包装类型和基本类型的大小比较
3. 场景三、包装类型的运算
4. 场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
5. 场景五、函数参数与返回值

## 12-5：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，~~虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较~~。（笔试选择较为频繁，跟谁学考过）

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE（NullPointException）。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。

## 12-6：String转出int型， 判断能不能转？ 如何转？

可以转， 得处理异常 Integer.parseInt(s) 主要为 NumberFormatException： 

## 12-7：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?

## 12-8：int与Integer区别

1. Integer是int的包装类 ，int则是java的一种基本数据类型
2. Integer变量必须实例化后才能使用，而int变量不需要
3. Integer的默认值是null, int的默认值是0

注：

1. 非new生成的Integer变量和new Integer生成的变量比较时， 结果为false。( 因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer0生成的变量指向堆中新建的对象，两者在内存中的地址不同)
```java
Integer i = new Integer(100);
Integer j = 100;
Syatem.out.print(i == J); //false
```

2. Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true


# 13.java基础-关键字-访问权限关键字
## 13-1：访问控制关键字级别

![avatar](./../../1.basics/1.java-basic/assets/3-2.jpg)

## 13-2: 通过反射访问private成员和方法，既然能访问为什么要private？

1. private并不是解决安全问题的，如果想让解决代码的安全问题，请用别的办法。
2. private的意义是OOP（面向对象编程）的封装概念。

# 14.java基础-关键字-static

## 14-1:static使用场景

1. 修饰成员变量和成员方法 
     
2. 静态代码块: 
   
3. 静态内部类（static修饰类的话只能修饰内部类）： 
   
4. 静态导包: 
   
# 15.java基础-关键字-final关键字

## 15-1 final关键字使用特点

1. final修饰的类不能被继承

2. final修饰的方法不能被重写；

3. final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

4. 想通过使用final提升程序性能
   * 因为编译器能从final中获取额外的信息，因此可以对类或者方法调用进行额外的优化处理。但这中优化对程序性能的提升极其有限。

## 15-2：final, finally, finalize 的区别。
1. final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

2. finally 是异常处理语句结构的一部分，表示总是执行。
   
3. finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可
以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。


## 15-3：使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。


# 16.java基础-关键字-this关键字和super关键字

1. this程序
```java
class Manager {
    Employees[] employees;
     
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
     
    void report() { }
}
```

主要是访问本类（自己）的成员变量和方法（可写可不写）
super主要是通过子类去访问父类的成员变量和方法，必须写
2. super程序

```java
public class Super {
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

1. 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。
2. this 调用本类中的其他构造方法时，也要放在首行。
3. this、super不能用在static方法中。

# 17.java基础-关键字-transient

阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 transient 只能修饰变量，不能修饰类和⽅法。


# 18.java基础-集合map-hashmap的数据结构

## 18-1：hashmap的数据结构

1. JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，JDK1.7采用头插法虽然能够提高插入的效率，但是为了安全,防止环化，因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，保持之前节点的引用关系，就不会出现逆序且链表死循环的问题

2. （扩容机制）扩容后数据存储位置的计算方式也不一样：
   1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&
   2. 而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的存储方式。

3. （插入元素）JDK1.7的时候使用的是数组+ 单链表的数据结构。HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过(n-1)&hash判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构,当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构，以减少搜索时间。

## 18-2；为什么JDK8时候引入了红黑树？

因为当数组中每个元素，都是一个Entry，每一个Entry是一个单链表。

当链表长度过长的时候，查询链表中的一个元素就比较耗时，这时就引入了红黑树。

首先红黑树是一棵二叉树，而且属于二叉树中比较特殊的二叉搜索树。红黑树有一条特性就是从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。这一特
性，确保没有一条路径会比其他路径长出两倍，因而，红黑树是接近平衡的二叉树。这就使得红黑树的时间复杂度大大降低。

所以，用红黑树替代单链表会降低集合中元素的访问速度。

## 18-3：为什么不把链表全部换为红黑树

1. 链表的结构比红黑树简单，构造红黑树要比构造链表复杂，所以在链表的节点不多的情况下，从整体的性能看来，如果把链表全部换为红黑树，效率反而更低。
2. HashMap频繁的resize（扩容），扩容的时候需要重新计算节点的索引位置，也就是会将红黑树进行拆分和重组，其实这是很复杂的，这里涉及到红黑树的着色和旋转，所以为链表树化设置一个阀值是非常有必要的。

## 18-4：为什么是使用红黑树而不是AVL树？

在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，如果插入时间过长必然等待时间更长。同时因为AVL树需要更高的旋转次数才能在修改时正确地重新平衡数据结构，所以红黑树相对AVL树他的插入更快！

## 18-5：为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？

在JDK1.7中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用

## 18-6：为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）

1. 中间有个差值7可以有效防止链表和树频繁转换，降低效率

2. 由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。

## 18-7：扰动函数以及作用

HashMap的hash方法。

为了防止一些实现比较差的hashCode()方法，使用扰动函数之后可以减少碰撞。


## 18-8：哈希冲突的解决方法

1. 拉链法
   
创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

2. 开发地址法

所有输入的元素全部存放在哈希表里，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。

## 18-9：HashMap的put操作

HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过计算判断当前元素存放的位置

1. 如果数组的这个位置是空的，把key放进去，put操作就完成了。

2. 如果数组位置不为空，就判断该元素与要存入的元素的?hash?值以及?key?是否相同，如果相同的话，直接覆盖

3. 若果不相等，这个元素必然是个链表。遍历链表逐一比对value，如果value在链表中不存在，就把新建节点，将value放进去，put操作完成。

4. 如果链表中value存在，则替换原节点的value，put操作完成。

5. 如果链表节点数已经达到8个，首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，如果达到64就将冲突的链表为红黑树。

## 18-10：HashMap的get操作

1. 先对key的hashCode()做hash，然后计算index。

2. 如果访问的节点是bucket里的第一个节点，则直接命中；

3. 如果有冲突，则通过key.equals(k)去树或链表中查找对应的entry。其中，树的时间复杂度为O(logn)；链表的时间复杂度为O
   (n)。

## 18-11：hashmap的get和put操作的时间复杂度

当HashMap的entry的数组足够大，key的hash值足够分散时，即是可以实现一个entry数组下标最多只对应了一个entry，此时get方法的时间复杂度可以达到O(1)。

但是如果所有的hash都一样，那么退化为线性查找，变成了O（n）

## 18-12：hashmap的String类型如何计算hashcode的

就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。

选择值31是因为它是素数。如果是偶数并且乘法运算溢出，则信息将丢失，因为乘以2等于移位。

31的一个不错的特性是乘法可以用移位和减法来代替，以获得更好的性能

哈希分布比较均匀。偶数的冲突率很高，只有少数例外。小乘数（1-20）的冲突率也很高

## 18-13:reHash过程

1. 首先创建一个比现有哈希表更大的新哈希表（expand）
2. 然后将旧哈希表的所有元素都迁移到新哈希表去（rehash）

## 18-14：hash函数以及常用方法

1. 直接定址法：直接以key或者key上加上某个常数作为哈希地址
2. 数字分析法：提取key中取值比较均匀的数字作为哈希地址
3. 除留余数法：用key除以某个不大于哈希表长度m的数，将所得余数作为哈希地址
4. 分段叠加法：按照哈希表地址位数将关键字分成了位数相等的几部分，其中最后一部分可以比较短，然后将这几部分相加，舍弃最高位仅为后的结果就是该关键字的哈希地址
5. 平方取中法：如果key的各部分分部都不均匀，可以先求出他的平方值，然后按照需求求取中间的几位作为哈希地址
6. 伪随机数法：采用一个伪随机数作为哈希函数


## 18-15：HashMap为什么要树化?

安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶中，则会形成一个链表。而链表查询时线性的，会严重影响存取的性能。

## 18-16：hashmap树化门槛及作用

* 链表长度大于8
* 数组长度大于64

作用：
这个本质上，是一个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶中，则会形成一个链表。而链表查询是线性的，会严重影响存取的性能。

## 18-17：hashmap的特性

1. 允许空键和空值（但空键只有一个，且放在第一位）
2. 元素是无序的，而且顺序会不定时改变
3. key不允许重复。

## 18-18:HashMap为什么可以插入空值?

HashMap在put的时候会调用hash()方法来计算key的hashcode值，可以从hash算法中看出当key==null时返回的值为0。因此key为
null时，hash算法返回值为0，不会调用key的hashcode方法。

## 18-19：JDK的hashmap与Redis的hashmap的区别

1. HashMap由于对链表size超过8采用二叉树结构，使得get操作随着激烈冲突导致变成一个类二叉树，时间复杂度为O(log(n))较
   redis的字典表O(n)，性能提升明显。
2. Redis的rehash由于采用渐进式的方式，对于大数据量下的rehash操作性能提升明显。这也是由于HashMap大部分用于临时且数据
   量不是特别大的数据，redis的hash用于存储避免大数据情况导致异常，双方的侧重点不一样。
3. Redis的单链表在冲突的情况下是从表头插入，时间复杂度为O(1)，而HashMap则为O(n)。


# 19.java基础-集合map-hashmap源码数值分析


## 19-1:HashMap中(tab.length - 1) & hash作用

1. 保证不会发生数组越界

2. 保证元素尽可能的均匀分布


## 19-2：请解释一下HashMap的参数loadFactor，它的作用是什么？

loadFactor表示HashMap的拥挤程度

作用：影响hash操作到同一个数组位置的概率。

## 19-3：HashMap的扩容因子为什么是0.75

1. 如果设置过大，如0.85，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，性能下降。
   
2. 如果设置过小，如0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。

## 19-4:为什么默认初始化桶数组大小为16

如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小，既不会像1，2，3那样放几个元素就扩容，也不会像几千几万那样可以只会利用一点点空间从而
造成大量的浪费。

## 19-5：hashmap为什么是2的次幂

取模运算可以变成位与运算，效率显著提高！但是要浪费一些空间。


# 20.java基础-集合map-hashmap线程问题


## 20-1:hashMap是否线程安全

在JDK1.7的时候没有加入同步锁保护，同时由于JDK1.7在并发执行put造作导致扩容行为从而导致环形链表，在获取数据遍历链表形成死循环，同时hashmap迭代器的fail-fast策略，一旦在使用地带器过程中出现并发操作，就会跑出异常。

那么JDK1.8虽然解决了死循环问题，但是还是没有同步锁保护机制，所以依然线程不安全

所以多线程情况下，首选线程安全的ConcurrentHashMap

## 20-2为什么hashmap中String、integer包装类适合作为key

1. 包装类重写了equals\hashcode方法，不容易出现hash值计算错误
2. 由于String类型是final的，保证了key的不可更改性

## 20-3：线程安全的Map

* Hashtable
* ConcurrentHashMap
* SynchronizedMap

1. Hashtable、SynchronizedMap源码中是使用synchronized来保证线程安全的
   
2. ConcurrentHashMap沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想，但是ConcurrentHashMap没有对整个hash表进行锁定，而是采用了分离锁（segment）的方式进行局部锁定。具体体现在，它在代码中维护着一个segment数组。
   
## 20-4：设计线程安全的map

1. 使用synchronized来进行约束：

2. 使用JDK1.5版本所提供的lock机制
   
3. 使用JDK提供的读写锁

4. 使用JDK1.5提供的ConcurrentHashMap,该类将Map的存储空间分为若干块,每块拥有自己的锁,减少了多个线程争夺同一个锁的情况


# 21.java基础-集合map-ConcurrentHashMap

## 21-1：ConcurrentHashMap的底层实现

从JDK1.7版本的数组+Segment+分段锁的方式实现，分段锁Segment，它类似于HashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock。ConcurrentHashMap内部使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。虽然在写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment这一种结构，但是带来的副作用是Hash的过程要比普通的HashMap要长

到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。数据结构上取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。为了保证线程安全，JDK1.8采用CAS+Synchronized保证线程安全。JDK1.8现调整为对每个数组元素加锁。由于定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样查询时间复杂度会得到改善

## 21-2：为何会出现ConcurrenHashMap?

1. 线程安全，读写还快，以空间换时间

2. 改善了hashmap迭代器出现的ConcurrentModificationException

* 由于ConcurrentHashMap对于会产生并发操作的node都会有加锁同步处理,且迭代器获取tab[index]开头node时都会从主存来获得,保证获取的数据是最新的，从而保证了迭代器在迭代过程中即使有put , remove等操作同时发生也可以保证迭代的安全性,不会出现ConcurrentModificationException

## 21-3：为什么ConcurrentHashMap（hashtable）为何不支持null键和null值

ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。

## 21-4：ConcurrentHashMap的put操作

1：首先判断是否初始化，如果没有初始化则进入initTable()方法进行初始化工作
2：如果已经初始化了，进入无限循环，原子判断key对应的数组下标是否有值了
3：如果key对应的下标没有值，通过:CAS原理插入，插入成功则退出循环，插入失败则继续循环，所以这种无锁的机制都是利用无限循环+CAS操作。
4：如果key对应的下标已经存在值,判断此时hash==MOVED,则进入帮助扩容。
5：如果key对应的下标已经存在值，但是hash!=MOVED,则需要对数组的这个下标进行加锁了，以保证线程的安全。
6：如果数组的这个下标是一个链表，则对操作链表（判断链表用hash>=0）
7：如果数组的这个下标是一个红黑树，则操作红黑树。
8：插入成功后，如果链表的长度已经达到了红黑树的阀门8，则首先判断此时数组的长度是否大于64，如果小于64则进行扩容，如果大于等于64则链表变成红黑树
9：判断容器是否扩容

## 21-5：分段锁原理

首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

# 22.java基础-集合map-TreeMap

## 22-1:TreeMap底层原理：

TreeMap是桶+红黑树的实现方式.TreeMap的底层结构就是一个数组,数组中每一个元素又是一个红黑树.当添加一个元素(key-value)的时候,根据key的hash值来确定插入到哪一个桶中(确定插入数组中的位置),当桶中有多个元素时,使用红黑树进行保存;当一个桶中存放的数据过多,那么根据key查找的效率就会降低

## 22-2：使用场景

1. 需要基于排序的统计功能：

2. 需要快速增删改查的存储功能：

3. 需要快速增删改查而且需要保证遍历和插入顺序一致的存储功能：

# 23.java基础-集合map-LinkedHashmap

## 23-1：linkedhashmap的底层原理

linkedhashmap继承HashMap，他比hashmap多维护了一个双向链表

# 24.java基础-集合map-HashTable

## 24-1：HashTable的底层原理

HashTable的与HashMap中相似，有一点重大区别就是所有的操作都是通过synchronized锁保护的。只有获得了对应的锁，才能进行后续的读写等操作。

# 25.java基础-集合list-ArrayList

## 25-1：数组(Array)和列表(ArrayList)有什么区别？ 什么时候应该使用 Array 而不是ArrayList？
1. 定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 
2. 容量上： Array 大小固定， ArrayList 的大小是动态变化的。 
3. 操作上： ArrayList 提供更多的方法和特性， 
   
使用基本数据类型或者知道数据元素数量的时候可以考虑 Array;ArrayList 处理固定数量的基本类型数据类型时会自动装箱来减少编码工作量，但是相对较慢。

# 26.java基础-集合list-vector


# 27.java基础-集合list-linkedlist


# 28.java基础-集合set-HashSet

## 28-1：hashset原理

HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复
出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。

# 29.java基础-集合set-TreeSet

## 29-1：TreeSet原理

# 30.java基础-集合set-LinkedSet

## 30-1：LinkedSet原理

# 31.java基础-集合-集合大比较（区别和使用场景）

主要从一下几方面分析

1. 线程
2. 底层
3. 时间复杂度
4. 内存
5. 其他

## 31-1：set和list、map的区别

1. List(对付顺序的好帮手)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象

2. Set(注重独一无二的性质):不允许重复的集合。不会有多个元素引用相同的对象。

3. Map(用Key来搜索的专家):使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

## 31-2：arraylist、linkedlist区别和适用场景

1. 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
2. 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构
3. 插入和删除是否受元素位置的影响： 
   ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 
   ② LinkedList 采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。
4. 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。<br>
5. 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）

<font color="#986078">使用场景：</font>

当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。

## 31-3：vector、Arraylist区别和适用场景

1. 线程：Vector是多线程安全的，
2. 底层：两个都是数组实现，
3. 时间复杂度：Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比
4. 内存：但是当空间不足的时候，两个类的增加方式是不同。vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%
5. 其他：Vector可以设置增长因子，而ArrayList不可以
   
<font color="#986078">使用场景：</font>

1. 安全因素
2. 在集合中使用数据量比较大的数据


## 31-4：HashMap、Treemap、linkedHashMap区别和适用场景

1. 线程安全：都不是线程安全的
2. 底层：TreeMap的底层是红黑树，能够按照键值进行升序排列，而HashMap与linkedHashMap是基于哈希表实现，
3. 时间复杂度：Treemap由于是红黑树，hashmap要更快一些，
4. 内存，由于Treemap使用的是红黑树，内存要大于另外两个， 又因为linkedhashmap多维护了一个双向链表，也要大约hashmap
5. 其他：hashmap排序是无序的。另外两种排序有序
   
<font color="#986078">使用场景：</font>

## 31-5：HashTable、Hashmap区别和适用场景

1. 线程安全，hashtable更加安全
2. 底层，hashtable底层加入了锁保护
3. 时间复杂度，由于加入了锁保护，hashtable时间复杂度要低于hashmap
4. 内存，
5. 其他

<font color="#986078">使用场景：</font>

1. 若在单线程中，我们往往会选择HashMap；
2. 而在多线程中，则会选择Hashtable。(02)，
3. 若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。


## 31-6： ConcurrentHashMap、Hashmap区别和适用场景

1. ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。
2. ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制。所以，前者线程安全的，后者不是线程安全的。
   
<font color="#986078">使用场景：</font>

1.安全因素

## 31-7： Hashset、Hashmap区别和适用场景

待定
1. 接口：实现了Map接⼝ 实现Set接⼝
2. 存储：存储键值对 仅存储对象
3. 添加元素：调⽤ put（）向map中添加元素       调⽤ add（） ⽅法向Set中添加元素
4. 计算：HashMap使⽤键（Key）计算Hashcode     HashSet使⽤成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()⽅法⽤来判断对象的相等性，
   
<font color="#986078">使用场景：</font>



## 31-8：treeset、hashset区别和适用场景

1. TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值
   HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束

2. HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例	

<font color="#986078">使用场景：</font>

在我们需要排序的功能时，我们才使用TreeSet。

## 31-9：JAVA集合类

1. Collection
   1. List
        * Arraylist： Object数组
        * Vector： Object数组
        * LinkedList： 双向链表(JDK1.6之前为循环链表， JDK1.7取消了循环)
    2. Set
        * HashSet（⽆序，唯⼀） : 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素
        * LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的
        * TreeSet（有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)
2. Map
    1. HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。 JDK1.8以后在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为8）时，将链表转化为红⿊树，以减少搜索时间
    2. LinkedHashMap： LinkedHashMap 继承⾃ HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问顺序相关逻辑。详细可以查看： 
    3. Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的
    4. TreeMap： 红⿊树（⾃平衡的排序⼆叉树）


# 32.java基础-设计类问题

## 32-1：如果想要一个key对应多个Value的话，怎么设计Map

https://blog.csdn.net/yanzhenjie1003/article/details/51550264?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase


## 32-2：插入一万个元素之后会不会扩容，扩容扩多少

HashMap 是否扩容，由 threshold 决定，而 threshold 又由初始容量和 loadFactor 决定。

1. HashMap 构造方法传递的 initialCapacity，它实际表示 table 的容量。
   
   * 只是代表了 table 数组容量为 1000

2. 构造方法传递的initialCapacity，最终会被tableSizeFor()方法动态调整为2的N次幂，以方便在扩容的时候，计算数据在newTable中的位置。

  * 虽然你传入了10000，但是实际传入的是10000/loadFactor，但是呢会调整为最接近的2 的 N 次幂
  
    * 如：实际传入了10000/0.75=13333，最接近的是2^13=16384，那么就采用16384
  
3. 如果设置了table的初始容量，会在初始化 table 时，将扩容阈值 threshold 重新调整为 table.size * loadFactor。

  * 那么可以储存的最大容量就是：16384*0.75=12288

## 32-3：创建一个对象HashMap<Integer,Integer> map=new HashMap<>先put(10),然后get(new Long(10))结果是多少？

为空，原因是

1. hashmap在存入的时候，先对key做一遍hash，以hash值作为数组下标，如果发现下标已有值，判断存的key跟传入的key是不是相同，如果相同覆盖，显然Integer 和 Long 肯定不是一个类型，所以 Long 123 和 Integer 123 hashmap会认为是 hash冲突

2. hashmap 在 get的时候，也是先做hash处理，根据hash值查找对应的数组下标查找,虽然存入Integer 123  根据 Long 123 来获取返回的 是 NULL

# 33.java基础-IO-各种流

## 33-1：为何还要有字符流

因为我们不知道编码类型很容易出现乱码，所以IO就提供了一个直接操作字符的接口

## 33-2：字节流和字符流区别

1. 字节流不会用到缓冲区(内存)的，而字符流在操作的时候是使用到缓冲区的
2. 字节流在操作文件时，即使不关闭资源，文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，只有在使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容
3. 字节流:处理字节和字节数组或二进制对象;字符流:处理字符、字符数组或字符串。

## 33-3：同步、异步与阻塞、非阻塞

同步：执行一个操作之后， 等待结果，然后执行其他后续的操作

异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没有执行完的操作

阻塞：进程给CPU传达一个任务后，一直等待CPU处理完成，然后执行后面的操作

非阻塞：进程给CPU传达一个任务后，继续处理其他的操作，隔段时间来询问之前的操作是否完成

## 33-4：BIO\NIO\AIO区别

BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。

（NIO与IO区别）NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的I/O模型，

1. IO流是阻塞的，NIO流是不阻塞的。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer
   中后，线程再继续处理数据。Java IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了

2. IO面向流(Stream oriented)，而NIO面向缓冲区(Buffer oriented)。在面向流的I/O中,可以将数据直接写入或者将数据直接读
   到Stream对象中。在从流读到缓冲区，因为Buffer是一个对象，它包含一些要写入或者要读出的数据。NIO是直接读到Buffer中进
   行操作。

3. NIO通过Channel（通道）进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因
   为 Buffer，通道可以异步地读写。

4. NIO有选择器，而IO没有。线程之间的切换对于操作系统来说是昂贵的，因此选择器用于使用单个线程处理多个通道提高系统效率
   选择器是有用的。

AIO: AIO 也就是NIO2。在引入了NIO的改进版,它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

## 33-5：linux的5种IO模型

1. 阻塞式IO模型

2. 非阻塞IO模型

3. IO复用模型

4. 信号驱动IO模型

5. 异步IO模型

## 33-6:IO多路复用

如果有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流，这样会造成CPU占有率会多高，这个实现方式及其的不合理。

所以人们提出了I/O多路复用这个模型，一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力

## 33-7：三种常用的实现方式-select

a. 从用户空间将fd_set拷贝到内核空间
　　b. 注册回调函数
　　c. 调用其对应的poll方法
　　d. poll方法会返回一个描述读写是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。
　　e. 如果遍历完所有的fd都没有返回一个可读写的mask掩码，就会让select的进程进入休眠模式，直到发现可读写的资源后，重新唤醒等待队列上休眠的进程。如果在规定时间内都没有唤醒休眠进程，那么进程会被唤醒重新获得CPU，再去遍历一次fd。
　　f. 将fd_set从内核空间拷贝到用户空间

select函数优缺点
　　缺点：两次拷贝耗时、轮询所有fd耗时，支持的文件描述符太小
　　优点：跨平台支持


## 33-8：三种常用的实现方式-poll

poll函数的调用过程（与select完全一致）

　　优点：连接数（也就是文件描述符）没有限制（链表存储）
　　缺点：大量拷贝，水平触发（当报告了fd没有被处理，会重复报告，很耗性能）

## 33-9：三种常用的实现方式-epoll

epoll的优点

没有最大并发连接的限制
只有活跃可用的fd才会调用callback函数
内存拷贝是利用mmap()文件映射内存的方式加速与内核空间的消息传递，减少复制开销。（内核与用户空间共享一块内存）
只有存在大量的空闲连接和不活跃的连接的时候，使用epoll的效率才会比select/poll高

## 33-10：三种常用的实现方式区别

(1)select==>时间复杂度O(n)

它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

(2)poll==>时间复杂度O(n)

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.

(3)epoll==>时间复杂度O(1)

epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。

例子：

1. select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子
2. poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神
3. epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.


# 22.java基础-反射


## 21-1：什么是反射

    从类或对象中推导出Class类，然后再从Class类中获得类的信息

## 21-2：反射的作用

1. 在运行时判断任意一个对象所属的类。

2. 在运行时判断任意一个类所具有的成员变量和方法。

3. 在运行时任意调用一个对象的方法

4. 在运行时构造任意一个类的对象

## 21-3：获取class对象方法

1. class.getClass()
2. Class.forname
3. ClassLoader.loadClass

## 21-4：Class.forName和classloader.loadClass的区别

1. 初始化不同:
   * Class.forName()会对类初始化，而loadClass()只会装载或链接。
   * foranme在类加载的时候会执行静态代码块，loadclass只有在调用newInstance方法的时候才会执行静态代码块
2. 类加载器不同:
   * Class.forName(String)方法(只有一个参数)，哪个调用了forname就用那个类加载器
   * ClassLoader.loadClass()方法是一个实例方法，调用时需要自己指定类加载器

## 21-3：哪些类不能反射

枚举，因为枚举类类的修饰abstract，所以没法实例化，反射也无能为力

## 21-3：Java创建对象的方式

1. 通过new语句实例化一个对象；
   
2. 通过反射机制创建对象。

3. 通过clone()方法创建一个对象；

4. 通过反序列化的方式创建对象。


## 21-4：设计模式——代理模式

一个代理将对象包装起来，使用这个代理对象来取代包装起来的对象，任何对包装对象的调用都要通过代理

## 21-5：静态代理的用途

1. 通过代理对象控制对真实对象的使用权限。

2. 通过使用一个代理小对象来代表一个真实的大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。

3. 通过代理可以在调用真实对象的方法的前后增加额外功能。


## 21-6：动态代理的几种实现方式(aop代理方式)

1. JDK动态代理
2. Cglib动态代理

## 21-7：两种方式区别

1. JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。

2. 如果目标类没有实现接口，那么会选择使用CGLIB来动态代理目标类。


## 21-8：什么是静态代理

事先写好代理类，可以手工编写，也可以用工具生成。

## 21-9：什么是静态代理（继续修改）

通过反射，在运行时才进行相关代理，而不像静态代理在编译器就已经确定被代理的对象


## 21-10：动态代理与静态代理的区别

1. 静态代理自己写逻辑代码，动态代理通过方法生成
2. 静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。


# 23.java基础-注解

## 22-1：元注解以及分类

定义其他注解的注解 ，共四个

1. @Target（表示该注解可以用于什么地方）

2. @Retention（表示再什么级别保存该注解信息）

3. @Documented（将此注解包含再javadoc中）

4. @Inherited（允许子类继承父类中的注解）
 
## 22-2 Java常用注解

1. @Override 表示当前方法覆盖了父类的方法

2. @Deprecation 表示方法已经过时,方法上有横线，使用时会有警告。

3. @SuppressWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)

4. SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。

5. @FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。

扩展[Spring常用注解]()

# 24.java基础-泛型

## 23-1：什么是泛型

1. 允许在定义类和接口的时候使⽤类型

2. 泛型可以提⾼代码的复⽤性

## 23-2：编译器如何处理泛型

1. Code specialization：在实例化一个泛型类或泛型方法时都产生一份新的字节码or二进制代码。

2. Code sharing：对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。

## 23-3：为什么Java要用这种编译器

1. C++和C#是使用Code specialization的处理机制，他有几个缺点:
   * 导致代码膨胀。
   * 在引用类型系统中，浪费空间

2. Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。

## 23-4: 什么是类型擦除

Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。

## 23-5：类型擦除过程

1. 将所有的泛型参数用最顶级的父类型进行替换。 

2. 移除所有的类型参数

## 23-6：泛型带来的问题

1. 虚拟机中没有泛型，只有普通类和普通方法,所有泛型类的类型参数在编译时都会被擦除,泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。 

2. 创建泛型对象时需要指明类型，让编译器尽早的做参数检查

3. 不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。 

4. 静态变量是被泛型类的所有实例所共享的。
    
5. 泛型的类型参数不能用在Java异常处理的catch语句中。

## 23-7：List泛型和原始类型List之间的区别?

 List<Object>和原始类型List之间的区别?
1. 在编译时编译器不会对原始类型进行类型安全检查，会对带参数的类进行检查
2. 你可以把任何带参数的类型传递给原始类型List，但是list会产生编译错误

## 23-8：List泛型和原始类型List泛型之间的区别?

List<?>和原始类型List<Object>之间的区别?

List<?>是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。

# 25-java基础-泛型应用

## 24-1:子类继承父类的public可以写成private吗

可以写，但是变为private之后，需要对方法重写写get/set方法

## 24-2：多态时是否会出现类型擦除

会出现类型擦除

编译器在编译一个继承自泛型类的子类时，为了方法覆盖的签名匹配，保留泛型类型的多态性，会生成一个桥接方法

# 26-java基础-异常

## 26-1:异常的分类

1. Error表⽰系统级的错误，是java运⾏环境内部错误或者硬件问题，不能指望程序来处理这样的问题

2. Exception 表⽰程序需要捕捉、 需要处理的常， 是由与程序设计的不完善⽽出现的问题， 程序必须处理的问题。

## 26-2:Java 中的两种异常类型是什么？ 他们有什么区别？

Java 中有两种异常： 受检查的(checked)异常和不受检查的(unchecked)异常。

1. 不受检查的异常不需要在方法或者是构造函数上声明 
2. 受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。

## 26-3：异常类型

0. Java中的异常， 主要可以分为两⼤类——受检异常（ checked exception） 和 ⾮受检异常（ unchecked exception）

1. 受检异常

这种异常在IO操作中⽐较多。 ⽬的就是告诉这个⽅法的调⽤者，我这个⽅法不保证⼀定可以成功， 是有可能找不到对应的⽂件 的， 你要明确的对这种情况做特殊处理哦。

2. 非受检异常

这种异常⼀般可以理解为是代码原因导致的。⽐如发⽣空指针、数组越界等。


## 26-4：什么是OOM？常见有哪些OOM？

1. Java堆溢出——OutOfMemoryError

原因：由于不断创建对象实例，当对象数量达到了最大堆的容量限制后产生内存溢出异常。

解决方法：

1)首先确认是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）；

2)如果是内存泄漏引起的，查看GC Roots引用链，找出为什么无法被垃圾回收的原因；

3)如果是内存溢出，检查虚拟机的堆参数（-Xmx最大值和-Xms最小值），对比物理内存看是否可以调大；

2. 虚拟机栈和本地方法栈溢出——StackOverflowError

原因：在单线程下，虚拟机栈容量太小或者定义了大量的本地变量

解决方法：增大虚拟机栈容量

原因：在多线程下，大量创建新线程，会抛出OOM，每个线程的栈分配的内存越大，越容易产生；

解决方法：减少线程产生、降低最大堆、减少栈容量；

3. 运行时常量池溢出

原因：代码在运行时创建了大量的常量，超出了常量池上限；

解决方法：通过修改-XX:PermSize和-XX:MaxPermSize参数来修改方法区大小，从而修改常量池大小；

4.方法区溢出

原因：在运行时，ClassLoader动态加载了大量的Class信息，超出方法区上限；

解决方法：通过修改参数来修改方法区大小；





## 25-3：异常链

是指在进⾏⼀个异常处理时抛出了另外⼀个异常， 由此产⽣了⼀个异常链条。

该技术⼤多⽤于将“ 受检查异常” （ checked exception） 封装成为“⾮受检查异常”（ unchecked exception)或者RuntimeException。


# 27.java基础-常用类-String

## 23-1：String为什么是final的？

1. 它创建的时候HashCode就被缓存了，不需要重新计算，这样在键值对就运行很快
2. 为了线程安全，可以被多个线程调用
3. 只有字符串不变，才能实现字符串池，提高效率

## 23-2：拼接方式

1. 使用+
2. 使用concat
3. 使用StringBuilder
4. 使用StringBuffer
5. 使用StringUtils.join

## 23-3: String、StringBuffer和StringBuilder区别

1. 运行速度上：StringBuilder>StringBuffer>String(因为String每次都要生成新对象)

2. 线程安全：StringBuffer，String 

3. 是否可变：只有String不可变

4. 底层实现：StringBuffer用了同步块synchronized

## 23-4：StringBuffer如何实现线程安全

直接通过synchronized 关键字来实现同步操作

## 23-6：String 和 char[] 数组谁更适合存密码

相对来说是String更合适，原因是底层有final关键字进行了修饰

## 23-7：String str = new String("abc");创建了几个对象-百度，京东

分情况讨论：
1. 如果常量池中没有abc，会创建两个
   * 一个是new  String 创建的一个新的对象
   * 一个是常量“abc”对象的内容创建出的一个新的String对象

2. 如果常量池有，会创建一个

[详情1](https://blog.csdn.net/qq_36470686/article/details/83444483)
[详情2](https://www.cnblogs.com/zhaideyou/p/5875175.html)

## 23-8：处理数据量较大的字符串用string还是stringbuilder，为什么

Stringbuilder，操作字符串效率更高

注：StringBuffer虽然也可以处理字符而且线程安全，但是处理字符相对Stringbuilder慢

## 23-9：为什么StringBuffer和StringBuilder比String更快（不变性）

1. string类设计成final类型，每次有修改操作时，都会赋值给新的对象。

2. 因为赋值给新的对象，原来的对象就不再引用，就会进行回收。

3. 因为string拼接的扩容机制，当在某个点上，会发生oom(内存用完了)

## 23-10：如何把一段逗号分割的字符串转换成一个数组?
如果不查 jdk api，我很难写出来！我可以说说我的思路：
1 用正则表达式，代码大概为： String [] result = orgStr.split(“,”);
2 用 StingTokenizer 


# 28.java基础-常用类-枚举

## -1：enum线程安全

## -2: switch 是否可用于String类型的判断，Java哪个版本之后有此功能的

JDK1.7开始支持

# 29.Java基础-常用类-时间类

## 29-1：SimpDateFormat是线程不安全的类，不要定义为static变量，如果定义，必须加锁或工具类

1. SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。

2. 由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。

解决方案：
1. SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。
2. 通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。
3. ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象


# 30.java基础-常用类-Object类

## 30-1:Object类有哪些方法

1. clone方法
2. getClass方法
3. toString方法
4. finalize方法
5. equals方法
6. hashcode方法
7. wait方法
8. notify方法
9. notifyAll方法

## 30-2：为什么操作线程方法会在Object对象中

1. 这些方法存在于同步中；
2. 使用这些方法必须标识同步所属的锁；
3. 锁可以是任意对象，所以任意对象调用方法一定定义在Object类中。

# 31.java基础-序列化

## -1：什么是序列化和饭序列化

1. 序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。

2. 反序列化是序列化的逆操作。

## -2：序列化的作用

1. Java远程方法调用
2. 对JavaBean进行序列化

## -2：java对象如何实现序列化

  * 实现Serializable接口
  * 实现ExternalSeri alizable方法

## -3：java对象如何实现反序列化

  * 实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法。
  * 实现externalSerializable接口的方法在反序列化时会调用构造方法。

## -4：哪些不会被序列化

1. 被static修饰的属性不会被序列化
2. 对象的类名、属性都会被序列化,方法不会被序列化


## -5：序列化协议有哪些

1. COM,COM的序列化的原理利用了编译器中虚表,使得其学习成本巨大.
2. CORBA，COBRA的主要问题是版本之间兼容性较差,以及使用复杂晦涩.
3. XML&5OAP，无论是性能还是间接性比较差
4. Thrift在时空开销上不太理想
5. JSON，序列化后数据更加简洁，而且解析速度较快
6. protobuf、avro不仅兼容json格式，解析速度更快

## -3:该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？

这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。

## -4: 什么是serialVersionUID

1. 这样做是为了serialVersionUID是用来验证版本一致性的，保证安全的，因为⽂件存储中的内容可能被篡改。
2. 在进⾏反序列化时， JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化， 否则就会出现序列化版本不⼀致的异常






