<!-- TOC -->

- [1.类加载](#1类加载)
  - [1.1：类的生命周期](#11类的生命周期)
  - [1.2：类的加载过程](#12类的加载过程)
  - [1.3：类加载机制](#13类加载机制)
  - [1.4：知道哪些类加载器?](#14知道哪些类加载器)
- [2.双亲委派模型](#2双亲委派模型)
  - [2-1：双亲委派模型流程](#2-1双亲委派模型流程)
  - [2-2：双亲委派模型带来了什么好处呢？](#2-2双亲委派模型带来了什么好处呢)
  - [2-3：如果我们不想⽤双亲委派模型怎么办？](#2-3如果我们不想双亲委派模型怎么办)
  - [2-4：自己写一个类能不能被加载？](#2-4自己写一个类能不能被加载)
- [3.垃圾回收](#3垃圾回收)
  - [3-1：如何判断对象已经死亡？](#3-1如何判断对象已经死亡)
  - [3-2：强、软、弱、虚引用](#3-2强软弱虚引用)
  - [3-3：如何减少 GC 的次数](#3-3如何减少-gc-的次数)
  - [3-4：GC 是什么?为什么要有 GC?](#3-4gc-是什么为什么要有-gc)
  - [3-5：垃圾回收的优点](#3-5垃圾回收的优点)
  - [3-6：垃圾回收器的基本原理是什么？](#3-6垃圾回收器的基本原理是什么)
  - [3-7：什么样的对象需要回收](#3-7什么样的对象需要回收)
  - [3-8：可作为GC Roots的对象？](#3-8可作为gc-roots的对象)
  - [3-9：垃圾回收器可以马上回收内存吗？](#3-9垃圾回收器可以马上回收内存吗)
  - [3-10：有什么办法主动通知虚拟机进行垃圾回收？](#3-10有什么办法主动通知虚拟机进行垃圾回收)
  - [3-11：垃圾收集算法](#3-11垃圾收集算法)
  - [3-12：Minor Gc和Full GC 有什么不同呢？](#3-12minor-gc和full-gc-有什么不同呢)
  - [3-13：何时发生full gc](#3-13何时发生full-gc)
- [4.常⻅的垃圾回收器有那些?](#4常的垃圾回收器有那些)
  - [4-1：Serial收集器](#4-1serial收集器)
  - [4-2：ParNew收集器](#4-2parnew收集器)
  - [4-3：Parallel Scavenge收集器](#4-3parallel-scavenge收集器)
  - [4-4：Serial Old收集器](#4-4serial-old收集器)
  - [4-5：Parallel Old收集器](#4-5parallel-old收集器)
  - [4-6：CMS收集器](#4-6cms收集器)
  - [4-7：G1收集器](#4-7g1收集器)
  - [4-8：吞吐有限和响应有限的垃圾收集器如何选择](#4-8吞吐有限和响应有限的垃圾收集器如何选择)
- [5.Java内存结构（JMM）](#5java内存结构jmm)
  - [5-0：简述（理解即可）](#5-0简述理解即可)
  - [5-1：为什么需要Java内存模型？](#5-1为什么需要java内存模型)
  - [5-2：什么是JMM](#5-2什么是jmm)
  - [5-3：什么是Java内存模型？](#5-3什么是java内存模型)
  - [5-4：Java内存模型的两大内存是啥？](#5-4java内存模型的两大内存是啥)
  - [5-5：内存如何工作](#5-5内存如何工作)
  - [5-6：Java内存模型三大特性](#5-6java内存模型三大特性)
  - [5-7：jvm内存结构](#5-7jvm内存结构)
  - [5-8：程序计数器为什么是私有的?](#5-8程序计数器为什么是私有的)
  - [5-9：虚拟机栈和本地⽅法栈为什么是私有的?](#5-9虚拟机栈和本地法栈为什么是私有的)
  - [5-10：堆和栈的区别是什么？](#5-10堆和栈的区别是什么)
  - [5-11：Java中的数组是存储在堆上还是栈上的？](#5-11java中的数组是存储在堆上还是栈上的)
  - [5-12：Java 8的metaspace (元空间)](#5-12java-8的metaspace-元空间)
  - [5-13：为什么要进行元空间代替持久代呢?](#5-13为什么要进行元空间代替持久代呢)
  - [5-14：Java中的对象一定在堆上分配内存吗？](#5-14java中的对象一定在堆上分配内存吗)
  - [5-15：怎么如何获取堆和栈的dump文件？](#5-15怎么如何获取堆和栈的dump文件)
  - [5-16：不同的虚拟机在实现运行时内存的时候有什么区别？](#5-16不同的虚拟机在实现运行时内存的时候有什么区别)
- [6.新生代， 老年代， 持久代](#6新生代-老年代-持久代)
  - [6-1：新生代， 老年代， 持久代？ 各存了什么？](#6-1新生代-老年代-持久代-各存了什么)
  - [6-2:什么时候进行老年代](#6-2什么时候进行老年代)
- [7. HotSpot虚拟机对象](#7-hotspot虚拟机对象)
  - [7-1：说⼀下Java对象的创建过程](#7-1说下java对象的创建过程)
  - [7-2：内存分配的两种⽅式选择](#7-2内存分配的两种式选择)
  - [7-3：虚拟机如何保证线程安全](#7-3虚拟机如何保证线程安全)
  - [7-4：对象的访问定位有哪两种⽅式?](#7-4对象的访问定位有哪两种式)
  - [7-5：访问定位两种方式的优缺点](#7-5访问定位两种方式的优缺点)
  - [7-6：对象分配规则](#7-6对象分配规则)
- [8.内存泄露与内存溢出](#8内存泄露与内存溢出)
  - [8-1：什么是内存泄漏](#8-1什么是内存泄漏)
  - [8-2：什么是内存溢出](#8-2什么是内存溢出)
  - [8-3：内存溢出， 内存泄漏区别？](#8-3内存溢出-内存泄漏区别)
  - [8-4：如何避免内存泄露、 溢出？](#8-4如何避免内存泄露-溢出)
  - [8-5：如何检测内存泄露？](#8-5如何检测内存泄露)
  - [8-6：java中会存在内存泄露呢？什么时候发生](#8-6java中会存在内存泄露呢什么时候发生)
- [9.调优工具](#9调优工具)
  - [9-1：调优工具有哪些？](#9-1调优工具有哪些)
- [10.JVM进程有哪些线程启动? (拼多多)](#10jvm进程有哪些线程启动-拼多多)
- [11.jvm启动模式之client 与server](#11jvm启动模式之client-与server)
- [12.简述JVM中静态分派和动态分派(引申:重载和重写)。](#12简述jvm中静态分派和动态分派引申重载和重写)

<!-- /TOC -->


# 1.类加载

## 1.1：类的生命周期

类的生命周期包括：加载、连接、初始化、使用和卸载

## 1.2：类的加载过程

类的加载过程分为：加载->连接->初始化。连接过程又可分为三步:验证->准备->解析

1. 加载，

      1. 通过全类名获取定义此类的二进制字节流
      2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

2. 连接，连接又包含三块内容：验证、准备、初始化。
   * 1）验证，文件格式验证、元数据验证、字节码验证、符号引用验证；
   * 2）准备，为类的静态变量分配内存，并将其初始化为默认值；
   * 3）解析，虚拟机将常量池内的符号引用转换为直接引用

3. 初始化，开始执行java代码

4. 使用，new出对象程序中使用

5. 卸载，执行垃圾回收
   
    卸载类需要满足3个要求:
         1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
         2. 该类没有在其他任何地方被引用
         3. 该类的类加载器的实例已被GC

* 理解：在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 1.3：类加载机制

1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用
   另外一个类加载器来载入

2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，
   只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，
   必须重启JVM，程序的修改才会生效

## 1.4：知道哪些类加载器?

书本

# 2.双亲委派模型

## 2-1：双亲委派模型流程

书本

## 2-2：双亲委派模型带来了什么好处呢？

书本

## 2-3：如果我们不想⽤双亲委派模型怎么办？

书本

## 2-4：自己写一个类能不能被加载？

书本


# 3.垃圾回收

## 3-1：如何判断对象已经死亡？

## 3-2：强、软、弱、虚引用

## 3-3：如何减少 GC 的次数

1. 对象不用时最好显示置为 NULL

2. 尽量少使用 System,gc()

3. 尽量少使用静态变量

4. 尽量使用 StringBuffer,而不使用 String 来累加字符串
5. 分散对象创建或删除的时间

6. 尽量少用 finaliza 函数

7. 如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory

8. 能用基本类型入 INT 就不用对象 Integer

9. 增大-Xmx 的值

## 3-4：GC 是什么?为什么要有 GC?

GC是垃圾收集的意思

内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， Java 语言没有提供释放已分配内存的显示操作方法

## 3-5：垃圾回收的优点

1. 可以有效的防止内存泄露
2. 有效的使用可以使用的内存。

## 3-6：垃圾回收器的基本原理是什么？

对于 GC 来说，当程序员创建对象时， GC 就开始监控这个对象的地址、大小以及使用情况。
通常， GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当 GC 确定一些对象为"不可达"时， GC 就有责任回收这些内存空间。

## 3-7：什么样的对象需要回收

对象到GC Roots没有引用链， 那么这个对象不可用， 需要回收

## 3-8：可作为GC Roots的对象？

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法引用的对象

## 3-9：垃圾回收器可以马上回收内存吗？

不可以？？？？？？

## 3-10：有什么办法主动通知虚拟机进行垃圾回收？

可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。

## 3-11：垃圾收集算法

1. 标记-清除算法
   
算法分为“标记”和“清除”阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不⾜进
⾏改进得到。这种垃圾收集算法会带来两个明显的问题：
1. 效率问题
2. 空间问题（标记清除后会产⽣⼤量不连续的碎⽚）

2. 复制算法

为了解决效率问题， 它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空
间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。

3. 标记-整理算法

根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后
直接清理掉端边界以外的内存。

4. 分代收集算法

根据对象存活周期的不同将内存分为⼏块。⼀般将java堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

## 3-12：Minor Gc和Full GC 有什么不同呢？

⼤多数情况下，对象在新⽣代中eden 区分配。当 eden 区没有⾜够空间进⾏分配时，虚拟机将发起⼀次Minor GC。

1. 新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， Minor GC⾮常频繁，回收速度⼀般也⽐较快。

2. ⽼年代GC（Major GC/Full GC） :指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的Minor GC（并⾮绝对）， 
   Major GC的速度⼀般会⽐Minor GC的慢10倍以上。


## 3-13：何时发生full gc

1. System.gc()方法的调用 ，system.gc(), 此方法的调用是建议JVM进行Full GC, 可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。 

2. old/Tenured 空间不足 

3. perm/metaspace 空间不足

4. CMS GC时出现promotion failed和concurrent mode failure 

5. 判断当前新生代的对象是否能够全部顺利的晋升到老年代，如果不能，就提早触发一次老年代的收集

# 4.常⻅的垃圾回收器有那些?

## 4-1：Serial收集器

不仅只会使⽤⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程，直到它收集结束。

优势：

1. 简单⽽⾼效
2. 由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。 

## 4-2：ParNew收集器

除了使⽤多线程进⾏垃圾收集外，其余⾏为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。

## 4-3：Parallel Scavenge收集器

关注点是吞吐量（⾼效率的利⽤CPU）。 

## 4-4：Serial Old收集器

⼀种⽤途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使⽤，另⼀种⽤途是作为CMS收集器的后备⽅案。

## 4-5：Parallel Old收集器

使⽤多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

## 4-6：CMS收集器

书本

## 4-7：G1收集器

书本

## 4-8：吞吐有限和响应有限的垃圾收集器如何选择

1. 吞吐量优先
新生代采用Paralle Scavenge,老年代采用Parallel Old.并配置 多个线程进行回收。设置参数来调整最大垃圾收集停顿时间和吞吐量的大小。
2. 响应时间优先
设置老年代的收集器是CMS (最短时间，spark streaming采用这个)。年轻代是ParnNiew(多线程)。

# 5.Java内存结构（JMM）

## 5-0：简述（理解即可）

JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；

## 5-1：为什么需要Java内存模型？

屏蔽各种硬件和操作系统的内存访问差异

## 5-2：什么是JMM

JMM是Java内存模型，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

## 5-3：什么是Java内存模型？

1. 定义程序中各种变量的访问规则

2. 把变量值存储到内存的底层细节

3. 从内存中取出变量值的底层细节

## 5-4：Java内存模型的两大内存是啥？

1. 主内存
  * Java堆中对象实例数据部分
  * 对应于物理硬件的内存
2. 工作内存
  * Java栈中的部分区域
  * 优先存储于寄存器和高速缓存

## 5-5：内存如何工作

线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存

## 5-6：Java内存模型三大特性

可见性（当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改）
原子性（一个操作或一系列操作是不可分割的，要么同时成功，要么同时失败）
有序性（变量赋值操作的顺序与程序代码中的执行顺序一致）



## 5-7：jvm内存结构

书本

## 5-8：程序计数器为什么是私有的?

程序计数器主要有两个作⽤：

1. 字节码解释器通过改变程序计数器来依次读取指令
2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置

如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。

程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。

## 5-9：虚拟机栈和本地⽅法栈为什么是私有的?

为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地⽅法栈是线程私有的。

## 5-10：堆和栈的区别是什么？

一个是线程独享的，一个是线程共享的

堆中主要存放对象实例。栈（局部变量表）中主要存放各种基本数据类型、对象的引用。

## 5-11：Java中的数组是存储在堆上还是栈上的？

在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；

所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。

## 5-12：Java 8的metaspace (元空间)

方法区是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区是JVM的规范，

永久代(PermGen space )是HotSpot对这种规范的实现。在JDK1.8中，HotSpot已经没有永久代，取而代之的是Metaspace( 元空间)。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。


## 5-13：为什么要进行元空间代替持久代呢?

1. 字符串存在永久代中，容易出现性能问题和内存溢出。

2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。


## 5-14：Java中的对象一定在堆上分配内存吗？

前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。

如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。

## 5-15：怎么如何获取堆和栈的dump文件？

Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。

可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。

## 5-16：不同的虚拟机在实现运行时内存的时候有什么区别？

前面提到过《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：
方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。
这一规定，可以说是给了虚拟机厂商很大的自由。
虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。
实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。
在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）


# 6.新生代， 老年代， 持久代

## 6-1：新生代， 老年代， 持久代？ 各存了什么？

1. 新生代
   * 存放存活率低的对象， 比如说新创建的对象一般放新生代（Eden区）

2. 老年代
   * 存放存活率较高的对象，新生代的对象经过minor gc后存活且survivor区可容纳则进入survivor区， 年龄为1，在survivor区每安全度过一次minor gc， 年龄加一， 一般年龄为15就进入老年代

3. 持久代
   * 就是方法区

## 6-2:什么时候进行老年代

(1)当对象首次创建时, 会放在新生代的eden区, 若没有GC的介入，会一直在eden区, GC后，是可能进入survivor区或者年老代

(2)当对象年龄达到一定的大小 ,就会离开年轻代， 进入老年代。 而对象的年龄是由GC的次数决定的

-XX:MaxTenuringThreshold=n　　新生代的对象最多经历n次GC， 就能晋升到老年代, 但不是必要条件 　　

-XX:TargetSurvivorRatio=n　　用于设置Survivor区的目标使用率，即当survivor区GC后使用率超过这个值, 就可能会使用较小的年龄作为晋升年龄

(3)除年龄外, 对象体积也会影响对象的晋升的, 若对象体积太大, 新生代无法容纳这个对象

-XX:PretenureSizeThreshold　　即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对串行回收器以及ParNew回收有效, 而对ParallelGC回收器无效

# 7. HotSpot虚拟机对象

## 7-1：说⼀下Java对象的创建过程

Step1:类加载检查
虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

Step2:分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

内存分配的两种方式：（补充内容，需要掌握）

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

内存分配的两种方式

内存分配并发问题（补充内容，需要掌握）

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
Step3:初始化零值
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

Step4:设置对象头
初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

Step5:执行 init 方法
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 7-2：内存分配的两种⽅式选择

分配⽅式有 “指针碰撞” 和 “空闲列表” 两种

选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC收集器的算法是"标记-清除"，还是"标记-整理"，

## 7-3：虚拟机如何保证线程安全

1. CAS+失败重试： 虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
2. TLAB： 为每⼀个线程预先在Eden区分配⼀块内存， JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分配

## 7-4：对象的访问定位有哪两种⽅式?

①使⽤句柄

   * 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池， reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
②直接指针

  * 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址


## 7-5：访问定位两种方式的优缺点

1. 使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。
2. 使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。

## 7-6：对象分配规则

1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。

2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。

3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。

4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 


# 8.内存泄露与内存溢出

## 8-1：什么是内存泄漏

指一个不再被程序使用的对象或变量一直被占据在内存中。 

## 8-2：什么是内存溢出

指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，

## 8-3：内存溢出， 内存泄漏区别？

1. 内存泄露积累起来将导致内存溢出。

2. 内存泄露可以通过完善代码来避免； 内存溢出可以通过调整配置来减少发生频率， 但无法彻底避免。

## 8-4：如何避免内存泄露、 溢出？

1. 尽早释放无用对象的引用。
2. 使用临时变量的时候， 让引用变量在退出活动域后自动设置为null， 暗示垃圾收集器来收集该对象， 防止发生内存泄露。
3. 程序进行字符串处理时， 尽量避免使用String， 而应使用StringBuffer， 因为每一个String对象都会独立占用内存一块区域

## 8-5：如何检测内存泄露？

可以通过一些性能监测分析工具， 如 JProfiler、 Optimizeit Profiler。

## 8-6：java中会存在内存泄露呢？什么时候发生

会存在内存泄露

但是也有几种情况会造成内存泄漏：

1. 静态集合类，容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。

2. 各种连接，如数据库连接、网络连接和IO连接等。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，将会造成大量的对象无法被回收，从而引起内存泄漏。

3. 变量不合理的作用域。一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。

4. 内部类持有外部类，由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

5. 改变哈希值，造成内存泄露

# 9.调优工具

## 9-1：调优工具有哪些？

常用调优工具分为两类

1. jdk自带监控工具：jconsole和jvisualvm，
2. 第三方监控工具：MAT(Memory Analyzer Tool)、GChisto。

jconsole，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控

jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。

MAT，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

GChisto，一款专业分析gc日志的工具


# 10.JVM进程有哪些线程启动? (拼多多)

1. main主线程，执行我们指定的启动类的main方法
2. Reference Handler处理引 用的线程，用于处理引用对象本身(软引用、弱引用、虚引用)的垃圾回收问题
3. Finalizer调用对象的finalize方法的线程，就是垃圾回收的线程
4. Signal Dispatcher分发处理发送给JVM信号的线程
5. Attach Listener负责接收外部的命令的线程

# 11.jvm启动模式之client 与server

jvm启动时，通过-server 或-client参数指定启动模式。

(1)编译器方面:
当虚拟机运行在client 模式时，使用的是一一个代号为 c1的轻量级编译器，而server模式启动时，虚拟机采用的是相对重量级，代号为c2的编译器: c2编译器比cl编译器编译的相对彻底，服务起来之后，性能高。

(2)gc方面:
cilent模式下的新生代(Serial 收集器)和老年代(Serial Old)选择的是串行gc server模式下的新生代选择并行回收ge,老年代选择并行ge

(3)启动方面:
client模式启动快，编译快，内存占用少，针对桌面应用程序设计，优化客户端环境的启动时间。server模式启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用设计，优化服务器环境的最大化程序执行速度

# 12.简述JVM中静态分派和动态分派(引申:重载和重写)。

1.静态分派:依赖静态类型定位方法的分派，发生在编译时期，奥型应用为方法的秋.
(重载的参数是通过静态类型确定的，直接调用父类)
2、动态分配:在运行时期根据实际类型来确定方法的分派，发生在程序运行时，
典型应用
是方法的重写，也是多态的一种体现。 根据转型来确定是否调用父类还是子类的方法。
虚方法和非虚方法:
(1)非虚方法(所有statie方法+final/private方法)通过invokespecial指令调用，对这个
非虚方法的符号引用将转为对应的直接引用，即转为直接引用方法，在编译完成时就确定唯
一的调用方法。
(2)虚方法是通过invokevirtual 指令调用，且会有静态或者动态分派分派。具体先根据编
译期时方法接收者和方法参数的静态类型来分派，再在运行期根据只根据方法接收者的实际
类型来分派。
 