# 1.类加载

## 1.1：类的生命周期

类的生命周期包括：加载、连接、初始化、使用和卸载

## 1.2：类的加载过程

类的加载过程分为：加载->连接->初始化。连接过程又可分为三步:验证->准备->解析

1. 加载，

      1. 通过全类名获取定义此类的二进制字节流
      2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

2. 连接，连接又包含三块内容：验证、准备、初始化。
   * 1）验证，文件格式验证、元数据验证、字节码验证、符号引用验证；
   * 2）准备，为类的静态变量分配内存，并将其初始化为默认值；
   * 3）解析，虚拟机将常量池内的符号引用转换为直接引用

3. 初始化，开始执行java代码

4. 使用，new出对象程序中使用

5. 卸载，执行垃圾回收
   
    卸载类需要满足3个要求:
         1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
         2. 该类没有在其他任何地方被引用
         3. 该类的类加载器的实例已被GC

* 理解：在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。




## 5.4:类加载机制

1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入

2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效


## 5.3:知道哪些类加载器?

1. BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载%JAVA_HOME%/lib ⽬录下的jar包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类。

2. ExtensionClassLoader(扩展类加载器) ：主要负责加载⽬录 %JRE_HOME%/lib/ext ⽬录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。

3. AppClassLoader(应⽤程序类加载器) :⾯向我们⽤户的加载器，负责加载当前应⽤classpath下的所有jar包和类。


# 6.双亲委派模型

## 6-1：双亲委派模型流程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

## 6-2：双亲委派模型带来了什么好处呢？

1. 系统类防止内存中出现多份同样的字节码

2. 保证Java程序安全稳定运行


## 6-3：如果我们不想⽤双亲委派模型怎么办？

为了避免双亲委托机制，我们可以⾃⼰定义⼀个类加载器，然后重载 loadClass() 即可。


## 6-4：如何⾃定义类加载器?

除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承⾃ java.lang.ClassLoader 。如果我们要⾃定义⾃⼰的类加载器，很明显需要继承 ClassLoader 。






















# 1.Java内存

## 1-0：简述（理解即可）

JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；

## 1-1：jvm内存结构

1. Java堆,几乎所有的对象实例都在这里分配内存。

2. 方法区,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

3. 程序计数器,它的作用可以看做是当前线程所执行的字节码的行号指示器。

4. JVM栈,虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

5. 本地方法栈,是为虚拟机使用到的Native方法服务。

方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。

## -5：程序计数器为什么是私有的?

程序计数器主要有两个作⽤：

1. 字节码解释器通过改变程序计数器来依次读取指令
2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置

如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。

程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。

## -6：虚拟机栈和本地⽅法栈为什么是私有的?

为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地⽅法栈是线程私有的。

## 1-2：新生代， 老年代， 持久代？ 各存了什么？

1. 新生代
   * 存放存活率低的对象， 比如说新创建的对象一般放新生代（Eden区）

2. 老年代
   * 存放存活率较高的对象，新生代的对象经过minor gc后存活且survivor区可容纳则进入survivor区， 年龄为1，在survivor区每安全度过一次minor gc， 年龄加一， 一般年龄为15就进入老年代

3. 持久代
   * 就是方法区

## -4:什么时候进行老年代

1. 大对象
2. 空间分配担保
3. 年龄判定


## 1-3:Students = new Student(};在内存中做了哪些事情?

1. 加载Student.class文件进内存
2. 在栈内存为s开辟空间
3. 在堆内存为学生对象开辟空间
4. 对学生对象的成员变量进行默认初始化
5. 对学生对象的成员变量进行显示初始化
6. 通过构造方法对学生对象的成员变量赋值
7. 学生对象初始化完毕,把对象地址赋值给s变量

## -5：Java 8的metaspace (元空间)

方法区是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区是JVM的规范，

永久代(PermGen space )是HotSpot对这种规范的实现。在JDK1.8中，HotSpot已经没有永久代，取而代之的是Metaspace( 元空间)。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。


## -6：为什么要进行元空间代替持久代呢?

1. 字符串存在永久代中，容易出现性能问题和内存溢出。

2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。



## 2：说⼀下Java对象的创建过程

![avatar](http://code.clouddn.com/02_04_03_interview_jvm_01.jpg)

①类加载检查： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。

②分配内存： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。 分配⽅式有 “指针碰撞” 和 “空闲列表” 两种， 选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。

③初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。

④设置对象头： 初始化零值完成之后， 虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。

⑤执⾏ init ⽅法： 在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏ <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。




## 3.内存分配的两种⽅式选择

分配⽅式有 “指针碰撞” 和 “空闲列表” 两种

选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC
收集器的算法是"标记-清除"，还是"标记-整理"，


## 4.内存两种方式

![avatar](http://code.clouddn.com/02_04_03_interview_jvm_02.jpg)


## 5.虚拟机如何保证线程安全

1. CAS+失败重试： 虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
2. TLAB： 为每⼀个线程预先在Eden区分配⼀块内存， JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分配

##  对象的访问定位有哪两种⽅式?

①使⽤句柄

   * 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池， reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
②直接指针

  * 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址


## 访问定位两种方式的优缺点

1. 使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。
2. 使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。

## 说⼀下堆内存中对象的分配的基本策略


在堆中，eden区、 s0区、 s1区都属于新⽣代， tentired 区属于⽼年代。

⼤部分情况，对象都会⾸先在Eden区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊s0或者s1，并且对象的年龄还会加1，当它的年龄增加到⼀定程度，就会被晋升到⽼年代中。对象晋升到⽼年代的年龄阈值，另外，⼤对象和⻓期存活的对象会直接进⼊⽼年代。

##  Minor Gc和Full GC 有什么不同呢？

⼤多数情况下，对象在新⽣代中eden 区分配。当 eden 区没有⾜够空间进⾏分配时，虚拟机将发起⼀
次Minor GC。

1. 新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， Minor GC⾮常频繁，回收速度⼀般也
⽐较快。

2. ⽼年代GC（Major GC/Full GC） :指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的
Minor GC（并⾮绝对）， Major GC的速度⼀般会⽐Minor GC的慢10倍以上。


## 对象分配规则

1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。

2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。

3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。

4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 

## 如何判断对象是否死亡?

* 堆中⼏乎放着所有的对象实例，对堆垃圾回收前的第⼀步就是要判断哪些对象已经死亡（即不能再被任
何途径使⽤的对象）。

1. 引⽤计数法:给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。

2. 可达性分析算法:通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。

## 简单的介绍⼀下强引⽤,软引⽤,弱引⽤,虚引⽤

1. 强引⽤(StrongReference)
如果⼀个对象具有强引⽤，那就类似于必不可少的⽣活⽤品，垃圾回收器绝不会回收它。当内存空间不⾜， Java虚拟机宁愿抛出OutOfMemoryError(OOM)错误，使程序异常终⽌，也不会靠随意回收具有强引⽤的对象来解决内存不⾜问题。

2. 软引⽤(SoftReference)

如果⼀个对象只具有软引⽤，那就类似于可有可⽆的⽣活⽤品。如果内存空间⾜够，垃圾回收器就不会
回收它，如果内存空间不⾜了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以
被程序使⽤。

3. 弱引⽤(WeakReference)

如果⼀个对象只具有弱引⽤，那就类似于可有可⽆的⽣活⽤品。弱引⽤与软引⽤的区别在于：只具有弱
引⽤的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，⼀旦发现
了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存。

4. 虚引⽤（PhantomReference）

虚引⽤主要⽤来跟踪对象被垃圾回收的活动。

## 如何判断⼀个常量是废弃常量?

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引⽤该字符串常量的话，就说明常量
"abc" 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话， "abc" 就会被系统清理出常量池。

## 如何判断⼀个类是⽆⽤的类?

需要满足三个条件
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的⽅法。

# 2. 垃圾收集有哪些算法，各⾃的特点？

## 2-1：GC 是什么?为什么要有 GC?

GC是垃圾收集的意思

内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， Java 语言没有提供释放已分配内存的显示操作方法

## 2-2：如何减少 GC 的次数
1. 对象不用时最好显示置为 NULL

2. 尽量少使用 System,gc()

3. 尽量少使用静态变量

4. 尽量使用 StringBuffer,而不使用 String 来累加字符串
5. 分散对象创建或删除的时间

6. 尽量少用 finaliza 函数

7. 如果有需要使用经常用到的图片，可以使用软引用类型，将图片保存在内存中，而不引起 outofmemory

8. 能用基本类型入 INT 就不用对象 Integer

9. 增大-Xmx 的值


## 2-2：垃圾回收的优点

1. 可以有效的防止内存泄露
2. 有效的使用可以使用的内存。

## 2-3：垃圾回收器的基本原理是什么？

对于 GC 来说，当程序员创建对象时， GC 就开始监控这个对象的地址、大小以及使用情况。
通常， GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当 GC 确定一些对象为"不可达"时， GC 就有责任回收这些内存空间。

## 2-4：什么样的对象需要回收

对象到GC Roots没有引用链， 那么这个对象不可用， 需要回收

## 2-5：可作为GC Roots的对象？

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法引用的对象

## 2-4：垃圾回收器可以马上回收内存吗？

不可以？？？？？？

## 2-5：有什么办法主动通知虚拟机进行垃圾回收？

可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。

## 2-6：什么是内存泄漏

指一个不再被程序使用的对象或变量一直被占据在内存中。 

## 2-7：什么是内存溢出

指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，


## 2-8：内存溢出， 内存泄漏区别？

1. 内存泄露积累起来将导致内存溢出。

2. 内存泄露可以通过完善代码来避免； 内存溢出可以通过调整配置来减少发生频率， 但无法彻底避免。

## 2-9：如何避免内存泄露、 溢出？

1. 尽早释放无用对象的引用。
2. 使用临时变量的时候， 让引用变量在退出活动域后自动设置为null， 暗示垃圾收集器来收集该对象， 防止发生内存泄露。
3. 程序进行字符串处理时， 尽量避免使用String， 而应使用StringBuffer， 因为每一个String对象都会独立占用内存一块区域

## 2-10:如何检测内存泄露？

可以通过一些性能监测分析工具， 如 JProfiler、 Optimizeit Profiler。


## 2-7：java中会存在内存泄露呢？什么时候发生

会存在内存泄露

但是也有几种情况会造成内存泄漏：

1. 静态集合类，容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。

2. 各种连接，如数据库连接、网络连接和IO连接等。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，将会造成大量的对象无法被回收，从而引起内存泄漏。

3. 变量不合理的作用域。一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。

4. 内部类持有外部类，由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

5. 改变哈希值，造成内存泄露

## 2-1：标记-清除算法

算法分为“标记”和“清除”阶段：⾸先标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的
对象。它是最基础的收集算法，后续的算法都是对其不⾜进⾏改进得到。这种垃圾收集算法会带来两个
明显的问题：
1. 效率问题
2. 空间问题（标记清除后会产⽣⼤量不连续的碎⽚）


## 2-2:复制算法

为了解决效率问题， 它可以将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收。

## 2-3:标记-整理算法

根据⽼年代的特点特出的⼀种标记算法，标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接
对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。

## 2-4:分代收集算法

根据对象存活周期的不同将内存分为⼏块。⼀般将java堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

## 2-5:HotSpot为什么要分为新⽣代和⽼年代？

主要是为了提升GC效率。




# 3.常⻅的垃圾回收器有那些?

## -1：有哪些垃圾回收器

1. Serial收集器，只使用一个线程去回收，可能会产生较长的停顿。

2. ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。

3. Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。

4. Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法

5. CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

6. G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征

## -2：吞吐有限和响应有限的垃圾收集器如何选择

1. 吞吐量优先
新生代采用Paralle Scavenge,老年代采用Parallel Old.并配置 多个线程进行回收。设置参数来调整最大垃圾收集停顿时间和吞吐量的大小。
2. 响应时间优先
设置老年代的收集器是CMS (最短时间，spark streaming采用这个)。年轻代是ParnNiew(多线程)。



## 3-1:Serial收集器

不仅只会使⽤⼀条垃圾收集线程去完成垃圾收集⼯作，更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程，直到它收集结束。

优势：

1. 简单⽽⾼效
2. 由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。 

##  3-2：ParNew收集器

除了使⽤多线程进⾏垃圾收集外，其余⾏为（控制参数、收集算法、回收策略等等）和Serial收集器完全⼀样。

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。

## 3-3：Parallel Scavenge收集器

关注点是吞吐量（⾼效率的利⽤CPU）。 CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）。所谓吞吐量就是CPU中⽤于运⾏⽤户代码的时间与CPU总消耗时
间的⽐值。 Parallel Scavenge收集器提供了很多参数供⽤户找到最合适的停顿时间或最⼤吞吐量，如
果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀
个不错的选择。
新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。

## 3-4：Serial Old收集器

⼀种⽤途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使⽤，
另⼀种⽤途是作为CMS收集器的后备⽅案。

## 3-5:Parallel Old收集器

使⽤多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。


## 3-6:CMS收集器

CMS（Concurrent Mark Sweep）收集器是⼀种以获取最短回收停顿时间为⽬标的收集器。实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。

整个过程分为四个步骤：
1. 初始标记：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；
2. 并发标记：同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。
3. 重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对象的标记记录
4. 并发清除：开启⽤户线程，同时GC线程开始对为标记的区域做清扫。

主要优点： 

1. 并发收集
2. 低停顿。

缺点：
1. 对CPU资源敏感；
2. ⽆法处理浮动垃圾；
3. 它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。

## 3-7：G1收集器

主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征.

它具备⼀下特点：
1. 并⾏与并发： 部分其他收集器原本需要停顿Java线程执⾏的GC动作， G1收集器仍然可以通过并发的⽅式让java程序继续执⾏。

2. 分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概念。

3. 空间整合： G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。

4. 可预测的停顿：降低停顿时间、建⽴可预测的停顿时间模型

G1收集器的运作⼤致分为以下⼏个步骤：

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

# 4.类⽂件结构

## 4-1:介绍⼀下类⽂件结构




# 10.调优工具

## 调优工具有哪些？

常用调优工具分为两类

1. jdk自带监控工具：jconsole和jvisualvm，
2. 第三方监控工具：MAT(Memory Analyzer Tool)、GChisto。

jconsole，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控

jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。

MAT，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

GChisto，一款专业分析gc日志的工具


# 11.JVM进程有哪些线程启动? (拼多多)

1. main主线程，执行我们指定的启动类的main方法
2. Reference Handler处理引 用的线程，用于处理引用对象本身(软引用、弱引用、虚引用)的垃圾回收问题
3. Finalizer调用对象的finalize方法的线程，就是垃圾回收的线程
4. Signal Dispatcher分发处理发送给JVM信号的线程
5. Attach Listener负责接收外部的命令的线程

## 11-1:jvm启动模式之client 与server

jvm启动时，通过-server 或-client参数指定启动模式。

## 11-2:cilent模式与server模式的区别

(1)编译器方面:
当虚拟机运行在client 模式时，使用的是一一个代号为 c1的轻量级编译器，而server模式启动时，虚拟机采用的是相对重量级，代号为c2的编译器: c2编译器比cl编译器编译的相对彻底，服务起来之后，性能高。

(2)gc方面:
cilent模式下的新生代(Serial 收集器)和老年代(Serial Old)选择的是串行gc server模式下的新生代选择并行回收ge,老年代选择并行ge

(3)启动方面:
client模式启动快，编译快，内存占用少，针对桌面应用程序设计，优化客户端环境的启动时间。server模式启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用设计，优化服务器环境的最大化程序执行速度

## 11-3:简述JVM中静态分派和动态分派(引申:重载和重写)。
1.静态分派:依赖静态类型定位方法的分派，发生在编译时期，奥型应用为方法的秋.
(重载的参数是通过静态类型确定的，直接调用父类)
2、动态分配:在运行时期根据实际类型来确定方法的分派，发生在程序运行时，
典型应用
是方法的重写，也是多态的一种体现。 根据转型来确定是否调用父类还是子类的方法。
虚方法和非虚方法:
(1)非虚方法(所有statie方法+final/private方法)通过invokespecial指令调用，对这个
非虚方法的符号引用将转为对应的直接引用，即转为直接引用方法，在编译完成时就确定唯
一的调用方法。
(2)虚方法是通过invokevirtual 指令调用，且会有静态或者动态分派分派。具体先根据编
译期时方法接收者和方法参数的静态类型来分派，再在运行期根据只根据方法接收者的实际
类型来分派。
 