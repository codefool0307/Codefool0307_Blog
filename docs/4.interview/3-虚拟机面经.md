

## 类加载的过程


## Jvm区域。堆，栈，常量池等

## jvm 老年代什么时候对象会直接放在老年代。如果放不到 怎么办？ oom

## JVM垃圾回收算法(新生代和老年代)

## 为什么新生代和老年代采用不同的回收算法

## 

## jvm分区

## gc

## 类加载相关

？？？？不明

# 双亲委派模型

## -1：什么是双亲委派模型

每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤双亲委派模型。

即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。 
加载的时候，⾸先会把该请求委派该⽗类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。 当⽗类加载器为null时，会使⽤启动类加载器 BootstrapClassLoader 作为⽗类加载器。

## -2：双亲委派模型带来了什么好处呢？

双亲委派模型保证了Java程序的稳定运⾏，可以避免类的重复加载，也保证了Java的核⼼API不被篡改。

如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为 java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的 Object类。


## -3：如果我们不想⽤双亲委派模型怎么办？

为了避免双亲委托机制，我们可以⾃⼰定义⼀个类加载器，然后重载 loadClass() 即可。


## -4：如何⾃定义类加载器?

除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承⾃ java.lang.ClassLoader 。如
果我们要⾃定义⾃⼰的类加载器，很明显需要继承 ClassLoader 。


## JVM内存结构，

## OOM有哪些，

## 排查工具



## 1：介绍下 Java 内存区域(运⾏时数据区)




## 2：说⼀下Java对象的创建过程

![avatar](http://code.clouddn.com/02_04_03_interview_jvm_01.jpg)

①类加载检查： 虚拟机遇到⼀条 new 指令时，⾸先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。

②分配内存： 在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需的内存⼤⼩在类加载完成后便可确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从 Java 堆中划分出来。 分配⽅式有 “指针碰撞” 和 “空闲列表” 两种， 选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。

③初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。

④设置对象头： 初始化零值完成之后， 虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。

⑤执⾏ init ⽅法： 在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说，执⾏ new 指令之后会接着执⾏ <init> ⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。




## 3.内存分配的两种⽅式选择

分配⽅式有 “指针碰撞” 和 “空闲列表” 两种

选择以上两种⽅式中的哪⼀种，取决于 Java 堆内存是否规整。⽽ Java 堆内存是否规整，取决于 GC
收集器的算法是"标记-清除"，还是"标记-整理"，


## 4.内存两种方式

![avatar](http://code.clouddn.com/02_04_03_interview_jvm_02.jpg)


## 5.虚拟机如何保证线程安全

1. CAS+失败重试： 虚拟机采⽤ CAS 配上失败重试的⽅式保证更新操作的原⼦性。
2. TLAB： 为每⼀个线程预先在Eden区分配⼀块内存， JVM在给线程中的对象分配内存时，⾸先在TLAB分配，当对象⼤于TLAB中的剩余内存或TLAB的内存已⽤尽时，再采⽤上述的CAS进⾏内存分配

##  对象的访问定位有哪两种⽅式?

①使⽤句柄

   * 如果使⽤句柄的话，那么Java堆中将会划分出⼀块内存来作为句柄池， reference 中存储的就是对象的句柄地址，⽽句柄中包含了对象实例数据与类型数据各⾃的具体地址信息；
②直接指针

  * 如果使⽤直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，⽽reference 中存储的直接就是对象的地址


## 访问定位两种方式的优缺点

1. 使⽤句柄来访问的最⼤好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，⽽ reference 本身不需要修改。
2. 使⽤直接指针访问⽅式最⼤的好处就是速度快，它节省了⼀次指针定位的时间开销。

## 说⼀下堆内存中对象的分配的基本策略


在堆中，eden区、 s0区、 s1区都属于新⽣代， tentired 区属于⽼年代。

⼤部分情况，对象都会⾸先在Eden区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊s0或者s1，并且对象的年龄还会加1，当它的年龄增加到⼀定程度，就会被晋升到⽼年代中。对象晋升到⽼年代的年龄阈值，另外，⼤对象和⻓期存活的对象会直接进⼊⽼年代。

##  Minor Gc和Full GC 有什么不同呢？

⼤多数情况下，对象在新⽣代中eden 区分配。当 eden 区没有⾜够空间进⾏分配时，虚拟机将发起⼀
次Minor GC。

1. 新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， Minor GC⾮常频繁，回收速度⼀般也
⽐较快。

2. ⽼年代GC（Major GC/Full GC） :指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的
Minor GC（并⾮绝对）， Major GC的速度⼀般会⽐Minor GC的慢10倍以上。

## 如何判断对象是否死亡?

* 堆中⼏乎放着所有的对象实例，对堆垃圾回收前的第⼀步就是要判断哪些对象已经死亡（即不能再被任
何途径使⽤的对象）。

1. 引⽤计数法:给对象中添加⼀个引⽤计数器，每当有⼀个地⽅引⽤它，计数器就加1；当引⽤失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使⽤的。

2. 可达性分析算法:通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不可⽤的。

## 简单的介绍⼀下强引⽤,软引⽤,弱引⽤,虚引⽤

1. 强引⽤(StrongReference)
如果⼀个对象具有强引⽤，那就类似于必不可少的⽣活⽤品，垃圾回收器绝不会回收它。当内存空间不⾜， Java虚拟机宁愿抛出OutOfMemoryError(OOM)错误，使程序异常终⽌，也不会靠随意回收具有强引⽤的对象来解决内存不⾜问题。

2. 软引⽤(SoftReference)

如果⼀个对象只具有软引⽤，那就类似于可有可⽆的⽣活⽤品。如果内存空间⾜够，垃圾回收器就不会
回收它，如果内存空间不⾜了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以
被程序使⽤。

3. 弱引⽤(WeakReference)

如果⼀个对象只具有弱引⽤，那就类似于可有可⽆的⽣活⽤品。弱引⽤与软引⽤的区别在于：只具有弱
引⽤的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，⼀旦发现
了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存。

4. 虚引⽤（PhantomReference）

虚引⽤主要⽤来跟踪对象被垃圾回收的活动。

## 如何判断⼀个常量是废弃常量?

假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引⽤该字符串常量的话，就说明常量
"abc" 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话， "abc" 就会被系统清理出常量池。

## 如何判断⼀个类是⽆⽤的类?

需要满足三个条件
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的⽅法。

# 2. 垃圾收集有哪些算法，各⾃的特点？

## 2-1：


## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 


## 

## 

## 

## 