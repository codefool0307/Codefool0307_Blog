<!--
 * @Author: 孙浩然
 * @Date: 2020-07-13 07:35:01
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-08-26 18:01:37
 * @FilePath: \docs\4.interview\12-15-框架面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 

# 1.IOC

## 1-1：什么是IOC



## 什么是spring框架

Spring 是⼀种轻量级的控制反转和面向切面编程的容器框架，旨在提⾼开发⼈员的开发效率以及系统的可维护性。 

## 列举⼀些重要的Spring模块

1. Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该
   类库。主要提供 IoC 依赖注⼊功能。
2. Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。
3. Spring AOP ：提供了⾯向切⾯的编程实现。
4. Spring JDBC : Java数据库连接。
5. Spring JMS ： Java消息服务。
6. Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。
7. Spring Web : 为创建Web应⽤程序提供⽀持。



## @RestController vs @Controller

Controller 返回⼀个⻚⾯
单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况。


@RestController 返回JSON 或 XML 形式数据

但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，
这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）。

如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4 之后新加的注解）。


## IoC

IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。
在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开
发难度。

Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是SpringBoot 注解配置就慢慢开始流⾏起来。

## AOP
AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤
的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模
块间的耦合度，并有利于未来的可拓展性和可维护性。
Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK
Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候
Spring AOP会使⽤Cglib ，


## Spring AOP 和 AspectJ AOP 有什么区别？

Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，

如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐
Spring AOP 快很多。

## Spring 中的 bean 的作⽤域有哪些?
singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建⼀个新的 bean 实例。
request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。
session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。
global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已
经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于
portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有
不同的会话

## Spring 中的单例 bean 的线程安全问题了解吗？
⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问
题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程
安全问题。
常⻅的有两种解决办法：
1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2. 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的
⼀种⽅式）。

## @Component 和 @Bean 的区别是什么？
1. 作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。
2. @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤
@ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的
bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean 告诉
了Spring这是某个类的示例，当我需要⽤它的时候还给我。
3. @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来
注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来
实现。


## 将⼀个类声明为Spring的 bean 的注解有哪些?
我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配
的 bean 的类,采⽤以下注解可实现：
@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个
层，可以使⽤ @Component 注解标注。
@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。
@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据
给前端⻚⾯。



Spring中的这几个注解有什么区别：@Component 、@Repository、@Service、@Controller
@Component指的是组件，
@Controller，@Repository和@Service 注解都被@Component修饰，用于代码中区分表现层，持久层和业务层的组件，代码中组件不好归类时可以使用@Component来标注

当前版本只有区分的作用，未来版本可能会添加更丰富的功能




## 21-3：Spring常用注解

1. @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。

2. @Scope注解 作用域

3. @Lazy(true) 表示延迟初始化

4. @Service用于标注业务层组件

5. @Controller用于标注控制层组件@Repository用于标注数据访问组件，即DAO组件。

6. @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

7. @Scope用于指定scope作用域的（用在类上）

8. @PostConstruct用于指定初始化方法（用在方法上）

9. @PreDestory用于指定销毁方法（用在方法上）

10. @DependsOn：定义Bean初始化及销毁时的顺序

11. @Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常

12. @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired 

13. @Qualifier("personDaoBean") 存在多个实例配合使用

@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。

@PostConstruct 初始化注解

@PreDestroy 摧毁注解 默认 单例 启动就加载

## Spring中Bean的作用域


## Spring的AOP和IOC。写过哪些动态代理

## AOP的应用场景？

## Spring相关，SpringAOP底层怎么实现的

## 什么是SpringIOC?

## Spring的核心是什么

## AOP的应用场景

## spring如何解决循环依赖

Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，

一级缓存：存放完全实例化属性赋值完成的Bean，直接可以使用。
二级缓存：存放早期Bean的引用，尚未属性装配的Bean
三级缓存：存放实例化完成的Bean工厂。