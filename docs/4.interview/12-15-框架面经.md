<!--
 * @Author: 孙浩然
 * @Date: 2020-07-13 07:35:01
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-09-07 07:35:49
 * @FilePath: \docs\4.interview\12-15-框架面经.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/Java-Point/#/)，如对源码有异议请在我的博客中提问
--> 
<!-- TOC -->

- [1.Spring概述](#1spring概述)
  - [1-1：什么是spring?](#1-1什么是spring)
  - [1-2：Spring用到的设计模式](#1-2spring用到的设计模式)
  - [1-3：Request和Session的区别](#1-3request和session的区别)
  - [1-3：什么是 Spring 的循环依赖](#1-3什么是-spring-的循环依赖)
  - [1-4：什么是三级缓存](#1-4什么是三级缓存)
  - [1-5：什么是早期暴露的对象](#1-5什么是早期暴露的对象)
  - [1-6：如何解决循环依赖](#1-6如何解决循环依赖)
  - [Spring两大特性](#spring两大特性)
  - [Spring和Springboot的区别](#spring和springboot的区别)
- [2.Spring控制反转](#2spring控制反转)
  - [2-1：IOC原理](#2-1ioc原理)
  - [2-2：IOC容器种类](#2-2ioc容器种类)
  - [2-3：BeanFactory与ApplicationContext区别](#2-3beanfactory与applicationcontext区别)
  - [2-4：什么是依赖注入](#2-4什么是依赖注入)
  - [2-5：有哪些不同类型的IOC（依赖注入）方式？](#2-5有哪些不同类型的ioc依赖注入方式)
  - [2-5：IOC与DI的的区别:](#2-5ioc与di的的区别)
  - [2-6：](#2-6)
- [3.Spring面向切面编程(AOP)](#3spring面向切面编程aop)
  - [3-1：什么是aop](#3-1什么是aop)
  - [3-2：AOP的相关概念：](#3-2aop的相关概念)
- [3.Spring Bean](#3spring-bean)
  - [3-1：Bean的五种作用域](#3-1bean的五种作用域)
  - [3-2：Bean的生命周期](#3-2bean的生命周期)
  - [3-3：](#3-3)
- [4.Spring注解](#4spring注解)
- [5.Spring数据访问](#5spring数据访问)
- [6.](#6)
- [7.SpringMVC](#7springmvc)
  - [7-1：SpringMVC流程](#7-1springmvc流程)
- [8.事务](#8事务)
  - [8-1：spring事务种类](#8-1spring事务种类)
  - [8-2：Spring两种事务区别](#8-2spring两种事务区别)
  - [8-3：事务传播行为](#8-3事务传播行为)
  - [8-4：事务隔离级别](#8-4事务隔离级别)
  - [8-5：Spring的事务和数据库的事务隔离是一个概念么？](#8-5spring的事务和数据库的事务隔离是一个概念么)
  - [8-6：spring如何回滚和提交](#8-6spring如何回滚和提交)
- [9.MyBatis](#9mybatis)
  - [9-1：MyBatis是什么](#9-1mybatis是什么)
  - [9-2：ORM是什么](#9-2orm是什么)
  - [9-3：JPA](#9-3jpa)
  - [9-4：MyBatis优点](#9-4mybatis优点)
  - [9-5：为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？](#9-5为什么说mybatis是半自动orm映射工具它与全自动的区别在哪里)
  - [9-6：传统JDBC开发存在的问题，如何解决的](#9-6传统jdbc开发存在的问题如何解决的)
  - [9-7：Hibernate 和 MyBatis 的区别](#9-7hibernate-和-mybatis-的区别)
  - [9-8：MyBatis的解析和运行原理](#9-8mybatis的解析和运行原理)
  - [9-9：MyBatis编程步骤是什么样的？](#9-9mybatis编程步骤是什么样的)
  - [9-10：MyBatis的工作原理](#9-10mybatis的工作原理)
  - [2.5 为什么需要预编译](#25-为什么需要预编译)
  - [MyBatis是如何做到SQL预编译的呢？](#mybatis是如何做到sql预编译的呢)
  - [如何防止SQL注入](#如何防止sql注入)
  - [Mybatis都有哪些Executor执行器？它们之间的区别是什么？](#mybatis都有哪些executor执行器它们之间的区别是什么)
  - [2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？](#28-mybatis是否支持延迟加载如果支持它的实现原理是什么)
- [10.映射器](#10映射器)
  - [10-1：#{}和${}的区别是什么？](#10-1和的区别是什么)
  - [10-2：Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？](#10-2xml-映射文件中除了常见的-selectinsertupdaedelete-标签之外还有哪些标签)
  - [最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗](#最佳实践中通常一个xml映射文件都会写一个dao接口与之对应请问这个dao接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗)
  - [3.11 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？](#311-mybatis的xml映射文件中不同的xml映射文件id是否可以重复)
  - [简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？](#简述mybatis的xml映射文件和mybatis内部数据结构之间的映射关系)
  - [Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，3.16 还是说必须定义在A标签的前面？](#mybatis映射文件中如果a标签通过include引用了b标签的内容请问b标签能否定义在a标签的后面316-还是说必须定义在a标签的前面)
- [11.高级查询](#11高级查询)
  - [4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？](#41-mybatis实现一对一一对多有几种方式怎么操作的)
  - [4.2 Mybatis是否可以映射Enum枚举类？](#42-mybatis是否可以映射enum枚举类)
- [12.动态SQL](#12动态sql)
  - [12-1：Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？](#12-1mybatis动态sql是做什么的都有哪些动态sql能简述一下动态sql的执行原理不)
  - [12-2：Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？](#12-2mybatis-是如何将-sql-执行结果封装为目标对象并返回的都有哪些映射形式)
- [13.插件模块](#13插件模块)
  - [6.1 Mybatis是如何进行分页的？分页插件的原理是什么？](#61-mybatis是如何进行分页的分页插件的原理是什么)
  - [6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。](#62-简述mybatis的插件运行原理以及如何编写一个插件)
- [14.缓存](#14缓存)
  - [14-1：Mybatis的一级、二级缓存](#14-1mybatis的一级二级缓存)
- [15.servlet](#15servlet)
  - [15-1：Servlet生命周期?](#15-1servlet生命周期)
  - [forward和redirect的区别](#forward和redirect的区别)
  - [tomcat容器是如何创建servlet类实例？用到了什么原理](#tomcat容器是如何创建servlet类实例用到了什么原理)
  - [Servlet安全性问题](#servlet安全性问题)
  - [servlet写就行了，为什么要有springMVC这个东西呢](#servlet写就行了为什么要有springmvc这个东西呢)
  - [两者区别](#两者区别)
  - [servlet加载顺序](#servlet加载顺序)
  - [filter和Interceptor的区别](#filter和interceptor的区别)
  - [jsp和servlet区别](#jsp和servlet区别)
  - [Servlet是线程安全的吗？](#servlet是线程安全的吗)
- [15.SpringBoot](#15springboot)
  - [SpringBoot自动配置原理](#springboot自动配置原理)

<!-- /TOC -->
# 1.Spring概述

## 1-1：什么是spring?

书本

Spring的优缺点是什么？

1，降低了组件之间的耦合性，实现了软件各层之间的解耦。

2，可以使用容器提供的众多服务，如事务管理，消息服务等。

3，容器提供单例模式支持。

4，容器提供了AOP技术，利用它可以很容易实现一些拦截，如权限拦截，运行期监控等。

5，容器提供了众多的辅助类，能够加快应用的开发。

6，spring对于主流的应用框架提供了很好的支持，例如mybatis等。

7，spring属于低入侵式设计。

8，独立于各种应用服务器。

9，spring的DI机制降低了业务对象替换的复杂性。

10，spring的高度开放性，并不强制应用完全依赖于它，开发者可以自由选择spring的部分或者全部。

spring的缺点：

使用了大量的反射机制，反射机制非常占用内存。


4、Spring有哪些应用场景
5、Spring由哪些模块组成？
6、Spring 框架中都用到了哪些设计模式？
7、详细讲解一下核心容器（spring context应用上下文) 模块
8、Spring框架中有哪些不同类型的事件

9、Spring 应用程序有哪些不同组件？

10、使用 Spring 有哪些方式？





## 1-2：Spring用到的设计模式

## 1-3：Request和Session的区别

## 1-3：什么是 Spring 的循环依赖

就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，然后去创建 B 对象的时候，又发现 B 对象依赖 C，然后去创建 C 对象的时候，又发现 C 对象依赖 A。

## 1-4：什么是三级缓存

1. 第一级缓存：单例缓存池 singletonObjects。
2. 第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。
3. 第三级缓存：singletonFactories 单例对象工厂缓存

先从一级缓存singletonObjects中去获取，如果获取到 Bean 就直接返回。
如果获取不到或者对象正在创建中，那就再从二级缓存earlySingletonObjects中获取，如果获取到就直接返回。
如果前两级缓存都没成功返回，且允许 singletonFactories(allowEarlyReference=true)通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。如果获取到了就从singletonFactories中移除，并且放进earlySingletonObjects。其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。

## 1-5：什么是早期暴露的对象

你是一个不完整的对象，你的属性还没有值，你的对象也没有被初始化。这就是早期暴露的对象，只是提前拿出来给你认识认识。但他非常重要。这是多级缓存解决循环依赖问题的一个巧妙的地方。

## 1-6：如何解决循环依赖

主要是用三级缓存来解决循环依赖问题

比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决

1. 使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~
2. 实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）
3. 初始化A：@Autowired依赖注入B（此时需要去容器内获取B）
4. 为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~
5. 实例化B，并将其放入缓存。（此时B也能够被引用了）
6. 初始化B，@Autowired依赖注入A（此时需要去容器内获取A）
7. 此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回
8. B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。
9. 因为B实例已经成功返回了，因此最终A也初始化成功
10. 到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美

## Spring两大特性

IOC、AOP

自己细化

## Spring和Springboot的区别





# 2.Spring控制反转

## 2-1：IOC原理


## 2-2：IOC容器种类

## 2-3：BeanFactory与ApplicationContext区别

## 2-4：什么是依赖注入

Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。

## 2-5：有哪些不同类型的IOC（依赖注入）方式？

构造器依赖注入： 构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。

Setter方法注入： Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。

接口注入：定义接口

## 2-5：IOC与DI的的区别: 

IOC:  控制反转,将类的对象的创建交给Spring类管理创建. 
DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. 

## 2-6：


# 3.Spring面向切面编程(AOP)

## 3-1：什么是aop

能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并
有利于未来的可拓展性和可维护性。

## 3-2：AOP的相关概念：

(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知
(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器
(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)
(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式
(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程
(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段
(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类
(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO



















# 3.Spring Bean
## 3-1：Bean的五种作用域

书本p105

## 3-2：Bean的生命周期

（1）实例化（必须的）构造函数构造对象
（2）装配（可选的）为属性赋值
（3）回调（可选的）（容器-控制类和组件-回调类）
（4）初始化(init-method=" ")
（5）就绪
（6）销毁（destroy-method=" "） 

（1）实例化Bean：
对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入
另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当
容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。
（2）设置对象属性（依赖注入）：
实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通 过BeanWrapper提供的设置属性的接口完成依赖注入。
（3）处理Aware接口：
接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：
①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方
法，此处传递的就是Spring配置文件中Bean的id值；
②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的
是Spring工厂自身。
③如果这个Bean已经实现了ApplicationContextAware接口，会调用
setApplicationContext(ApplicationContext)方法，传入Spring上下文；
（4）BeanPostProcessor：
如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用
postProcessBeforeInitialization(Object obj, String s)方法。
（5）InitializingBean 与 init-method：
如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。
（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object
obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；
以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。
（7）DisposableBean： 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的
destroy()方法；
（8）destroy-method：
最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。



## 3-3：


# 4.Spring注解


# 5.Spring数据访问


# 6.


# 7.SpringMVC

## 7-1：SpringMVC流程


# 8.事务

## 8-1：spring事务种类

书本

## 8-2：Spring两种事务区别

书本

## 8-3：事务传播行为

书本


## 8-4：事务隔离级别

书本

## 8-5：Spring的事务和数据库的事务隔离是一个概念么？

Spring只提供统一事务管理接口，具体实现都是由各数据库自己实现（如MySQL）。Spring会在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保
持一致

如果Spring没有指定事务隔离级别，则会采用数据库默认的事务隔离级别；当Spring指定了事务隔离级别，则会在代码里将事务隔离级别修改为指定值；当数据库不支持这
种隔离级别，效果则以数据库的为准（比如采用了MyISAM引擎）。

## 8-6：spring如何回滚和提交




# 9.MyBatis

## 9-1：MyBatis是什么

就和传统的JDBC一样，就是个连接数据库进行增删改查的开源框架

## 9-2：ORM是什么

指将数据库中的每一行数据用对象的形式表现出来。

## 9-3：JPA

是Java持久化接口

## 9-4：MyBatis优点

1. 简单易学，容易上手（相比于Hibernate） ---- 基于SQL编程

2. 消除了JDBC大量冗余的代码，不需要手动开关连接

3. 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDB提供了可扩展性，所以只要这个数据库有针对Java的
   jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。

4. 提供了很多第三方插件（分页插件 / 逆向工程）

5. 能够与Spring很好的集成

## 9-5：为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联
对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

## 9-6：传统JDBC开发存在的问题，如何解决的

1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。


2. Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。


3. 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决： Mybatis自动将java对象映射至sql语句。


4. 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比
较方便。
解决：Mybatis自动将sql执行结果映射至java对象。

## 9-7：Hibernate 和 MyBatis 的区别

1） Mybatis 它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，
2） Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性
能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运
营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的
前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定
义多套 sql 映射文件，工作量大。
3） Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是
Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象
模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都
是好架构，所以框架只有适合才是最好。


## 9-8：MyBatis的解析和运行原理

MyBatis的运行过程分为两大步：

1. 读取配置文件缓存到Configuration对象，用以创建SqlSessionFactory；
   - 第一步：通过org.apache.ibatis.builder.xml.XMLConfigBuilder解析配置的XML文件，对出所配置的参数，并将读取的能容存入org.apache.ibatis.session.
     Configuration类对象中。而Configuration采用的是单例模式，几乎所有的MyBatis配置内容都会存放在这个单例对象中，以便后续将这些内容读出。
   - 第二步：使用Configuration对象去创建SqlSessionFactory。MyBatis中的SqlSessionFactory是个接口，而不是一个实现类，为此MyBatis提供了一个默认的实现类
     org.apache.ibatis.session.default.DefaultSqlSessionFactory。在大部分情况下都没有必要自己创建新的SqlSessionFactory实现类。

2. SqlSession的执行过程。
    主要使用JDK动态代理

## 9-9：MyBatis编程步骤是什么样的？

1、创建 SqlSessionFactory
2、通过 SqlSessionFactory 创建 SqlSession
3、通过 sqlsession 执行数据库操作
4、调用 session.commit()提交事务
5、调用 session.close()关闭会话

## 9-10：MyBatis的工作原理

1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着<select | update | delete | insert>标签项。

2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。

3、SqlSession对象完成和数据库的交互：
a、用户程序调用mybatis接口层api（即Mapper接口中的方法）
b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象
c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象
d、JDBC执行sql。

e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。

## 2.5 为什么需要预编译

预编译（#{}）会将SQL提前编译好，#{}位置为占位符，执行时候一个占位符就对应一个变量，不会影响到SQL结
构，所以不会存在SQL注入问题；
非预编译（${}）不会提前编译SQL，${}位置会直接将变量拼接进来，会影响到SQL的本身机构

## MyBatis是如何做到SQL预编译的呢？

在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。

## 如何防止SQL注入

攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵参数检验不足的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。

在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。

## Mybatis都有哪些Executor执行器？它们之间的区别是什么？

Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。

**SimpleExecutor：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

**``ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

**BatchExecutor：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

2.7 Mybatis中如何指定使用哪一种Executor执行器？

在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。

## 2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。

它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。

# 10.映射器

## 10-1：#{}和${}的区别是什么？

1. ${}是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。
2. #{}是 sql 的参数占位符，Mybatis 会将 sql 中的#{}替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，
   比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。

## 10-2：Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为 sql 片段标签，通过<include>标签引入 sql 片段，<selectKey>为不支持自增的主键生成策略标签。


3.2 模糊查询like语句该怎么写
3.3 在mapper中如何传递多个参数
3.4 Mybatis如何执行批量操作
3.5 如何获取生成的主键
3.6 当实体类中的属性名和表中的字段名不一样 ，怎么办
3.7 Mapper 编写有哪几种方式？
3.8 什么是MyBatis的接口绑定？有哪些实现方式？

3.9 使用MyBatis的mapper接口调用时有哪些要求？
## 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗

Dao 接口，就是人们常说的 Mapper接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中MappedStatement的 id 值，接口方法内的参数，就是传递给 sql 的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到 namespace 为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在 Mybatis 中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行MappedStatement所代表的 sql，然后将 sql 执行结果返回。


## 3.11 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？

不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。

原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。


## 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？

Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<parameterMap>标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。<resultMap>标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为 MappedStatement 对象，标签内的 sql 会被解析为 BoundSql 对象。


3.13 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？

## Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，3.16 还是说必须定义在A标签的前面？

虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。

原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。

# 11.高级查询

## 4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？

能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据列值来完成 100 条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

t_id t_name s_id

| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |


## 4.2 Mybatis是否可以映射Enum枚举类？

Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和 getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。


# 12.动态SQL

## 12-1：Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？

Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind。

其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

## 12-2：Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。

有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

# 13.插件模块

## 6.1 Mybatis是如何进行分页的？分页插件的原理是什么？

Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：select _ from student，拦截 sql 后重写为：select t._ from （select \* from student）t limit 0，10

## 6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。

Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

# 14.缓存

## 14-1：Mybatis的一级、二级缓存

一级缓存是mybatis默认就帮我们开启的，一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓
存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

# 15.servlet

## 15-1：Servlet生命周期?


加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例
初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象
处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求
销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁
卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。
简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。

## forward和redirect的区别

实际发生位置不同，地址栏不同

转发是发生在服务器的

转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。
重定向是发生在浏览器的

- **重定向是由浏览器进行跳转的**，进行重定向跳转的时候，**浏览器的地址会发生变化的**。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。**这是由浏览器进行的页面跳转**实现重定向**会发出两个http请求**，**request域对象是无效的，因为它不是同一个request对象**
用法不同:

很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上

request.getRequestDispatcher("/资源名 URI").forward(request,response)

转发时"/"代表的是本应用程序的根目录【zhongfucheng】
response.send("/web应用/资源名 URI");

重定向时"/"代表的是webapps目录
能够去往的URL的范围不一样:

转发是服务器跳转只能去往当前web应用的资源
重定向是服务器跳转，可以去往任何的资源
传递数据的类型不同

转发的request对象可以传递各种类型的数据，包括对象
重定向只能传递字符串
跳转的时间不同

转发时：执行到跳转语句时就会立刻跳转
重定向：整个页面执行完之后才执行跳转
那么转发(forward)和重定向(redirect)使用哪一个？

根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。
典型的应用场景：

转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变
重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了

## tomcat容器是如何创建servlet类实例？用到了什么原理

当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）
在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。

## Servlet安全性问题
由于Servlet是单例的，当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。

## servlet写就行了，为什么要有springMVC这个东西呢

比如说在数据库进行了添加删除更改功能，在web.xml中注册新sevlet，并映射对应的/insert /delete /update /XXX，在这些新的servlet中调用View和Model层完成功能。

这样新定义servlet的方法比较麻烦，要去继承HttpServlet接口，实现接口方法，手写调用jsp的重定向或者请求转发，还要再web.xml中注册。

Spring主要也是通过DispatcherServlet实现了Servlet这个接口，又叫前端控制器，来自前端的请求会先到达这里，它负责到后台去匹配合适的handler。DispatcherServlet的主要工作流程如下：

前端请求到达DispatcherServlet。

前端控制器请求HandlerMappering 查找Handler。

如果查找到存在的处理器，进一步去调用service和dao层

返回结果再到controller层，渲染具体的视图，返回结果给页面。

## 两者区别

Servlet：性能最好，处理Http请求的标准。

SpringMVC：开发效率高（好多共性的东西都封装好了，是对Servlet的封装，核心的DispatcherServlet最终继承自HttpServlet）

## servlet加载顺序

web.xml 的加载顺序是：context- param -> listener -> filter -> servlet

## filter和Interceptor的区别

1、filter接口在javax.servlet包下面。inteceptor定义在org.springframework.web.servlet中。
2、filter是servlet规定的，interceptor即可用于web程序，也可用于application中。
3、filter是servlet容器支持的，interceptor是spring框架支持的。
4、filter通过dochain放行，interceptor通过prehandler放行。
5、filter只在方法前后执行，interceptor粒度更细，可以深入到方法前后，异常抛出前后。

## jsp和servlet区别

通过 http 请求一个 JSP 页面是，首先 Tomcat 会调用 service（）方法将JSP编译成为 Servlet，然后执行 Servlet。

## Servlet是线程安全的吗？

Servlet不是线程安全的

比如说，当Tomcat接收到Client的HTTP请求时，Tomcat从线程池中取出一个线程，之后找到该请求对应的Servlet对象并进行初始化，之后调用service()方法。要注意的是每一个Servlet对象再Tomcat容器中只有一个实例对象，即是单例模式。如果多个HTTP请求请求的是同一个Servlet，那么着两个HTTP请求对应的线程将并发调用Servlet的service()方法。

Thread1和Thread2调用了同一个Servlet1，所以此时如果Servlet1中定义了实例变量或静态变量，那么可能会发生线程安全问题（因为所有的线程都可能使用这些变量）

# 15.SpringBoot

## SpringBoot自动配置原理