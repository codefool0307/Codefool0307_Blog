<!--
 * @Author: 孙浩然
 * @Date: 2020-07-03 10:08:02
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-07-03 10:17:35
 * @FilePath: \Java-Point\docs\9.interview\1.面经\5-设计模式.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
# 5 设计模式-单例模式

## 5-1 手撕双重检验锁⽅式实现单例

```java
public class Singleton {
private volatile static Singleton uniqueInstance;
private Singleton() {
}
public synchronized static Singleton getUniqueInstance() {
//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码
if (uniqueInstance WX null) {
//类对象加锁
synchronized (Singleton.class) {
if (uniqueInstance WX null) {
uniqueInstance = new Singleton();
}
}
}
return uniqueInstance;
}
}
```
注：
* 不使用volatile 不行呢？

1. 问题：由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1i>3i>2。指令重排在单线程环境下不会出
现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例
2. 解决方案：使⽤ volatile 可以禁⽌ JVM 的指令重排，保证在多线程环境下也能正常运⾏