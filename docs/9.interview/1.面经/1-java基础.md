<!--
 * @Author: 孙浩然
 * @Date: 2020-07-01 10:38:12
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-07-02 09:29:29
 * @FilePath: \Java-Point\docs\9.interview\1.面经\1-java基础.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
# Java十八讲

# 1.java基础-数据类型-8种常见类型
##  1-1：八种数据类型是什么？

1. 字符型   char
2. 布尔型  boolean
3. 数值型
   1. 整型：byte、short、int、long
   2. 浮点型：float、double

<font?color=red>特别注意</font>：String不是基本数据类型，是引用类型。
                                                          
##  1-2：为什么byte类型是-128~+127

因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是原因。

##  1-3：java为什么除了基本数据类型还要有引用数据类型

引用数据类型是在堆里，基本数据类型在栈储缓存
引用数据类型需要多一次解引用，而且还要存储对象头，这样对于基本数据类型

##  1-4：什么是单精度和双精度？
单精度浮点数在计算机存储器中占用4个字节（32?bits），
双精度浮点数(double)使用64位（8字节）来存储一个浮点数。

##  1-5：什么是浮点数？
由一个有效数字加上幂数来表示，使用浮点数的主要原因是由于计算机二进制的运算


# 2.java基础-数据类型-自动拆装箱
## 2-1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 2-2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候，如果属于小数据，那么就可以直接从本地内存进行调用，就不需要再次创建对象来进行姐姐

## 2-3：Integer的源码分析

1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
   * 如果说有，那么直接从内存进行读取
   * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置，但是只有Integer源码可以对高值、低值进行改变。

## 2-4：自动拆装箱的原理

    * 自动装箱：调用valueOf（）方法将原始类型值转换成对象
    * 自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。

## 2-5:自动拆装箱使用场景

1. 场景一、将基本数据类型放入集合类
2. 场景二、包装类型和基本类型的大小比较
3. 场景三、包装类型的运算
4. 场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
5. 场景五、函数参数与返回值

## 2-6：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，~~虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较~~。（笔试选择较为频繁，跟谁学考过）

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE（NullPointException）。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。

引申：==与equals的区别

1. ==在基本数据类型是值的比较，在引用数据类型是对象的比较（只要是创建了对象就不可以了）
2. equals主要是内容的比较
   * 其中equals源码主要代码思路：
      * 判定传入的对象和当前对象是否为同一个对象，如果是就直接返回true.
      * 判定传入的类型值是否为String,若不是则返回false;
      * 判定传入的String与当前的String的床都是否一致，若不一致就返回false;
      * 循环对比两个字符串的char[]数组，逐个对比字符是否一致，若存在不一致的情况，则直      接返回false;
      * 循环结束都没有找到不匹配的，所以最后返回true; 


