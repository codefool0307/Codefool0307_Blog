<!--
 * @Author: 孙浩然
 * @Date: 2020-07-01 10:38:12
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-07-02 14:30:45
 * @FilePath: \Java-Point\docs\9.interview\1.面经\1-java基础.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
# Java十八讲

# 1.java基础-数据类型-8种常见类型
##  1-1：八种数据类型是什么？

1. 字符型   char
2. 布尔型  boolean
3. 数值型
   1. 整型：byte、short、int、long
   2. 浮点型：float、double

<font?color=red>特别注意</font>：String不是基本数据类型，是引用类型。
                                                          
##  1-2：为什么byte类型是-128~+127

因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是原因。

##  1-3：java为什么除了基本数据类型还要有引用数据类型

引用数据类型是在堆里，基本数据类型在栈储缓存
引用数据类型需要多一次解引用，而且还要存储对象头，这样对于基本数据类型

##  1-4：什么是单精度和双精度？
单精度浮点数在计算机存储器中占用4个字节（32?bits），
双精度浮点数(double)使用64位（8字节）来存储一个浮点数。

##  1-5：什么是浮点数？
由一个有效数字加上幂数来表示，使用浮点数的主要原因是由于计算机二进制的运算


# 2.java基础-数据类型-自动拆装箱
## 2-1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 2-2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候，如果属于小数据，那么就可以直接从本地内存进行调用，就不需要再次创建对象来进行姐姐

## 2-3：Integer的源码分析

1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
   * 如果说有，那么直接从内存进行读取
   * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置，但是只有Integer源码可以对高值、低值进行改变。

## 2-4：自动拆装箱的原理

    * 自动装箱：调用valueOf（）方法将原始类型值转换成对象
    * 自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。

## 2-5:自动拆装箱使用场景

1. 场景一、将基本数据类型放入集合类
2. 场景二、包装类型和基本类型的大小比较
3. 场景三、包装类型的运算
4. 场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
5. 场景五、函数参数与返回值

## 2-6：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，~~虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较~~。（笔试选择较为频繁，跟谁学考过）

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE（NullPointException）。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。

引申：==与equals的区别

1. ==在基本数据类型是值的比较，在引用数据类型是对象的比较（只要是创建了对象就不可以了）
2. equals主要是内容的比较
   * 其中equals源码主要代码思路：
      * 判定传入的对象和当前对象是否为同一个对象，如果是就直接返回true.
      * 判定传入的类型值是否为String,若不是则返回false;
      * 判定传入的String与当前的String的床都是否一致，若不一致就返回false;
      * 循环对比两个字符串的char[]数组，逐个对比字符是否一致，若存在不一致的情况，则直      接返回false;
      * 循环结束都没有找到不匹配的，所以最后返回true; 

# 3.java基础-关键字-访问权限关键字
## 3-1：访问控制关键字级别

![avatar](./../../1.basics/1.java-basic/assets/3-2.jpg)

## 3-2: 通过反射访问private成员和方法，既然能访问为什么要private？

1. private并不是解决安全问题的，如果想让解决代码的安全问题，请用别的办法。
2. private的意义是OOP（面向对象编程）的封装概念。

# 4.java基础-关键字-static

## 4-1:static使用场景

1. 修饰成员变量和成员方法 
     * 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
2. 静态代码块: 
   * 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. 静态内部类（static修饰类的话只能修饰内部类）： 
   * 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. 静态导包: 
   * 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

# 5.java基础-关键字-final关键字

## 5-1 final关键字使用特点

1. final修饰的类不能被继承

2. final修饰的方法不能被重写；

3. final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

## 5-2 final使用原因

1. 第一个原因是把方法锁定，以防任何继承类修改它的含义；
2. 第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。



final关键字
traisent
静态
synchronized 关键字
volatile关键字
