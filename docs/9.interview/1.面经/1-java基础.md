<!--
 * @Author: 孙浩然
 * @Date: 2020-07-01 10:38:12
 * @LastEditors: 孙浩然
 * @LastEditTime: 2020-07-06 10:06:04
 * @FilePath: \Java-Point\docs\9.interview\1.面经\1-java基础.md
 * @博客地址: 个人博客，如果各位客官觉得不错，请点个赞，谢谢。[地址](https://codefool0307.github.io/JavaScholar/#/)
--> 
# Java十八讲

# 1.java基础-数据类型-8种常见类型
##  1-1：八种数据类型是什么？

1. 字符型   char
2. 布尔型  boolean
3. 数值型
   1. 整型：byte、short、int、long
   2. 浮点型：float、double

<font?color=red>特别注意</font>：String不是基本数据类型，是引用类型。
                                                          
##  1-2：为什么byte类型是-128~+127

因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是原因。

##  1-3：java为什么除了基本数据类型还要有引用数据类型

引用数据类型是在堆里，基本数据类型在栈储缓存
引用数据类型需要多一次解引用，而且还要存储对象头，这样对于基本数据类型

##  1-4：什么是单精度和双精度？
单精度浮点数在计算机存储器中占用4个字节（32?bits），
双精度浮点数(double)使用64位（8字节）来存储一个浮点数。

##  1-5：什么是浮点数？
由一个有效数字加上幂数来表示，使用浮点数的主要原因是由于计算机二进制的运算


# 2.java基础-数据类型-自动拆装箱
## 2-1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 2-2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候，如果属于小数据，那么就可以直接从本地内存进行调用，就不需要再次创建对象来进行姐姐

## 2-3：Integer的源码分析

1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
   * 如果说有，那么直接从内存进行读取
   * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置，但是只有Integer源码可以对高值、低值进行改变。

## 2-4：自动拆装箱的原理

    * 自动装箱：调用valueOf（）方法将原始类型值转换成对象
    * 自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。

## 2-5:自动拆装箱使用场景

1. 场景一、将基本数据类型放入集合类
2. 场景二、包装类型和基本类型的大小比较
3. 场景三、包装类型的运算
4. 场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
5. 场景五、函数参数与返回值

## 2-6：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，~~虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较~~。（笔试选择较为频繁，跟谁学考过）

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE（NullPointException）。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。

引申：==与equals的区别

1. ==在基本数据类型是值的比较，在引用数据类型是对象的比较（只要是创建了对象就不可以了）
2. equals主要是内容的比较
   * 其中equals源码主要代码思路：
      * 判定传入的对象和当前对象是否为同一个对象，如果是就直接返回true.
      * 判定传入的类型值是否为String,若不是则返回false;
      * 判定传入的String与当前的String的床都是否一致，若不一致就返回false;
      * 循环对比两个字符串的char[]数组，逐个对比字符是否一致，若存在不一致的情况，则直      接返回false;
      * 循环结束都没有找到不匹配的，所以最后返回true; 

# 3.java基础-关键字-访问权限关键字
## 3-1：访问控制关键字级别

![avatar](./../../1.basics/1.java-basic/assets/3-2.jpg)

## 3-2: 通过反射访问private成员和方法，既然能访问为什么要private？

1. private并不是解决安全问题的，如果想让解决代码的安全问题，请用别的办法。
2. private的意义是OOP（面向对象编程）的封装概念。

# 4.java基础-关键字-static

## 4-1:static使用场景

1. 修饰成员变量和成员方法 
     * 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。
     * 被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
2. 静态代码块: 
   * 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. 静态内部类（static修饰类的话只能修饰内部类）： 
   * 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. 静态导包: 
   * 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

# 5.java基础-关键字-final关键字

## 5-1 final关键字使用特点

1. final修饰的类不能被继承

2. final修饰的方法不能被重写；

3. final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。

## 5-2 final使用场景

1. 把方法锁定，以防任何继承类修改它的含义；

2. 想通过使用final提升程序性能
   * 因为编译器能从final中获取额外的信息，因此可以对类或者方法调用进行额外的优化处理。但这中优化对程序性能的提升极其有限。

3. 权限控制,也就是说这个类或方法不希望被继承和重写

# 6.java基础-关键字-this关键字和super关键字

1. this程序
```java
class Manager {
    Employees[] employees;
     
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
     
    void report() { }
}
```

主要是访问本类（自己）的成员变量和方法（可写可不写）
super主要是通过子类去访问父类的成员变量和方法，必须写
2. super程序

```java
public class Super {
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

1. 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。
2. this 调用本类中的其他构造方法时，也要放在首行。
3. this、super不能用在static方法中。

# 7.java基础-关键字-transient

## 7-1： transient使用场景

阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 transient 只能修饰变量，不能修饰类和⽅法。

# 8.java基础-关键字-synchronized关键字

## 8-1：synchronized关键字理解

1. 解决的是多个线程之间访问资源的同步性， synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。
2. 在 Java 早期版本中， synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的， Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼，但是在JDK1.6对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

## 8-2：JDK1.6优化有哪些？

JDK1.6 对锁的实现引⼊了⼤量的优化，如偏向锁、轻量级锁、⾃旋锁、适应性⾃旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

~~锁主要存在四种状态，依次是：⽆锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈⽽逐渐升级。锁可以升级单绝对不可以降级，这种策略是为了提⾼获得锁和释放锁的效率。~~

①偏向锁

引入偏向锁的目是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。

② 轻量级锁

轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。

如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！

③ 自旋锁和自适应自旋

一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋）也就是自旋。

自旋次数的默认值是10次，用户可以修改--XX:PreBlockSpin来更改。

另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。

④ 锁消除

指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。

⑤ 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。
   
# 8-3：说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗

💀💀💀

## 8-4：synchronized关键字最主要的三种使⽤⽅式（与单例模式结合比较高）

1. 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁
2. 修饰代码块: 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。
3. 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例。

补充：
* synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class类上锁。 
* synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

## 8-5：synchronized 关键字底层原理

① synchronized 同步语句块的情况
synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中 monitorenter
指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 

② synchronized 修饰⽅法的的情况
synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是
ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法， JVM 通过该 ACC_SYNCHRONIZED 访问
标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。

## 8-6：synchronized和ReentrantLock的区别
1. 两者都是可重⼊锁

* “可重⼊锁”概念是：⾃⼰可以再次获取⾃⼰的内部锁。⽐如⼀个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器
下降为0时才能释放锁。

2. synchronized 依赖于 JVM ⽽ ReentrantLock 依赖于 API

3. ReentrantLock ⽐ synchronized 增加了⼀些⾼级功能
 1. 等待可中断； 
 2. 可实现公平锁； 
 3. 可实现选择性通知（锁可以绑定多个条件）

# 9.java基础-关键字-volatile关键字

## 9-1：volatile 关键字作用以及Java内存数据不一致

作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。


## 9-2：说说 synchronized 关键字和 volatile 关键字的区别

1. volatile关键字是线程同步的轻量级实现，但是volatile关键字只能⽤于变量⽽synchronized关键字可以修饰⽅法以及代码块。
2. synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升。
3. 多线程访问volatile关键字不会发⽣阻塞，⽽synchronized关键字可能会发⽣阻塞
4. volatile关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized关键字两者都能保证。
5. volatile关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized关键字解决的是多个线程之间访问资源的同步性。

## 9-3：get需要加锁么，为什么？ （蚂蚁金服）

get操作全程不需要加锁是因为Node的成员变量是用volatile修饰的，数组用volatile修饰主要是保证在数组扩容的时候保证可见性。

# 10.java基础-集合-hashmap

## 10-1：HashMap的底层实现
1. JDK1.8之前HashMap底层是数组和链表。HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过(n-1)&hash判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
   
2. JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。


## 10-2：扰动函数以及作用

HashMap的hash方法。

使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法，换句话说使用扰动函数之后可以减少碰撞。


## 10-3：拉链法

将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

## 10-4：HashMap的put操作

HashMap通过key的hashCode经过扰动函数处理过后得到hash值，然后通过(n-1)&hash判断当前元素存放的位置

1. 如果数组的这个位置是空的，把key放进去，put操作就完成了。

2. 如果数组位置不为空，就判断该元素与要存入的元素的?hash?值以及?key?是否相同，如果相同的话，直接覆盖

3. 若果不相等，这个元素必然是个链表。遍历链表逐一比对value，如果value在链表中不存在，就把新建节点，将value放进去，put操作完成。

4. 如果链表中value存在，则替换原节点的value，put操作完成。

5. 如果链表节点数已经达到8个，首先判断当前hashMap的长度，如果不足64，只进行resize，扩容table，如果达到64就将冲突的链表为红黑树。

## 10-5：hash函数以及常用方法

1. 直接定址法：直接以key或者key上加上某个常数作为哈希地址
2. 数字分析法：提取key中取值比较均匀的数字作为哈希地址
3. 除留余数法：用key除以某个不大于哈希表长度m的数，将所得余数作为哈希地址
4. 分段叠加法：按照哈希表地址位数将关键字分成了位数相等的几部分，其中最后一部分可以比较短，然后将这几部分相加，舍弃最高位仅为后的结果就是该关键字的哈希地址
5. 平方取中法：如果key的各部分分部都不均匀，可以先求出他的平方值，然后按照需求求取中间的几位作为哈希地址
6. 伪随机数法：采用一个伪随机数作为哈希函数

## 10-6：hashmap树化门槛及作用

* 链表长度大于8
* 数组长度大于64

作用：
这个本质上，是一个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶中，则会形成一个链表。而链表查询是线性的，会严重影响存取的性能。

## 10-7：hashmap性能提升作用和好处

主要是为了避免哈希碰撞拒绝服务攻击。

* 如：String的hashcode函数的强度很弱，有人可以很容易的构造出大量hashcode相同的String对象。如果向服务器一次提交数万个hashcode相同的字符串，服务器的查询时间过长，让服务器的CPU被大量占用，当有其他更多的请求时服务器会拒绝服务。而使用红黑树可以将查询时间降低到一定的数量级，可以有效避免哈希碰撞拒绝服务攻击。


## 10-8：hashmap的特性

1. 允许空键和空值（但空键只有一个，且放在第一位）
2. 元素是无序的，而且顺序会不定时改变
3. key?用?Set?存放，所以想做到?key?不允许重复，key?对应的类需要重写?hashCode?和?equals?方法。
4. 底层实现是?链表数组，JDK?8?后又加了红黑树。
5. 实现了?Map?全部的方法

## 10-9：java8为什么要对hashmap进行改造，用红黑树替代

提高效率

## 10-10：HashMap的扩容机制

书本

## 10-11：请解释一下HashMap的参数loadFactor，它的作用是什么？

loadFactor表示HashMap的拥挤程度

作用：影响hash操作到同一个数组位置的概率。默认loadFactor等于0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，在HashMap的构造器中可以定制loadFactor。

## 10-12：HashMap的树化门槛为什么是8

1. 当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值（树华门槛）。
   
2. 在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。
   
3. 不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率是一个非常小的值，几乎是不可能事件。

## 10-13：HashMap的扩容因子为什么是0.75

1. 如果设置过大，如0.85，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，性能下降。
   
2. 如果设置过小，如0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。

## 10-14:为什么默认初始化桶数组大小为16

如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小，既不会像1，2，3那样放几个元素就扩容，也不会像几千几万那样可以只会利用一点点空间从而造成大量的浪费。

## 10-15:hashMap是否线程安全

1. put的时候导致的多线程数据不一致

2. resize而引起死循环（JDK1.8已经不会出现该问题）

## 10-16：线程安全的Map

* Hashtable
* ConcurrentHashMap
* SynchronizedMap

1. Hashtable源码中是使用synchronized来保证线程安全的
   
2. ConcurrentHashMap沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想，但是ConcurrentHashMap没有对整个hash表进行锁定，而是采用了分离锁（segment）的方式进行局部锁定。具体体现在，它在代码中维护着一个segment数组。
   
3. 在SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的。

## 10-17：ConcurrentHashMap的底层实现，怎么做到线程安全的

在JDK1.7的时候，ConcurrentHashMap（分段锁）?对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。?到了?JDK1.8?的时候已经摒弃了Segment的概念，而是直接用?Node?数组+链表+红黑树的数据结构来实现，并发控制使用?synchronized?和?CAS?来操作。（JDK1.6以后?对?synchronized锁做了很多优化）?整个看起来就像是优化过且线程安全的?HashMap，虽然在JDK1.8中还能看到?Segment?的数据结构，但是已经简化了属性，只是为了兼容旧版本；

## 10-18：为何会出现ConcurrenHashMap?

线程安全，读写还快，以空间换时间
内存直接分为了16个segment，每个segment实际上还是存储的哈希表，写入的时候，先找到对应的segment，然后锁这个segment，写完，解锁，汗！就这么简单解决了，锁segment的时候，其他segment还可以继续工作

## 10-19：hashmap为什么是2的秘方次

如果length为2的N次方，取模运算可以变成位与运算，效率显著提高！但是要浪费一些空间。

## 10-20：hashmap的多线程导致死循环

并发下的Rehash会造成元素之间会形成一个循环链表。在JDK8之后，使用了链表转化为红黑树的形式，可以解决这个问题，但是呢还会有数据丢失等弊端

## 10-21：java8中map相关红黑树引用背景

书本

## 10-22：hashcode与equals

1. 如果两个对象相等，则hashcode一定也是相同的
2. 两个对象相等,对两个equals方法返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
   
综上，equals方法被覆盖过，则hashCode方法也必须被覆盖

hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

# 11.java基础-集合-Collection

## 11-1：ArrayList数组长度源码

一部分是用来存储数据元素，一部分是用来存储数组大小，标志，锁定，类信息指针等对象头信息，对象头信息最大占用内存不可超过8字节。

## 11-2：arraylist扩容机制

如果元素的个数，大于其容量，则把其容量扩展为原来容量的1.5倍。

## 11-3：遍历删除arraylist元素

1. 直接使用普通for循环进行操作
2. 直接使用Iterator进行操作
3. 使用Java8中提供的filter过滤
4. 使用增强for循环其实也可以
5. 直接使用fail-safe的集合类

## 11-4：set的重复元素

1. HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。

2. TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。
   
3. TreeSet是用compareTo()来判断重复元素的。

## 11-5：Enumeration和itrator区别
1. 函数接口不同
   * Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
   * Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
1. Iterator支持fail-fast机制，而Enumeration不支持。
2. Enumeration迭代器只能遍历Vector、Hashtable这种古老的集合，因此通常不要使用它，除非在某些极端情况下，不得不使用Enumeration，否则都应该选择Iterator迭代器。

## 11-6：comparable和Comparator的区别

书本

## 11-7：SynchronizedList

1. SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。
   
2. 使用SynchronizedList的时候，进行遍历时要手动进行同步处理。

3. SynchronizedList可以指定锁定的对象。





# 12.java基础-集合-Collections

## 12-1：Collection和collections区别

1. Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法
2. Collections是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

# 13.java基础-集合-Arrays


# 14.java基础-集合-集合大比较（区别和使用场景）

## 14-1：set和list、map的区别

1. List(对付顺序的好帮手)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象

2. Set(注重独一无二的性质):不允许重复的集合。不会有多个元素引用相同的对象。

3. Map(用Key来搜索的专家):使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

## 14-2：区别和适用场景




