面经总结

总结牛客网、个人实习秋招、还有几位大佬的知识点

<!-- TOC -->autoauto- [1.java基础-数据类型-8种常见类型](#1java基础-数据类型-8种常见类型)auto    - [问题1：八种数据类型是什么？](#问题1八种数据类型是什么)auto    - [问题2：为什么byte类型是-128~+127](#问题2为什么byte类型是-128127)auto    - [问题3：java为什么除了基本数据类型还要有引用数据类型](#问题3java为什么除了基本数据类型还要有引用数据类型)auto    - [问题4：什么是单精度和双精度？](#问题4什么是单精度和双精度)auto- [2.java基础-数据类型-自动拆装箱](#2java基础-数据类型-自动拆装箱)auto    - [问题1：为什么要有自动拆装箱](#问题1为什么要有自动拆装箱)auto    - [问题2：Integer缓存机制](#问题2integer缓存机制)auto    - [问题3：自动拆装箱相对应的程序问题：](#问题3自动拆装箱相对应的程序问题)auto    - [问题4：Integer的源码分析](#问题4integer的源码分析)auto    - [问题5：自动拆装箱的原理与使用场景](#问题5自动拆装箱的原理与使用场景)auto    - [问题6：自动拆装箱带来的问题](#问题6自动拆装箱带来的问题)autoauto<!-- /TOC -->

# 1.java基础-数据类型-8种常见类型
## 问题1：八种数据类型是什么？

字符型
char

布尔型
boolean

数值型
1.整型：byte、short、int、long

2.浮点型：float、double

<font color=red>特别注意</font>：String不是基本数据类型，是引用类型。

## 问题2：为什么byte类型是-128~+127



## 问题3：java为什么除了基本数据类型还要有引用数据类型

引用数据类型是在堆里，基本数据类型在栈里
栈所占空间小而且连续，常用来存储缓存
引用数据类型需要多一次解引用，而且还要存储对象头，这样对于基本数据类型


## 问题4：什么是单精度和双精度？
单精度浮点数在计算机存储器中占用4个字节（32 bits），
双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数。

# 2.java基础-数据类型-自动拆装箱
## 问题1：为什么要有自动拆装箱

比如说集合类中，要求元素必须是Object类，而int、double等基本数据类型无法使用，那么我们就把基本数据类型包装起来，使其具有对象的特征，并让他有了属性和方法

## 问题2：Integer缓存机制

Integer对小数据（-128~=127）具有缓存机制，当jvm在初始化的时候，如果数据是小数据，那么就会把数据存储在本地内存当中，当下次使用的时候，如果属于小数据，那么就可以直接从本地内存进行调用，就不需要再次创建对象来进行姐姐

## 问题3：自动拆装箱相对应的程序问题：
1.创建对象，那么必定不相等，

## 问题4：Integer的源码分析
1. 其中会有一个valueof函数，用来判断内存中是否有着这个数值，
    * 如果说有，那么直接从内存进行读取
    * 如果说没有，那么就需要创建一个对象
2. 在jvm初始化的时候，低值是不能改变的，但是高值是可以改变的，可以通过jvm进行参数设置
3. 不仅在Integer源码这样分析，其他的也这样分析
   
    有ByteCache用于缓存Byte对象
    有ShortCache用于缓存Short对象
    有LongCache用于缓存Long对象
    有CharacterCache用于缓存Character对象

但是除了Integer以外，这个范围高值、低值都是不能改变。

## 问题5：自动拆装箱的原理与使用场景
 1. 原理：自动装箱都是通过包装类的valueOf()方法来实现的.自动拆箱都是通过包装类对象的xxxValue()来实现的。
 2. 使用场景：
    场景一、将基本数据类型放入集合类
    场景二、包装类型和基本类型的大小比较
    场景三、包装类型的运算
    场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错
    场景五、函数参数与返回值

## 问题6：自动拆装箱带来的问题

1. 包装对象的数值比较，不能简单的使用==，虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较。

2. 如果包装类对象为null，那么自动拆箱时就有可能抛出NPE。

3. 如果一个for循环中有大量拆装箱操作，会浪费很多资源。
 
引申：==与equals的区别[]

# 3.java基础-语法

# 4.java基础-关键字-static
## 问题1：static的使用场景

1. 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
   
2. 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 Class.forName("ClassDemo")创建 Class 对象的时候也会执行。
   
3. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
   
4. 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

# 5.java基础-关键字-final
## 问题1：final使用场景

1. 对于一个final变量，
   * 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；
   * 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。类中所有的private方法都隐式地指定为final。

# 6.java基础-关键字-this和super
## 问题1：this、super不能用在static方法中。

被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。




