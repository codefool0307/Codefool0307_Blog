# 1 åŸºæœ¬æ•°æ®ç±»å‹

## 1.0 åŸºæœ¬æ•°æ®ç±»å‹ç»¼è¿°

ç›®å‰åŸºæœ¬æ•°æ®ç±»å‹åœ¨jdkå‘å¸ƒçš„æºç å½“ä¸­å…±åˆ†ä¸ºäº†ä¸‰éƒ¨åˆ†ï¼š

1. å¸ƒå°”ç±»å‹
2. å­—ç¬¦ç±»å‹
3. æ•°å€¼ç±»å‹

æ³¨ï¼šæ­£å¥½ä¸[é¢ç»](/docs/9.interview/1.é¢ç»/1-javaåŸºç¡€.md/#1javaåŸºç¡€-æ•°æ®ç±»å‹-8ç§å¸¸è§ç±»å‹)å¥‘åˆ

æ³¨ï¼šjdkæºç åœ¨src\java.base\java\langä¸­


## 1.1 å¸ƒå°”ç±»å‹æºç è§£æ 

Booleanå…³æ³¨ç‚¹ï¼š

1. booleanç±»å‹å¯ä»¥åˆ›å»ºå¯¹è±¡ï¼Œä½†æ˜¯å‚æ•°åªæœ‰åŒ…å«ä¸€ä¸ªå­—æ®µï¼Œå¦‚new Booleanï¼ˆtrueï¼‰ï¼Œä¸å¯ä»¥new Booleanï¼ˆtrueï¼Œfalseï¼‰ğŸ‘‰

2. Booleanä¸Stringçš„ç›¸äº’è½¬æ¢ ğŸ‘‰

  
![avatar](https://github.com/codefool0307/Java-Point/blob/master/docs/1.basics/1.java-basic/assets/1-1.jpg?raw=true)

### 1.1.1 å‡½æ•°å¤´

```java
package java.lang;

import jdk.internal.HotSpotIntrinsicCandidate;//ä¼šæ›¿ä»£JDKæºç å®ç°ï¼Œè·å–æ›´é«˜çš„æ•ˆç‡

public final class Boolean implements java.io.Serializable,//å®ç°å¯¹è±¡çš„åºåˆ—åŒ–ï¼Œ
                                                          // ä¸ºäº†è§£å†³ åœ¨å¯¹ å¯¹è±¡æµ è¿›è¡Œè¯»å†™æ“ä½œæ—¶æ‰€å¼•å‘çš„é—®é¢˜ï¼ˆåºåˆ—åŒ–è¯¦ç»†ä»‹ç»ï¼‰
                                      Comparable<Boolean>//ä¸¤æ•°ä¹‹é—´çš„æ¯”è¾ƒé—®é¢˜
{
```

### 1.1.2 æˆå‘˜å˜é‡ 

#### 1.1.2.1 æˆå‘˜å˜é‡ç¬¬ä¸€éƒ¨åˆ†

```java
    /* booleançš„æˆå‘˜å˜é‡ï¼ˆç¬¬ä¸€éƒ¨åˆ†ï¼‰*/
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);
```
![avatar](https://github.com/codefool0307/Java-Point/blob/master/docs/1.basics/1.java-basic/assets/1-2.jpg?raw=true)

#### 1.1.2.2 æˆå‘˜å˜é‡ç¬¬äºŒéƒ¨åˆ†

```java
    //booleançš„æˆå‘˜å˜é‡ï¼ˆç¬¬äºŒéƒ¨åˆ†ï¼‰------>è¡¨ç¤ºåŸºæœ¬ç±»å‹booleançš„classå¯¹è±¡
    //å‘Šè¯‰ç¼–è¯‘å™¨å¿½ç•¥uncheckçš„è­¦å‘Šä¿¡æ¯ï¼Œ
    //å¦‚ä½¿ç”¨Listï¼ŒArrayListç­‰æœªè¿›è¡Œå‚æ•°åŒ–äº§ç”Ÿçš„è­¦å‘Šä¿¡æ¯
    @SuppressWarnings("unchecked") 
    public static final Class<Boolean> TYPE = (Class<Boolean>) Class.getPrimitiveClass("boolean");

```
ä¸ºä»€ä¹ˆä¼šæ˜¯ä¸€ä¸ªTYPEå‘¢?

 1. intçš„åŒ…è£…ç±»æ˜¯Integerï¼Œä½†æ˜¯Integer.class ==?== int.class æ˜¯ç»å¯¹ä¸ç›¸ç­‰çš„ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯ä¸¤ä»½å­—èŠ‚ç æ–‡ä»¶
   
 2. ä½†æ˜¯æˆ‘è‡ªå·±åˆ›å»ºäº†ä¸€ä¸ªgetPrimitiveClassæ–¹æ³•ï¼Œé€šè¿‡è¿™ä¸ªæ–¹æ³•æ¥ç¡®å®šä½¿ç”¨ä»€ä¹ˆclassæ–‡ä»¶

æ³¨æ„ï¼š
    
1. è¿™ä¸ªæ–¹æ³•ä¸å±äºClass
    
2. ç¨‹åº

```java
   Integer.TYPE==int.class;//YES
   Integer.TYPE == Integer.class;//ERROR
```

3. åœ¨javaä¸­æœ‰ä¸¤ç§å¯¹è±¡ï¼š

    * å®ä¾‹å¯¹è±¡ï¼Œå¦‚ Boolean aBoolean = new Boolean(true);
    * Classå¯¹è±¡ æ¯ä¸€ä¸ªç±»åªè¦è¿è¡Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªclasså¯¹è±¡ï¼Œå®ƒåŒ…å«äº†ä¸ç±»æœ‰å…³çš„ä¿¡æ¯ï¼Œå®ä¾‹å¯¹è±¡å°±æ˜¯é€šè¿‡classå¯¹è±¡äº§ç”Ÿçš„

4. [getPrimitiveClassæ–¹æ³•](http://www.java2s.com/Code/Java/Reflection/isPrimitivetypegetPrimitiveClassgetTypeDefaultValue.htm)
   
```java
public static final Class<?> getPrimitiveClass(String typeName) {
   if (typeName.equals("byte"))
       return byte.class;
   if (typeName.equals("short"))
       return short.class;
   if (typeName.equals("int"))
       return int.class;
   if (typeName.equals("long"))
       return long.class;
   if (typeName.equals("char"))
       return char.class;
   if (typeName.equals("float"))
       return float.class;
   if (typeName.equals("double"))
       return double.class;
   if (typeName.equals("boolean"))
       return boolean.class;
   if (typeName.equals("void"))
       return void.class;
   throw new IllegalArgumentException("Not primitive type : " + typeName);
}
```
  
#### 1.1.2.3 æˆå‘˜å˜é‡ç¬¬ä¸‰éƒ¨åˆ†

```java
    private final boolean value;

    private static final long serialVersionUID = -3665804199014368530L;
```

### 1.1.3 æ„é€ å‡½æ•°

```java
   
    @Deprecated(since="9")//Deprecatedçš„å±æ€§ï¼Œè¡¨ç¤ºå·²è¢«å¼ƒç”¨çš„ç‰ˆæœ¬
    public Boolean(boolean value) {
        this.value = value;
    }
    
    @Deprecated(since="9")
    public Boolean(String s) {
        this(parseBoolean(s));//this(trueæˆ–è€…å…¶ä»–)è°ƒç”¨çš„å°±æ˜¯æ„é€ å‚æ•°
    }
```
æ„é€ å‡½æ•°ä¸å¸¸ç”¨äº†ï¼Œå› ä¸ºæˆ‘æœ‰äº†é™æ€å·¥å‚ï¼Œç”¨å®ƒå¹²å˜›ç”¨ï¼Ÿ

### 1.1.4 æ–¹æ³•

#### 1.1.4.1 æ–¹æ³•â€”â€”â€”â€”å°†å­—ç¬¦ä¸²å‚æ•°è§£æä¸ºå¸ƒå°”å€¼
```java
    /*
     * ä½œç”¨ï¼šå°†å­—ç¬¦ä¸²å‚æ•°è§£æä¸ºå¸ƒå°”å€¼
     * å¦‚ä½•å®ç°ï¼šå¦‚æœå­—ç¬¦ä¸²å‚æ•°ä¸æ˜¯nullï¼Œå¹¶ä¸”å¿½ç•¥å¤§å°å†™ï¼Œç­‰äºå­—ç¬¦ä¸²true

     * Example: {@code Boolean.parseBoolean("True")} returns {@code true}.<br>
     * Example: {@code Boolean.parseBoolean("yes")} returns {@code false}.
     */
    public static boolean parseBoolean(String s) {
        return ((s != null) && s.equalsIgnoreCase("true"));
    }
```

#### 1.1.4.2 æ–¹æ³•â€”â€”â€”â€”è¿”å›booleanå¯¹è±¡çš„å€¼

```java
    /*
     ä½œç”¨ï¼šè¿”å›booleanå¯¹è±¡çš„å€¼
     å¦‚ä½•å®ç°ï¼šç›´æ¥è¿”å›å®šä¹‰å¥½çš„å€¼å°±å¥½äº†-------------|
     */                                           |
    @HotSpotIntrinsicCandidate//è·å–æ›´é«˜çš„æ•ˆç‡     | 
    public boolean booleanValue() {               |
        return value;-----------------------------|
    }
```
ä½†æ˜¯è¿™æ ·ç¡®å®èƒ½è¿”å›æ‰¾åˆ°çš„å€¼ï¼Œä½†æ˜¯ä¸‹é¢è¿™ä¸ªæ–¹æ³•

ä¼šä¼˜äºæ„é€ å™¨å®ç°ï¼ŒåŒæ—¶æ—¶ç©ºæ€§æ¯”è¾ƒå¥½

```java
    @HotSpotIntrinsicCandidate
    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }

    public static Boolean valueOf(String s) {//ä¼šé¦–å…ˆå°†Stringè½¬æ¢ä¸ºBoolean
        return parseBoolean(s) ? TRUE : FALSE;
    }

    //è¿”å›çš„æ˜¯Stringç±»å‹
    public static String toString(boolean b) {
        return b ? "true" : "false";
    }
   
    public String toString() {
        return value ? "true" : "false";
    }
```

#### 1.1.4.3 æ–¹æ³•â€”â€”â€”â€”hashå’Œequalsæ–¹æ³•

```java
   
    @Override
    public int hashCode() {
        return Boolean.hashCode(value);
    }

    public static int hashCode(boolean value) {
        return value ? 1231 : 1237;
    }//é»˜è®¤è§„å®šå¥½çš„

    public boolean equals(Object obj) {
        if (obj instanceof Boolean) {  //ç”¨æ¥æµ‹è¯•ä¸€ä¸ªå¯¹è±¡æ˜¯å¦ä¸ºä¸€ä¸ªç±»çš„å®ä¾‹
            return value == ((Boolean)obj).booleanValue();
        }
        return false;
    }
```

#### 1.1.4.4 æ–¹æ³•â€”â€”â€”â€”è·å–ç³»ç»ŸBooleanå€¼

```java
    /**
     * å½“ä¸”ä»…å½“ä»¥å‚æ•°å‘½åçš„ç³»ç»Ÿå±æ€§å­˜åœ¨ï¼Œä¹Ÿå°±æ˜¯è¯´é¦–å…ˆ
      è®¾ç½®ä¸€ä¸ªç³»ç»Ÿå±æ€§çš„booleanå€¼ï¼Œå½“ç³»ç»Ÿå±æ€§çš„å€¼equal(â€œtrueâ€)æ—¶ï¼Œè¿”å›trueï¼Œå¦åˆ™è¿”å›falseï¼Œå¹¶ä¸”è¿”å›å€¼æ˜¯booleanå‹
    */
    public static boolean getBoolean(String name) {
        boolean result = false;
        try {
            result = parseBoolean(System.getProperty(name));//è¯»å–JVMä¸­çš„ç³»ç»Ÿå±æ€§
        } catch (IllegalArgumentException | NullPointerException e) {
        }
        return result;
    }
```

ä¾‹å­ï¼š

```java
        String s1="false";
        System.setProperty(s1, "false");//è®¾ç½®ä¸€ä¸ªç³»ç»Ÿå±æ€§å€¼
        //å¯¹ç³»ç»Ÿå±æ€§å€¼åˆ¤å®š
        boolean aBoolean2 = Boolean.getBoolean(s1);
        System.out.println(aBoolean2);
```

#### 1.1.4.5 æ–¹æ³•â€”â€”â€”â€”æ¯”è¾ƒé—®é¢˜

```java

    public int compareTo(Boolean b) {
        return compare(this.value, b.value);
    }

    public static int compare(boolean x, boolean y) {
        return (x == y) ? 0 : (x ? 1 : -1);
    }

```

#### 1.1.4.6 æ–¹æ³•â€”â€”â€”â€”é€»è¾‘ä¸æˆ–é

```java
    public static boolean logicalAnd(boolean a, boolean b) {
        return a && b;
    }

    public static boolean logicalOr(boolean a, boolean b) {
        return a || b;
    }

    public static boolean logicalXor(boolean a, boolean b) {
        return a ^ b;
    }
}

```

## 1.2 Numberæºç è§£æ 

### 1.2.0 æ€»ç»“

1. æ€»å…±æœ‰4ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œä¸»è¦ä½œç”¨æ˜¯åœ¨å­ç±»å½“ä¸­å®ç°

1. numberæ˜¯æ‰€æœ‰æ•´å‹çš„çˆ¶ç±»
2. numberæ˜¯æŠ½è±¡æ–¹æ³•

```java
package java.lang;

public abstract class Number implements java.io.Serializable {
    
    public abstract int intValue();
    public abstract long longValue();
    public abstract float floatValue();
    public abstract double doubleValue();

    public byte byteValue() {return (byte)intValue();}
	public short shortValue() {return (short)intValue();}
	
    private static final long serialVersionUID = -8742448824652078965L;
}
```

## 1.3 Integeræºç è§£æ 

å› ä¸ºæ•´å‹å¯ä»¥åˆ†ä¸ºï¼šæ•°å€¼å‹å’Œæµ®ç‚¹å‹ï¼Œé‚£ä¹ˆå°±ä»¥Integerä½œä¸ºä»‹ç»é‡ç‚¹ã€‚

### 1.3.1 å‡½æ•°å¤´

```java
package java.lang;

import java.lang.annotation.Native;

//ç»§æ‰¿äº†Number,é‚£ä¹ˆå°±ä¸€å®šé‡å†™äº†Numberçš„å››ä¸ªæ–¹æ³•

public final class Integer extends Number implements Comparable<Integer> {  

```
### 1.3.2 æˆå‘˜å˜é‡

```java
	//ä½¿ç”¨nativeå…³é”®å­—è¯´æ˜è¿™ä¸ªæ–¹æ³•æ˜¯åŸç”Ÿå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªæ–¹æ³•æ˜¯ç”¨C/C++è¯­è¨€å®ç°çš„ï¼Œå¹¶ä¸”è¢«ç¼–è¯‘æˆäº†DLLæˆ–è€…SOï¼ˆLinuxä¸‹ï¼‰ï¼Œç”±javaå»è°ƒç”¨ã€‚
	
	//å®šä¹‰äº†æœ€å°å€¼å’Œæœ€å¤§å€¼çš„
	@Native public static final int   MIN_VALUE = 0x80000000;//-ï¼ˆ2^31ï¼‰
	@Native public static final int   MAX_VALUE = 0x7fffffff;//ï¼ˆ2^31-1ï¼‰

	//å­—èŠ‚ç æ–‡ä»¶ï¼ŒåŒBooleanæºç 
	@SuppressWarnings("unchecked")
	public static final Class<Integer>  TYPE = (Class<Integer>) Class.getPrimitiveClass("int");
	
	//æ‰€æœ‰å¯èƒ½çš„å°†æ•°å­—è¡¨ç¤ºä¸ºå­—ç¬¦ä¸²çš„å­—ç¬¦é›†åˆã€‚
	final static char[] digits = {
		'0' , '1' , '2' , '3' , '4' , '5' ,
		'6' , '7' , '8' , '9' , 'a' , 'b' ,
		'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,
		'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
		'o' , 'p' , 'q' , 'r' , 's' , 't' ,
		'u' , 'v' , 'w' , 'x' , 'y' , 'z'
	};
```

æ³¨ï¼š 

   1. å­—ç¬¦ä¸²è½¬æ•°å­—çš„åˆæ³•å­—ç¬¦ä¸²åˆ†ä¸º2éƒ¨åˆ†ï¼Œ1ï¼‰-æˆ–+ç¬¦å·ä½ï¼› 2ï¼‰0åˆ°9ï¼Œaåˆ°z;   ç¬¦å·ä½ä¸å‚ä¸è½¬æ¢
   2. åŸºæ•°å¿…é¡»å¤§äº1ï¼Œå› ä¸ºå¦‚æœåŸºæ•°ç­‰äº1ï¼Œé‚£ä¹ˆå°±ä¼šæ— æ„ä¹‰ï¼Œé™·å…¥æ— é™å¾ªç¯ã€‚æ‰€ä»¥ï¼Œ0åˆ°9ä¸€å…±10ä½ï¼Œaåˆ°zä¸€å…±26ä½ï¼Œæ‰€ä»¥ä¸€å…±36ä½ã€‚

### 1.3.3 æˆå‘˜æ–¹æ³•ä¸€â€”â€”intç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²

ä¾‹å­ï¼š
```java
public class NumberSourceExample {
    public static void main(String[] args) {
        Integer integer = new Integer(1);
        String s = Integer.toString(-2, 1);
        System.out.println(s);
        //è¡¨ç¤ºæ˜¯å­—ç¬¦ä¸²å½¢å¼
        System.out.println(s+3);
```

```java
	public static String toString(int i, int radix) {//æ•°å­—ï¼Œè¿›åˆ¶
Character. MIN_RADIX = 2ï¼Œ Character.MAX_RADIX = 36
		//å¦‚æœè¿›åˆ¶æ•°å°äºCharacter.MIN_RADIXæˆ–å¤§äºCharacter.MAX_RADIXï¼Œåˆ™ä½¿ç”¨10è¿›åˆ¶ ã€‚
		//ä¸ºä»€ä¹ˆè¦ä¸€å®šä¿æŒåè¿›åˆ¶å‘¢?
		//è¿™ä¸ªçš„ä¸»è¦åŸå› åœ¨äºæˆ‘ä¹‹åå–æ¨¡å–ä½™å¾ˆå¥½åˆ¤æ–­
		//ä¾‹å­ï¼š25/10---->2,5ï¼Œç„¶åæ”¾åˆ°äº†æ•°ç»„ï¼Œåœ¨ä»æ•°ç»„åˆ°å­—ç¬¦ä¸²å°±å¯ä»¥äº†
		if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)
			radix = 10;
		/* Use the faster version */
		if (radix == 10) {
			return toString(i);
		}

        //ä¸»è¦æ˜¯æ¥æ”¾å…ƒç´ 
		char buf[] = new char[33];
		boolean negative = (i < 0);//åˆ¤æ–­ä¸€ä¸‹å¼•è¿›æ¥çš„æ•°å­—æ˜¯å“ªä¸ªèŒƒå›´çš„
		int charPos = 32;


		æ­£è´Ÿæ•°å‘¢ï¼Œæˆ‘å°±é€šè¿‡booleanæ¥åˆ¤æ–­å°±å¥½äº†------>negative
		å¦‚æœè¯´æ˜¯ä¸ªä½æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥æ”¾å…¥åˆ°æ•°ç»„ä¸­---->buf[charPos] = digits[-i];
		å¦‚æœè¯´æ˜¯åä½æ•°ï¼Œé‚£ä¹ˆå…ˆè¿›è¡Œæ‹†åˆ†ï¼Œç„¶ååœ¨è¿›è¡Œç»„åˆ

		if (!negative) {//negativeä¸ºå‡
			i = -i;
		}

		while (i <= -radix) {
			buf[charPos--] = digits[-(i % radix)];
			i = i / radix;
		}
		buf[charPos] = digits[-i];

		if (negative) {
			buf[--charPos] = '-';
		}

		return new String(buf, charPos, (33 - charPos));//å¯ä»¥å®ç°æ•°ç»„åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢
		//å°†value[]æ•°ç»„æŒ‰ç…§ä¼ å…¥çš„ä¸‹æ ‡å’ŒæŒ‡å®šçš„æˆªå–æ•°ç»„æ•°æ®çš„æ•°é‡è¿›è¡Œæˆªå–ï¼Œå¹¶ä¸”åˆ›å»ºä¸€ä¸ªå†…å®¹ä¸ºæ­¤çš„stringå¯¹è±¡
		//offsetè¡¨ç¤ºç¬¬ä¸€ä¸ªè¢«æˆªå–çš„å­—ç¬¦åœ¨æ•°ç»„value[]ä¸­çš„ä¸‹æ ‡ï¼Œcountè¡¨ç¤ºä»æ­¤å­—ç¬¦å¼€å§‹å‘åæˆªå–çš„å­—ç¬¦çš„æ•°é‡
		//è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼Œç”±ç¬¬äºŒä¸ªå‚æ•°æŒ‡å®šè¿›åˆ¶æ•°ã€‚
	}

	//
	public static String toUnsignedString(int i, int radix) { return Long.toUnsignedString(toUnsignedLong(i), radix); }
	//æ ¹æ®intç±»å‹è½¬æ¢ä¸ºæ— ç¬¦å­—ç¬¦ä¸²ï¼Œæ ¹æ®æ— ç¬¦å­—ç¬¦ä¸²è¿›è¡Œè®¾ç½®
	//ä¸ºä»€ä¹ˆæ˜¯ç§»ä½è¿™ä¹ˆå¤šï¼Œå°±æ˜¯ä¸è¿›åˆ¶æœ‰å…³ç³»
	public static String toHexString(int i) { return toUnsignedString0(i, 4); }
	public static String toOctalString(int i) { return toUnsignedString0(i, 3); }
	public static String toBinaryString(int i) { return toUnsignedString0(i, 1); }

	/**
	 * Convert the integer to an unsigned number.intç±»å‹è½¬æ¢ä¸ºæ— ç¬¦å·å­—ç¬¦ä¸²
	 */
	private static String toUnsignedString0(int val, int shift) {//ç§»ä½ç¬¦
		//Integer.numberOfLeadingZeros(val);
		//ä½œç”¨ä¸ºè¿”å›æ— ç¬¦å·æ•´å‹içš„æœ€é«˜éé›¶ä½å‰é¢çš„0çš„ä¸ªæ•°ï¼ŒåŒ…æ‹¬ç¬¦å·ä½åœ¨å†…ã€‚
		// æ‰€ä»¥magä¸ºvalçš„äºŒè¿›åˆ¶æœ‰æ•ˆä½æ•°
		int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
		//charsè¡¨ç¤ºçš„æ˜¯varè½¬æ¢ä¸º1<<shiftè¿›åˆ¶åçš„é•¿åº¦
		//è¦è¾¾åˆ°è¿™ç§æ•ˆæœåªéœ€è¦mag/shiftå¹¶å‘ä¸Šå–æ•´ä¾¿å¯è¾¾æˆï¼Œï¼ˆå› ä¸ºå¯èƒ½å­˜åœ¨å°æ•°ä½ï¼‰
		//ä¸ºäº†è¾¾åˆ°å‘ä¸Šå–æ•´çš„æ ¼å¼ï¼Œæ‰€ä»¥é‡‡ç”¨((mag + (shift - 1))/shiftè™½ç„¶æˆ‘å†™ä¸å‡ºæ¥è¿™ç§ç®—å¼ï¼Œä½†ç¡®å®å¯ä»¥è¾¾åˆ°è¿™ç§æ•ˆæœ==
		int chars = Math.max(((mag + (shift - 1)) / shift), 1);
		//java9ä¹‹åï¼Œä¸ºäº†èŠ‚çœå­—ç¬¦ä¸²çš„ç©ºé—´ï¼Œé»˜è®¤å¼€å¯å­—ç¬¦ä¸²å‹ç¼©ï¼Œä¹Ÿå°±æ˜¯ç”¨byteï¼ˆ8ä½ï¼‰ä¿å­˜å­—æ¯ã€‚
		// COMPACT_STRINGSé»˜è®¤å¼€å¯ã€‚coderç”±ä¸¤ä¸ªå€¼ï¼šLATIN1ï¼ŒUTF16ã€‚UTF16æ˜¯è‚¯å®šæ²¡æœ‰å¼€å¯å‹ç¼©çš„ã€‚
		//COMPACT_STRINGSé»˜è®¤ä¸ºtrueå³ä½¿ç”¨çš„LATIN1
		if (COMPACT_STRINGS) {
			byte[] buf = new byte[chars];
			//è¯¥æ–¹æ³•å°±æ˜¯å°†valçš„(1<<shift)è¿›åˆ¶å­˜åˆ°byte[]é‡Œ
			formatUnsignedInt(val, shift, buf, 0, chars);
			return new String(buf, LATIN1);
		} else {
			byte[] buf = new byte[chars * 2];
			formatUnsignedIntUTF16(val, shift, buf, 0, chars);
			return new String(buf, UTF16);
		}
	}
	
	//æŠŠä¸€ä¸ªé•¿ç±»å‹è½¬æ¢ä¸ºcharæ•°ç»„
	static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) {
		int charPos = len;
		int radix = 1 << shift;//è¿›åˆ¶
		int mask = radix - 1;
		//å…ˆå¾ªç¯ååˆ¤æ–­
		do {//å› ä½ä¸€å¼€å§‹æ˜¯é•¿åº¦
			buf[offset + --charPos] = Integer.digits[val & mask];
			val >>>= shift;
		} while (val != 0 && charPos > 0);

		return charPos;
	}

	final static char [] DigitTens = {
		'0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
		'1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
		'2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
		'3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
		'4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
		'5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
		'6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
		'7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
		'8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
		'9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
	} ;

	final static char [] DigitOnes = {
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	} ;

	public static String toString(int i) {
		if (i == Integer.MIN_VALUE)
			return "-2147483648";
		int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
		char[] buf = new char[size];
		getChars(i, size, buf);
		return new String(buf, true);
	}

	public static String toUnsignedString(int i) {
		return Long.toString(toUnsignedLong(i));
	}

	
	static void getChars(int i, int index, char[] buf) {
		int q, r;
		int charPos = index;
		char sign = 0;

		if (i < 0) {
			sign = '-';
			i = -i;
		}

		// Generate two digits per iteration
		while (i >= 65536) {
			q = i / 100;
			// really: r = i - (q * 100);
			r = i - ((q << 6) + (q << 5) + (q << 2));
			i = q;
			buf [--charPos] = DigitOnes[r];
			buf [--charPos] = DigitTens[r];
		}

		// Fall thru to fast mode for smaller numbers
		// assert(i <= 65536, i);
		for (;;) {
			q = (i * 52429) >>> (16+3);
			r = i - ((q << 3) + (q << 1));  // r = i-(q*10) ...
			buf [--charPos] = digits [r];
			i = q;
			if (i == 0) break;
		}
		if (sign != 0) {
			buf [--charPos] = sign;
		}
	}

	final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
		99999999, 999999999, Integer.MAX_VALUE };

	// Requires positive x
	static int stringSize(int x) {
		for (int i=0; ; i++)
			if (x <= sizeTable[i])
				return i+1;
	}

	
	public static int parseInt(String s, int radix)
		throws NumberFormatException
	{
		/*
		 * WARNING: This method may be invoked early during VM initialization
		 * before IntegerCache is initialized. Care must be taken to not use
		 * the valueOf method.
		 */

		if (s == null) {
			throw new NumberFormatException("null");
		}

		if (radix < Character.MIN_RADIX) {
			throw new NumberFormatException("radix " + radix +
				" less than Character.MIN_RADIX");
		}

		if (radix > Character.MAX_RADIX) {
			throw new NumberFormatException("radix " + radix +
				" greater than Character.MAX_RADIX");
		}

		int result = 0;
		boolean negative = false;
		int i = 0, len = s.length();
		int limit = -Integer.MAX_VALUE;
		int multmin;
		int digit;

		if (len > 0) {
			char firstChar = s.charAt(0);
			if (firstChar < '0') { // Possible leading "+" or "-"
				if (firstChar == '-') {
					negative = true;
					limit = Integer.MIN_VALUE;
				} else if (firstChar != '+')
					throw NumberFormatException.forInputString(s);

				if (len == 1) // Cannot have lone "+" or "-"
					throw NumberFormatException.forInputString(s);
				i++;
			}
			multmin = limit / radix;
			while (i < len) {
				// Accumulating negatively avoids surprises near MAX_VALUE
				digit = Character.digit(s.charAt(i++),radix);
				if (digit < 0) {
					throw NumberFormatException.forInputString(s);
				}
				if (result < multmin) {
					throw NumberFormatException.forInputString(s);
				}
				result *= radix;
				if (result < limit + digit) {
					throw NumberFormatException.forInputString(s);
				}
				result -= digit;
			}
		} else {
			throw NumberFormatException.forInputString(s);
		}
		return negative ? result : -result;
	}

	
	public static int parseInt(String s) throws NumberFormatException {
		return parseInt(s,10);
	}

	
	public static int parseUnsignedInt(String s, int radix)
		throws NumberFormatException {
		if (s == null)  {
			throw new NumberFormatException("null");
		}

		int len = s.length();
		if (len > 0) {
			char firstChar = s.charAt(0);
			if (firstChar == '-') {
				throw new
					NumberFormatException(String.format("Illegal leading minus sign " +
					"on unsigned string %s.", s));
			} else {
				if (len <= 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits
					(radix == 10 && len <= 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits
					return parseInt(s, radix);
				} else {
					long ell = Long.parseLong(s, radix);
					if ((ell & 0xffff_ffff_0000_0000L) == 0) {
						return (int) ell;
					} else {
						throw new
							NumberFormatException(String.format("String value %s exceeds " +
							"range of unsigned int.", s));
					}
				}
			}
		} else {
			throw NumberFormatException.forInputString(s);
		}
	}

	
	public static int parseUnsignedInt(String s) throws NumberFormatException {
		return parseUnsignedInt(s, 10);
	}

	
	public static Integer valueOf(String s, int radix) throws NumberFormatException {
		return Integer.valueOf(parseInt(s,radix));
	}

	
	public static Integer valueOf(String s) throws NumberFormatException {
		return Integer.valueOf(parseInt(s, 10));
	}

	

	private static class IntegerCache {
		static final int low = -128;
		static final int high;
		static final Integer cache[];

		static {
			// high value may be configured by property
			int h = 127;
			String integerCacheHighPropValue =
				sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
			if (integerCacheHighPropValue != null) {
				try {
					int i = parseInt(integerCacheHighPropValue);
					i = Math.max(i, 127);
					// Maximum array size is Integer.MAX_VALUE
					h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
				} catch( NumberFormatException nfe) {
					// If the property cannot be parsed into an int, ignore it.
				}
			}
			high = h;

			cache = new Integer[(high - low) + 1];
			int j = low;
			for(int k = 0; k < cache.length; k++)
				cache[k] = new Integer(j++);

			// range [-128, 127] must be interned (JLS7 5.1.7)
			assert IntegerCache.high >= 127;
		}

		private IntegerCache() {}
	}

	
	public static Integer valueOf(int i) {
		if (i >= IntegerCache.low && i <= IntegerCache.high)
			return IntegerCache.cache[i + (-IntegerCache.low)];
		return new Integer(i);
	}

	
	private final int value;


	public Integer(int value) {
		this.value = value;
	}

	
	public Integer(String s) throws NumberFormatException {
		this.value = parseInt(s, 10);
	}

	
	public byte byteValue() {
		return (byte)value;
	}
	public short shortValue() {
		return (short)value;
	}
	public int intValue() {
		return value;
	}
	public long longValue() {
		return (long)value;
	}
	public float floatValue() {
		return (float)value;
	}
	public double doubleValue() {
		return (double)value;
	}
	public String toString() {
		return toString(value);
	}
	
	@Override
	public int hashCode() {
		return Integer.hashCode(value);
	}
	public static int hashCode(int value) {
		return value;
	}
	public boolean equals(Object obj) {
		if (obj instanceof Integer) {
			return value == ((Integer)obj).intValue();
		}
		return false;
	}

	
	public static Integer getInteger(String nm) {
		return getInteger(nm, null);
	}
	public static Integer getInteger(String nm, int val) {
		Integer result = getInteger(nm, null);
		return (result == null) ? Integer.valueOf(val) : result;
	}
	
	public static Integer getInteger(String nm, Integer val) {
		String v = null;
		try {
			v = System.getProperty(nm);
		} catch (IllegalArgumentException | NullPointerException e) {
		}
		if (v != null) {
			try {
				return Integer.decode(v);
			} catch (NumberFormatException e) {
			}
		}
		return val;
	}

	
	public static Integer decode(String nm) throws NumberFormatException {
		int radix = 10;
		int index = 0;
		boolean negative = false;
		Integer result;

		if (nm.length() == 0)
			throw new NumberFormatException("Zero length string");
		char firstChar = nm.charAt(0);
		// Handle sign, if present
		if (firstChar == '-') {
			negative = true;
			index++;
		} else if (firstChar == '+')
			index++;

		// Handle radix specifier, if present
		if (nm.startsWith("0x", index) || nm.startsWith("0X", index)) {
			index += 2;
			radix = 16;
		}
		else if (nm.startsWith("#", index)) {
			index ++;
			radix = 16;
		}
		else if (nm.startsWith("0", index) && nm.length() > 1 + index) {
			index ++;
			radix = 8;
		}

		if (nm.startsWith("-", index) || nm.startsWith("+", index))
			throw new NumberFormatException("Sign character in wrong position");

		try {
			result = Integer.valueOf(nm.substring(index), radix);
			result = negative ? Integer.valueOf(-result.intValue()) : result;
		} catch (NumberFormatException e) {
			// If number is Integer.MIN_VALUE, we'll end up here. The next line
			// handles this case, and causes any genuine format error to be
			// rethrown.
			String constant = negative ? ("-" + nm.substring(index))
				: nm.substring(index);
			result = Integer.valueOf(constant, radix);
		}
		return result;
	}

	
	public int compareTo(Integer anotherInteger) {
		return compare(this.value, anotherInteger.value);
	}
	public static int compare(int x, int y) {
		return (x < y) ? -1 : ((x == y) ? 0 : 1);
	}
	
	public static int compareUnsigned(int x, int y) {
		return compare(x + MIN_VALUE, y + MIN_VALUE);
	}
	public static long toUnsignedLong(int x) {
		return ((long) x) & 0xffffffffL;
	}

	public static int divideUnsigned(int dividend, int divisor) {
		// In lieu of tricky code, for now just use long arithmetic.
		return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));
	}
	public static int remainderUnsigned(int dividend, int divisor) {
		// In lieu of tricky code, for now just use long arithmetic.
		return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));
	}
	
	
	//æ•´å‹çš„é•¿åº¦ä¸º32ä½
	@Native public static final int SIZE = 32;
	public static final int BYTES = SIZE / Byte.SIZE;

	
	public static int highestOneBit(int i) {
		// HD, Figure 3-1
		i |= (i >>  1);
		i |= (i >>  2);
		i |= (i >>  4);
		i |= (i >>  8);
		i |= (i >> 16);
		return i - (i >>> 1);
	}
	
	public static int lowestOneBit(int i) {
		// HD, Section 2-1
		return i & -i;
	}

	
	//è¿”å›æ— ç¬¦å·æ•´å‹içš„æœ€é«˜éé›¶ä½å‰é¢çš„0çš„ä¸ªæ•°ï¼ŒåŒ…æ‹¬ç¬¦å·ä½åœ¨å†…
	//â€>>>â€è¡¨ç¤ºæ— ç¬¦å·å³ç§»è¿ç®—ç¬¦ã€‚é«˜ä½è¡¥0
	//é‡‡ç”¨çš„æ˜¯äºŒåˆ†æ³•çš„æ€æƒ³ï¼Œhttps://www.jianshu.com/p/2c1be41f6e59
	public static int numberOfLeadingZeros(int i) {
		// HD, Figure 5-6
		if (i == 0)
			return 32;

		int n = 1;//nä½œä¸ºç¬¦å·ä½å­˜åœ¨
		if (i >>> 16 == 0) { n += 16; i <<= 16; }  //iå³ç§»16ä½   å·¦ç§»èµ‹å€¼
		if (i >>> 24 == 0) { n +=  8; i <<=  8; }  //iå³ç§»24ä½
		if (i >>> 28 == 0) { n +=  4; i <<=  4; }  //iå³ç§»28ä½
		if (i >>> 30 == 0) { n +=  2; i <<=  2; }  //iå³ç§»30ä½
		n -= i >>> 31;//
		return n;
	}
	
	public static int numberOfTrailingZeros(int i) {
		// HD, Figure 5-14
		int y;
		if (i == 0) return 32;
		int n = 31;
		y = i <<16; if (y != 0) { n = n -16; i = y; }
		y = i << 8; if (y != 0) { n = n - 8; i = y; }
		y = i << 4; if (y != 0) { n = n - 4; i = y; }
		y = i << 2; if (y != 0) { n = n - 2; i = y; }
		return n - ((i << 1) >>> 31);
	}

	
	public static int bitCount(int i) {
		// HD, Figure 5-2
		i = i - ((i >>> 1) & 0x55555555);
		i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
		i = (i + (i >>> 4)) & 0x0f0f0f0f;
		i = i + (i >>> 8);
		i = i + (i >>> 16);
		return i & 0x3f;
	}

	
	public static int rotateLeft(int i, int distance) {
		return (i << distance) | (i >>> -distance);
	}
	public static int rotateRight(int i, int distance) {
		return (i >>> distance) | (i << -distance);
	}

	
	public static int reverse(int i) {
		// HD, Figure 7-1
		i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
		i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
		i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
		i = (i << 24) | ((i & 0xff00) << 8) |
			((i >>> 8) & 0xff00) | (i >>> 24);
		return i;
	}

	public static int signum(int i) {
		// HD, Section 2-7
		return (i >> 31) | (-i >>> 31);
	}
	
	public static int reverseBytes(int i) {
		return ((i >>> 24)           ) |
			((i >>   8) &   0xFF00) |
			((i <<   8) & 0xFF0000) |
			((i << 24));
	}
	
	public static int sum(int a, int b) {
		return a + b;
	}
	public static int max(int a, int b) {
		return Math.max(a, b);
	}
	public static int min(int a, int b) {
		return Math.min(a, b);
	}
	@Native private static final long serialVersionUID = 1360826667806852920L;
}

```