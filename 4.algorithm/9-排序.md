# 9 排序算法
## 9.0 排序算法综述
![avatar](./assets/9-1.jpg)

## 9.1 冒泡排序
最古老的排序方式，目前基本不使用了，一般计算都会超时
相关理论就不介绍了，本科一年级老谭的那本红皮书学的第一个算法

<b>一、程序</b>

```java
public class BubbleSort {
    public static void main(String[] args) {
          int[] arr={2,4,1,7,5,3,9};
          sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }

    public static void sort(int[] arr){
        if (arr==null || arr.length<2){
            return;
        }
        //第一个循环主要是进行0~N-1，0~N-2.......
        for (int i = arr.length-1; i >0; i--) {
            //在0~x之间进行遍历凉凉比较
            //  01  12  23  34  45  
            for (int j = 0; j < i; j++) {
                if (arr[j]>arr[j+1]){
                    swap(arr,j,j+1);
                }
            }
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

<b>二、结果展示</b>
```java
       1	2	3	4	5	7	9	
```

<b>三、可能存在的问题</b>
暂无

## 9.2 选择排序
基本思路：假设数组为 [1....n]，每一趟，<font color=red>选择一个值</font>与<font color=red>数组剩下的值</font>进行比较，<font color=#2fe32>互换最小值的索引</font>并<font color=#f7873>交换</font>

<b>一、程序</b>

```java
public class SelectSort {
    public static void main(String[] args) {
        int[] arr={2,4,1,7,5,3,9};
        sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }
    public static void sort(int[] arr){
        for (int i = 0; i < arr.length; i++) {
            int min=i;
            for (int j = i+1; j < arr.length ; j++) {
                min =arr[min] < arr[j]?min:j;
            }
            swap(arr,i,min);
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

<b>二、结果展示</b>
```java
    1	2	3	4	5	7	9
```

<b>三、可能存在的问题</b>
暂无

## 9.3 插入排序

基本思路：左看看右看看
假设数组为 [1....n]，选出一个数值与<font color=green>左侧的值</font><font color=blue>比较交换</font>直到<font color=red>越界为止</font>

![avatar](./assets/9-2.jpg)
此图借鉴了这位大佬的辛苦劳作，再次说明
https://blog.csdn.net/zxm317122667/article/details/83344178

<b>一、程序</b>

```java
ublic class InsertionSort {
    public static void main(String[] args) {
        int[] arr={2,4,1,7,5,3,9};
        Sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }
    public static void Sort(int[] arr){
        //第一个for循环是找到一个基准数值
        for (int i = 1; i < arr.length; i++) {
            //第二个for循环是把基准书左侧的所有数值进行比较并交换
            for (int j = i-1; j >= 0 && arr[j]>arr[j+1]; j--) {
                swap(arr,j,j+1);
            }
        }
    }
    public static void swap(int[] arr,int i,int j){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
}
```

<b>二、结果展示</b>


<b>三、可能存在的问题</b>


## 9.4 归并排序

### 9.4.1 整体思路

假设一个数组arr，将其分开，分别进行排序，然后在进行合并

### 9.4.2 leetcode 912

<b>一、程序</b>

```java
public class Merge {
    public static void main(String[] args) {
      int[] arr={3,9,1,10,5,2,7,3};
      Sort(arr);
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+"\t");
        }
    }

    public static void Sort(int[] arr){
        if (arr==null || arr.length<2){
            return;
        }
     process(arr,0,arr.length-1);
    }

    public static void process(int[] arr,int L,int R){
        if (L==R){
            return;
        }
        int mid=L+((R-L)>>1);
        process(arr,L,mid);
        process(arr,mid+1,R);
        merge(arr,L,R,mid);
    }

    public static void merge(int[] arr,int L,int R,int mid){
        int[] help=new int[R-L+1];
        int i=0;
        int P1=L;
        int P2=mid+1;
        //前++与后++作用不同
        
        while (P1<=mid && P2<=R){
            help[i++]=arr[P1]<=arr[P2]?arr[P1++]:arr[P2++];
        }

        while (P1<=mid){
            help[i++]=arr[P1++];
        }

        while (P2<=R){
            help[i++]=arr[P2++];
        }
        for (int j = 0; j < help.length; j++) {
            arr[L+j]=help[j];
        }
    }
}
```

<b>二、结果展示</b>

```html
1	2	3	3	5	7	9	10
```

<b>三、可能存在的问题</b>


### 9.4.3 归并排序扩展——小和问题

假设一个数组[1,3,4,2,5] 1右边比1大的有4个，就记录4个1（4x1）以此类推

<b>一、程序</b>

```java
public class min {
    public static void main(String[] args) {
        int[] arr={1,3,4,2,5};
        int i = SmallSum(arr);
        System.out.println(i);
    }

    public static int SmallSum(int[] arr){
        if (arr==null || arr.length<2){
            return 0;
        }
       return  process(arr,0,arr.length-1);
    }

    public static int process(int[] arr,int L,int R){
        if (L==R){
            return 0;
        }
        int mid=L+((R-L)>>1);
        return process(arr,L,mid)+
        process(arr,mid+1,R)+
        merge(arr,L,R,mid);
    }

    public static int merge(int[] arr,int L,int R,int mid){
        int[] help=new int[R-L+1];
        int i=0;
        int P1=L;
        int P2=mid+1;
        int res=0;
        //前++与后++作用不同

        while (P1<=mid && P2<=R){
            res+=arr[P1]<arr[P2]?(R-P2+1)*arr[P1]:0;
            help[i++]=arr[P1]<=arr[P2]?arr[P1++]:arr[P2++];
        }

        while (P1<=mid){
            help[i++]=arr[P1++];
        }

        while (P2<=R){
            help[i++]=arr[P2++];
        }
        for (int j = 0; j < help.length; j++) {
            arr[L+j]=help[j];
        }
        return res;
    }
}
```

<b>二、结果展示</b>
```java
     16
```

<b>三、可能存在的问题</b>

### 9.4.4 归并排序扩展——逆序对

<b>一、程序</b>

```java
public class nixudui {
    public static void main(String[] args) {
        int[] arr={7,5,6,4};
        int sum = Sum(arr);
        System.out.println(sum);
    }

    public static int  Sum(int[] arr){
        return process(arr,0,arr.length-1);
    }

    public static int process(int[] arr,int L,int R){
        if (L>=R){
            return 0;
        }
        int mid=L+((R-L)>>1);
        return  process(arr,L,mid)+
         process(arr,mid+1,R)+
        merge(arr,L,R,mid);
    }

    public static int merge(int[] arr,int L,int R,int mid) {
        int[] help=new int[R-L+1];
        int i=0;
        int P1=L;
        int P2=mid+1;
        int res=0;

        while (P1 <= mid && P2 <= R){
            res+=arr[P1]>arr[P2]?mid-P1+1:0;
            help[i++]=arr[P1]<=arr[P2]?arr[P1++]:arr[P2++];
        }

        while (P1<=mid){
            help[i++]=arr[P1++];
        }

        while (P2<=R){
            help[i++]=arr[P2++];
        }
        for (int j = 0; j < help.length; j++) {
            arr[L+j]=help[j];
        }
        return res;
    }
}

```
<b>二、结果展示</b>


<b>三、可能存在的问题</b>




<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>



<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>


<b>一、程序</b>


<b>二、结果展示</b>


<b>三、可能存在的问题</b>